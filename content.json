{"meta":{"title":"爱学兮的小江","subtitle":null,"description":null,"author":"刘振江","url":"https://better-jiang.github.io","root":"/"},"pages":[{"title":"404 Not Found：该页无法显示","date":"2023-02-03T12:14:22.412Z","updated":"2023-02-03T12:14:22.412Z","comments":false,"path":"/404.html","permalink":"https://better-jiang.github.io/404.html","excerpt":"","text":""},{"title":"书单","date":"2023-02-03T12:14:22.435Z","updated":"2023-02-03T12:14:22.435Z","comments":false,"path":"books/index.html","permalink":"https://better-jiang.github.io/books/index.html","excerpt":"","text":""},{"title":"关于","date":"2023-02-03T12:14:22.434Z","updated":"2023-02-03T12:14:22.434Z","comments":false,"path":"about/index.html","permalink":"https://better-jiang.github.io/about/index.html","excerpt":"","text":"123456789101112131415&#123; &quot;name&quot;: &quot;刘振江&quot;, &quot;age&quot;: 27, &quot;gender&quot;: &quot;male&quot;, &quot;profession&quot;: &quot;front-end &amp; vue developer&quot;, &quot;address&quot;: &quot;Shenzhen， China&quot;, &quot;github&quot;: &quot;https://github.com/Better-Jiang&quot;, &quot;email&quot;: &quot;1433539514@qq.com&quot;, &quot;skills&quot;: [ [&quot;html&quot;, &quot;javascript&quot;, &quot;css&quot;], [&quot;vue&quot;, &quot;less&quot;, &quot;node&quot;] ], &quot;devTools&quot;: [&quot;Visual Studio Code&quot;]&#125;"},{"title":"分类","date":"2023-02-03T12:14:22.435Z","updated":"2023-02-03T12:14:22.435Z","comments":false,"path":"categories/index.html","permalink":"https://better-jiang.github.io/categories/index.html","excerpt":"","text":""},{"title":"Repositories","date":"2023-02-03T12:14:23.170Z","updated":"2023-02-03T12:14:23.170Z","comments":false,"path":"repository/index.html","permalink":"https://better-jiang.github.io/repository/index.html","excerpt":"","text":""},{"title":"友情链接","date":"2023-02-03T12:14:23.170Z","updated":"2023-02-03T12:14:23.170Z","comments":true,"path":"links/index.html","permalink":"https://better-jiang.github.io/links/index.html","excerpt":"","text":""},{"title":"标签","date":"2023-02-03T12:14:23.170Z","updated":"2023-02-03T12:14:23.170Z","comments":false,"path":"tags/index.html","permalink":"https://better-jiang.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"继续生活","slug":"继续生活","date":"2023-02-03T12:19:45.000Z","updated":"2023-02-03T12:33:10.477Z","comments":true,"path":"2023/02/03/继续生活/","link":"","permalink":"https://better-jiang.github.io/2023/02/03/%E7%BB%A7%E7%BB%AD%E7%94%9F%E6%B4%BB/","excerpt":"","text":"不管如何，是开心，还是失落，难过，无助，无可奈何？生活总要继续，没有选择。既然别无选择，何不欣然接受。心情好与坏，今天都会过去。工作上，担忧和自在，今天也都会下班。学习不，晨读不，看视频不，做作业不？其实都有的选，怎样选，如何做，计划好的截止日一定会来，成果如何，该后悔，还是恭喜，也造就注定了。因为你欺骗不了自己，永远都不会。所以，好好生活，认真点，用心点，多做些准备，那幻想中的一刻来临时，那预料之外的不幸突袭而至时，那计划好的结果，一步步靠近时，才不致慌张无措，悲喜无常。","categories":[{"name":"上班摸鱼写散文","slug":"上班摸鱼写散文","permalink":"https://better-jiang.github.io/categories/%E4%B8%8A%E7%8F%AD%E6%91%B8%E9%B1%BC%E5%86%99%E6%95%A3%E6%96%87/"}],"tags":[{"name":"一碗鸡汤","slug":"一碗鸡汤","permalink":"https://better-jiang.github.io/tags/%E4%B8%80%E7%A2%97%E9%B8%A1%E6%B1%A4/"}]},{"title":"js疑难治愈","slug":"js疑难治愈","date":"2022-08-20T00:50:12.000Z","updated":"2023-02-03T12:14:22.424Z","comments":true,"path":"2022/08/20/js疑难治愈/","link":"","permalink":"https://better-jiang.github.io/2022/08/20/js%E7%96%91%E9%9A%BE%E6%B2%BB%E6%84%88/","excerpt":"","text":"typeof、instanceof 检测数据类型typeofecma-262 / typeof operator typeof val Result Undefined “undefined” Null “object” Boolean “boolean” Nubmer “number” String “string” Symbol “symbol” BigInt “bigint” Object (does not implement [[Call]]) “object” Ojbect (implements [[Call]]) “function” Instanceofobject instanceof constructor 检测构造函数的prototype 属性是否出现在某个实例对象的原型链上 注意：一个对象的原型链是会改变的 如果obj instanceof Foo返回 true，并不意味着该表达式会永远返回true，因为： Foo.prototype属性的值可能会改变，改变之后的值可能不存在于obj的原型链上，此时原表达式的值就会为false 对象obj的原型链也可能改变，借助__proto__伪属性，可以改变对象的原型链。obj.__proto__=&#123;&#125;，则obj instanceof Foo返回false 12345678910111213141516function A() &#123;&#125;function B() &#123;&#125;let a = new A();a instanceof A; // true, Object.getPrototypeOf(a) === A.prototype; A.protoptype.isPrototypeOf(a) 返回true； A.prototype instanceof Object // true, A.prototype = &#123;&#125;; // 设置 A.prototype 指向一个空对象let a2 = new A();a2 instanceof A; // truea instanceof A; // fasle, A.prototype 指向了一个空对象，这个空对象不在a 的原型链上B.prototype = new A(); // 继承let a3 = new B();a3 instanceof B; // truea3 instancof A; // true, 因为 A.prototype 在 a3 的原型链上 数据的存储形式-堆栈栈 自动分配的内存空间，在代码执行过程中自动释放。 在栈区内存会创建一个JS代码执行的环境，作用域、函数的调用都在栈内存中执行。 JS的基本数据类型，占用空间大小固定，其值是直接保存在栈内存中，按值访问。 对于Ojbect的引用类型，其指针存储在栈内存中，指向堆内存的实际地址，通过引用访问 堆 动态分配堆内存，大小不定，不会自动释放。 堆内存中存储实际对象，在栈内存中存储对象的指针。对象的访问是按引用访问的 在堆区的内存不会自动释放，需要实现垃圾回收机制（GC） 因为在栈区指向的变量等是通过值访问的，当前作用域销毁后变量也就随之销毁，而使用引用访问是堆区变量，在作用域消失后，可能在外层作用域仍然存在引用，不能直接销毁，此时就需要判断此变量是否属于不再需要的变量，从而决定是否进行内存回收。 在Js中主要有 引用计数 和 标记清除 两种垃圾回收算法 深、浅拷贝 递归方式 1234567891011121314151617// 仅 实现 数组、对象的深拷贝，其它 例如Date,Fucntion, RegExpfunction cloneDeep(obj) &#123; let objClone = Array.isArray(obj) ? [] : &#123;&#125;; if (obj &amp;&amp; typeof obj === &#x27;object&#x27;) &#123; for (key in obj) &#123; if (obj.hasOwnProperty(key)) &#123; if(obj[key] &amp;&amp; type typeof obj[key] === &#x27;object&#x27;) &#123; objClone[key] = cloneDeep(obj[key]); &#125;else &#123; objClone[key] = obj[key]; &#125; &#125; &#125; &#125; return objClone;&#125; Object.assign(), 仅深拷贝对象的一级属性 $.extend(true,{},{a:1,b:2}) loadsh.cloneDeep() 编码、解码使用场景在URL地址，不允许出现非ASCII字符，如果URL地址中包含中文字符，就必须堆中文字符进行编码（转义） encodeURI() / encodeURIComponent() encodeURI 通常用于转码整个 URI， 其不会进行编码的字符包括; , / ? : @ &amp; = + $ - _ . ! ~ * &#39; ( ) # encodeURIComponent ，仅用于转码 URI的组成部分（？后面的参数）， 其不会进行编码的字符包括 - _ . ! ~ * &#39; ( ) 如果使用 encodeURIComponent 对整个URL进行编码，/ :字符会被编码； 使用 encodeURL 对整个URL进行编码，&amp; + =不会别编码，这GET、POST请求中是特殊字符，应该被编码。所以正确方法，使用 encodeURIComponent,仅对参数进行编码 123456789let url = &quot;https://developer.mozilla.org/en-US/search?q=闭包&amp;a=123&quot;;console.log(encodeURI(url)); // https://developer.mozilla.org/en-US/search?q=%E9%97%AD%E5%8C%85console.log(encodeURIComponent(url)); // https%3A%2F%2Fdeveloper.mozilla.org%2Fen-US%2Fsearch%3Fq%3D%E9%97%AD%E5%8C%85console.log( &quot;https://developer.mozilla.org/en-US/search?q=&quot; + encodeURIComponent(&quot;闭包&amp;a=123&quot;)); // https://developer.mozilla.org/en-US/search?q=%E9%97%AD%E5%8C%85%26a%3D123 为避免服务器收到不可预知的请求，对任何用户的输入作为URI部分的内容都需要encodeURIComponent 进行转义。例如，用户可能输入闭包&amp;a=123作为参数q的值，如果不对此内容进行转义，服务器得到的将是q=闭包&amp;a=123,即两个键值对（q=闭包，a=123），而不是一个键值对(q=闭包&amp;a=123) 隐式类型转换隐式类型转换 是在一定场景下，js运行环境会自动调用👇🏻几个方法，尝试转换成期望的数据类型 ToString, 其他类型的值转换为字符串类型 null， “null” undefined，”undefined”, 布尔类型，”true”, “false” 数字类型，10，”10”, 1e21 , “1e+21” 数组，相当于调用Array.prototype.join()方法，[1,2,3] 转换 “1,2,3”, 空数组[]转换为空字符串’’， 数组中的null,undefined，会被当做 &quot;&quot;空字符串处理 对象，相当于调用Object.prototype.toString()，返回”[object Object]” ToNumber null, 0 undefined， NaN 字符串，纯数字形式，转换为对应的数字，空字符串转换为0， 否则按失败处理，转换为 NaN 数组，首先会被转换为原始类型（ToPrimitive）,然后在根据转换后的原始类型处理 ToBoolean js中的假值，只有 false,null,undefined,&quot;&quot;,0,NaN， 其它值转化为布尔值都为true ToPrimitive， 对象类型（对象、数组）转化为原始类型的操作 当对象类型需要转化为原始类型时，会向查找对象的valueOf方法，如果valueOf()方法返回原始类型的值，则结果就是该值 如果对象的valueOf()不存在，或者valueOf()方法返回的不是原始类型的值，则会去调用对象的toString()方法，且遵循对象的ToString规则，则toString()的返回值作为ToPrimitive的结果","categories":[{"name":"技术总结","slug":"技术总结","permalink":"https://better-jiang.github.io/categories/%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%93/"}],"tags":[{"name":"面试","slug":"面试","permalink":"https://better-jiang.github.io/tags/%E9%9D%A2%E8%AF%95/"}]},{"title":"小白笔记-grunt","slug":"小白笔记-grunt","date":"2022-08-13T01:56:40.000Z","updated":"2023-02-03T12:14:22.424Z","comments":true,"path":"2022/08/13/小白笔记-grunt/","link":"","permalink":"https://better-jiang.github.io/2022/08/13/%E5%B0%8F%E7%99%BD%E7%AC%94%E8%AE%B0-grunt/","excerpt":"","text":"Grunt 侧重对整个过程的控制管理，是任务类型的的打包工具，代码检查、预编译、合并压缩；生成雪碧图、sourceMap、版本管理；运行单元测试、监控等。 Grunt 执行异步任务 执行异步任务的回调函数不能使用箭头函数 异步任务完成需要调用任务内置函数告知已经完成 Grunt 标记任务失败 同步任务通过 return false来标记任务失败 异步任务通过内置函数 done 传递 false 参数 ***done(false)**来标记任务失败 如果多任务执行，只要标记任务失败，后续任务将不在执行。添加 --force选项，会强制执行后续任务 Grunt 设置配置 使用 initConfig 方法去配置参数 使用 grunt.config 方法来获取参数 Grunt 插件使用 Grunt 插件命名规则 grunt-contrib-任务名 或 grunt-任务名 Grunt 常用插件 样式预编译、JS编译、文件监听 使用插件前，需要使用**loadNpmTasks**方法加载插件，然后才可以使用。load-grunt-tasks插件可自动加载所有插件 npxnpx是一个npm包执行器，有如下特点： 临时安装可执行依赖包，不用全局安装，故不用担心长期的污染 可以执行依赖包中的命令，安装完成自动运行 自动加载 node_modules中依赖包，而无需指定$PATH,还可以指定node.js版本，命令的版本。 1234567// 指定uglify-js 版本，npx 运行时，会到node_modules/.bin路径 和 环境变量$PATH里检查命令是否存。// 如果找不到，会临时安装，然后执行npx uglify-js@3.1.0 ./test/test_npx.js -o ./test/haha.js// 指定node版本的npx -p node@8 npm run build GulpGulp在4.0版本之后，无需引入gulp，然后在注册任务才可以调用，现在可直接通过exports导出任务。且取消了同步任务，约定每次任务执行完成后，都要调用回调函数的方法参数才可以。 Gulp 异步任务的多种形式 回调函数，标记任务失败，在方法done中传入错误对象。其后面的任务也不会在执行 promisePromise.resolve() 任务成功； Promise.reject() 任务失败 async、await 使用gulp读取文件操作时，返回文件流，gulp会自动在流上注册一个end事件 1234567891011121314151617// 返回文件流 const fs = require(&#x27;fs&#x27;); exports.stream = () =&gt; &#123; const readstream = fs.createReadStream(&quot;package.json&quot;); const writestream = fs.createWriteStream(&quot;temp.txt&quot;); readstream.pipe(writestream); return readstream; &#125; exports.stream2 = (done) =&gt; &#123; const readstream = fs.createReadStream(&quot;package.json&quot;); const writestream = fs.createWriteStream(&quot;temp2.txt&quot;); readstream.pipe(writestream); readstream.on(&quot;end&quot;, () =&gt; &#123; done() &#125;) &#125; gulp 文件操作Gulp使用 src方法匹配到源文件，然后通过node.js的pipe将文件流 输送到 gulp插件（编译，压缩），最后通过dest方法，将编译好的文件输出到指定编译目录中。 webpack用于JavaScript应用程序的静态模块打包工具。他会在内部从一个或多个入口点构建一个依赖图（dependency graph）,然后将项目中所需要的每一个模块组合成一个或多个bundles,它们均为静态资源。对webpack而言，一起文件都是一个个模块，根据个模块之间的依赖关系，对模块进行组合和打包，最终输出浏览器能使用的静态资源。 context 基础目录 webpack的基础目录，必须是绝对路径，用于从配置中解析 入口点（entry）和 加载器（loader）,默认为当前目录。 123456789101112const path = require(&quot;path&quot;);console.log(&#x27;__dirname&#x27;,__dirname);module.exports = &#123; mode: &quot;development&quot;, // 基础目录 &quot;/home/project/webpack-config/config/src&quot; context: path.resolve(__dirname,&quot;src&quot;), entry: &quot;./src/index.js&quot;, output: &#123; filename: &quot;main.js&quot;, path: path.resolve(__dirname,&quot;../dist&quot;) &#125;&#125; 基础目录 为 /home/project/webpack-config/config/src, 运行 npx webpack --config ./config/webpack.config-1.js,会报错，找不到./src/index.js. context,entry做如下修改，在执行 npx webpack 命令，编译正常。由此可知，context 是作为 entry 和 loader 的 根目录 123456789101112const path = require(&quot;path&quot;);console.log(&#x27;__dirname&#x27;,__dirname);console.log(&quot;__filename&quot;,__filename);module.exports = &#123; mode: &quot;development&quot;, context: path.resolve(__dirname,&quot;../src&quot;), entry: &quot;./index.js&quot;, output: &#123; filename: &quot;main.js&quot;, path: path.resolve(__dirname, &quot;../dist&quot;) &#125;&#125; entry 入口文件entry支持字符串、字符串数组、对象、函数类型 string 类型 1entry: &quot;./src/index.js&quot; 字符串数组 类型两个文件会合并打包为一个chunk文件 1entry: [&quot;./src/index.js&quot;, &quot;./src/calc/js&quot;] 对象类型entry 对象有2个入口，入口 a 和 b, 通过 dependOn 配置 b 依赖于 a, 构建是会等 a构建完成后再启动b的构建。entry 配置有多个入口文件，所以输出output的配置也要满足，使用[name]占位符来确保每个文件具有唯一代名称。 12345678910111213141516const path = require(&quot;path&quot;);module.exports = &#123; mode: &quot;development&quot;, context: path.resolve(__dirname,&quot;..&quot;), entry: &#123; b: &#123; dependOn: &quot;a&quot;, import: &quot;./src/calc.js&quot; &#125;, a: &quot;./src/index.js&quot; &#125;, output: &#123; filename: &quot;[name].js&quot;, path: path.resolve(__dirname, &quot;../dist&quot;) &#125;&#125; output 输出output属性最低要求，设置为一个对象，配置输出文件的文件名,默认输出目录dist 123output: &#123; filename: &quot;bundle.js&quot;&#125; 如果配置2个或多个入口文件，则应该使用 占位符来保证每个文件具有唯一的名称 生成 hash 文件名, 例如 b.ec5d198e69.js 12345678910111213141516const path = require(&quot;path&quot;);module.exports = &#123; mode: &quot;development&quot;, context: path.resolve(__dirname,&quot;..&quot;), entry: &#123; b: &#123; dependOn: &quot;a&quot;, import: &quot;./src/calc.js&quot; &#125;, a: &quot;./src/index.js&quot; &#125;, output: &#123; filename: &quot;[name].[contenthash:10].js&quot;, path: path.resolve(__dirname, &quot;../dist&quot;) &#125;&#125; 常用的hash 占位符有: hash, hash跟整个项目构建相关，每次构建生成的文件hash值都一样，只要项目中文件内容发生变化，hash值也会变化 contenthash, 由文件内容产生的hash值，内容不同产生的值也不一样 chunkhash, 每一次构建后生成的hash值都不一样，即使文件内容没有改变，不利于浏览器的缓存 生成 umd 模式的文件123456789101112131415161718192021const path = require(&quot;path&quot;);module.exports = &#123; mode: &quot;development&quot;, context: path.resolve(__dirname,&quot;..&quot;), entry: &quot;./src/index.js&quot;, // output: &#123; // library: &quot;lgUtils&quot;, // libraryTarget: &quot;umd&quot;, // filename: &#x27;[name].[hash:6].js&#x27;, // path: path.resolve(__dirname,&quot;../dist&quot;) // &#125; output: &#123; library: &#123; type: &#x27;umd&#x27;, name: &#x27;lqUtils&#x27; &#125;, filename: &#x27;[name].[hash:6].js&#x27;, path: path.resolve(__dirname,&quot;../dist&quot;) &#125;&#125; 执行 npx webpack --config ./config/webpack.config-6.js, 生成 main.7f77f8.jsjs文件，新建index.html并引入打包后的js文件，控制台打印lqUtils,可看到输出结果。表面 打包的js文件是 umd格式，支持浏览器。 js文件如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778/* * ATTENTION: The &quot;eval&quot; devtool has been used (maybe by default in mode: &quot;development&quot;). * This devtool is neither made for production nor for readable output files. * It uses &quot;eval()&quot; calls to create a separate source file in the browser devtools. * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/) * or disable the default devtool with &quot;devtool: false&quot;. * If you are looking for production-ready output files, see mode: &quot;production&quot; (https://webpack.js.org/configuration/mode/). */(function webpackUniversalModuleDefinition(root, factory) &#123; if(typeof exports === &#x27;object&#x27; &amp;&amp; typeof module === &#x27;object&#x27;) module.exports = factory(); else if(typeof define === &#x27;function&#x27; &amp;&amp; define.amd) define([], factory); else if(typeof exports === &#x27;object&#x27;) exports[&quot;lqUtils&quot;] = factory(); else root[&quot;lqUtils&quot;] = factory();&#125;)(self, () =&gt; &#123;return /******/ (() =&gt; &#123; // webpackBootstrap/******/ &quot;use strict&quot;;/******/ var __webpack_modules__ = (&#123;/***/ &quot;./src/index.js&quot;:/*!**********************!*\\ !*** ./src/index.js ***! \\**********************//***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) =&gt; &#123;eval(&quot;__webpack_require__.r(__webpack_exports__);\\n/* harmony export */ __webpack_require__.d(__webpack_exports__, &#123;\\n/* harmony export */ \\&quot;a\\&quot;: () =&gt; (/* binding */ a),\\n/* harmony export */ \\&quot;say\\&quot;: () =&gt; (/* binding */ say)\\n/* harmony export */ &#125;);\\nconst say = (msg) =&gt; &#123;\\n return `hello $&#123;msg&#125;`;\\n&#125;\\nconst a = \\&quot;jiang2\\&quot;;\\n\\n\\n//# sourceURL=webpack://lqUtils/./src/index.js?&quot;);/***/ &#125;)/******/ &#125;);/************************************************************************//******/ // The require scope/******/ var __webpack_require__ = &#123;&#125;;/******/ /************************************************************************//******/ /* webpack/runtime/define property getters *//******/ (() =&gt; &#123;/******/ // define getter functions for harmony exports/******/ __webpack_require__.d = (exports, definition) =&gt; &#123;/******/ for(var key in definition) &#123;/******/ if(__webpack_require__.o(definition, key) &amp;&amp; !__webpack_require__.o(exports, key)) &#123;/******/ Object.defineProperty(exports, key, &#123; enumerable: true, get: definition[key] &#125;);/******/ &#125;/******/ &#125;/******/ &#125;;/******/ &#125;)();/******/ /******/ /* webpack/runtime/hasOwnProperty shorthand *//******/ (() =&gt; &#123;/******/ __webpack_require__.o = (obj, prop) =&gt; (Object.prototype.hasOwnProperty.call(obj, prop))/******/ &#125;)();/******/ /******/ /* webpack/runtime/make namespace object *//******/ (() =&gt; &#123;/******/ // define __esModule on exports/******/ __webpack_require__.r = (exports) =&gt; &#123;/******/ if(typeof Symbol !== &#x27;undefined&#x27; &amp;&amp; Symbol.toStringTag) &#123;/******/ Object.defineProperty(exports, Symbol.toStringTag, &#123; value: &#x27;Module&#x27; &#125;);/******/ &#125;/******/ Object.defineProperty(exports, &#x27;__esModule&#x27;, &#123; value: true &#125;);/******/ &#125;;/******/ &#125;)();/******/ /************************************************************************//******/ /******/ // startup/******/ // Load entry module and return exports/******/ // This entry module can&#x27;t be inlined because the eval devtool is used./******/ var __webpack_exports__ = &#123;&#125;;/******/ __webpack_modules__[&quot;./src/index.js&quot;](0, __webpack_exports__, __webpack_require__);/******/ /******/ return __webpack_exports__;/******/ &#125;)();&#125;); tipsnpm view webpack devDependencies,npm view webpack dependencies 查看webpack的依赖 脚手架工具inquirer, 询问交互ejs， 模板解析在 package.json中，bin字段指向可执行文件，其值是字符串，或者 对象。 对象形式，myjs-cli 即为脚手架的名字字符串，脚手架的名字 就是 name的值执行脚手架，就会执行在package.json 中配置项 bin 指向的可执行文件 “bin”: { “myjs-cli”: “bin/index.js” },process.cwd()，node 运行时的路径 webpack 原理webpack 原理自定义 loader， plugin简易的 webpackwebpack 核心配置 entry, 可执行模块 或者 库的入口chunk, 多个文件组成的一个代码块。可以将可执行模块和它所依赖的模块组合成一个chunkloader， 文件转换器。 es6 转换 为 es5, scass 转换为 cssplugin, 扩展webpack功能的插件。 在 webpack 构建的生命周期节点上加入扩展hook，添加功能webpack 构建过程？初始化参数， 解析webpack 配置参数，合并shell传入和webpack.config.js 文件配置的参数，形成最后的配置结果开始编译通过上一步得到 的参数 初始化 compiler 对象注册所有配置的插件， 插件 监听webpack构建生命周期的事件节点，做出相应的处理执行对象的run方法开始执行编译确认入口， 从配置的 entry 入口，开始解析文件，构建AST语法树，找出依赖，递归下去编译模块， 递归中 根据文件类型和loader配置，调用所有配置的loader对文件进行转换，在找出该模块依赖的模块，在递归本步骤，直到所有入口依赖的文件都经过处理完成模块编译并输出，递归完成后，等到每个文件结果，包含每个模块以及它们之间的依赖关系，根据 entry 配置生成代码块 chunk输出完成， 输出所有的chunk 到文件系统自定义 pluginsplugins 的钩子函数分为 compiler钩子，和 compilation钩子，每个钩子还有很多各自的钩子周期函数，在不同钩子周期函数中，webpack 进行不同的操作。 如何创建 webpack plugin？构建函数扩展 apply 方法指定webpack 自身的事件钩子处理 webpack 内部实例的特定数据功能完成后，调用 webpack 提供的回调函数","categories":[{"name":"烂笔头","slug":"烂笔头","permalink":"https://better-jiang.github.io/categories/%E7%83%82%E7%AC%94%E5%A4%B4/"}],"tags":[{"name":"grunt","slug":"grunt","permalink":"https://better-jiang.github.io/tags/grunt/"}]},{"title":"去了解ESLint吧","slug":"去了解ESLint吧","date":"2022-08-04T06:09:15.000Z","updated":"2023-02-03T12:14:22.424Z","comments":true,"path":"2022/08/04/去了解ESLint吧/","link":"","permalink":"https://better-jiang.github.io/2022/08/04/%E5%8E%BB%E4%BA%86%E8%A7%A3ESLint%E5%90%A7/","excerpt":"","text":"参考文章 ESLint工作原理探讨-知乎 AST in Modern JavaScript -知乎 原理ESlint 使用Espress把js语法转换成AST，然后通过 AST selectors找到静态代码中内容，再根据 rule 的规则去判断这一段js 是否符合规范。 ESLint 使用 Espree 解析 JavaScript ESLint 使用 AST 去分析代码中的模式 ESLint 是完全插件化的，每个规则都是一个插件，并且可以在运行时添加更多规则 Configuring ESLintESLint 是完全可配置的，有2中方式开配置ESLint: 使用JavaScript注释，把配置信息直接嵌入到代码源文件中 指定一个独立的*配置文件**（.eslintrc.） ESLint中可配置以下选项： 运行环境（Environments）， 每种运行环境都带有一组特定的预定义全局变量 全局变量（Globals）， 运行期间可访问的其他全局变量 规则 （Rules），启用了哪些规则，以及其错误级别 插件（Plugins），使用了哪些第三方插件定义的额外规则、运行环境、配置等 配置文件ESlint配置文件支持多种文件格式,如果存在多个配置文件，优先级顺序按如下： JavaScript， .eslintrc.js， 导出一个配置对象。export an object JavaScript(ESM)， .eslintrc.cjs, 在 package.json 中 指定 &quot;type&quot;:&quot;module&quot; YAML，.eslintrc.yaml, eslintrc.yml JSON，.eslintrc.json, ESLint中的json 文件可使用js格式的注释 package.json， eslintConfig属性，指定配置文件路径 2中使用方式 ESLint 会自动查找检测配置文件.eslintrc.*,直到 系统的根目录~/ (**除非 指定了root:true**） 命令行CLI —config参数 eslint -c muconfig.json myfiletotest.js 共享设置在ESlint配置文件中设置可共享的对象，可提供给所有正在执行的规则去访问，可用于自定义规则中想要去访问相同信息。 123&#123; &quot;settings&quot;: &#123;&#125;&#125; 层叠配置1234567your-project├── .eslintrc.json├── lib│ └── source.js└─┬ tests ├── .eslintrc.json └── test.js 默认情况下，距离要检测文件最近的.eslintrc.*文件优先级最高，其次才是其父目录，直到根目录，当发现配置文件中指定&quot;root&quot;:true,会停止寻找。 配置层次结构优先级(高-&gt;低)： 行内配置 /*eslint-enable*/ 命令行选项 --global,—config,--rule 项目级别 配置 .eslintrc.*或package.json与要检测的文件 在同一目录中 继续 在 其祖先目录中寻找 .eslintrc.*、package.json文件，直到根目录（系统上当前用户的主目录(~/)也被视为根目录，即需要寻找到此停止，在8.0版本，该目录中的配置将被忽略）,或者找到&quot;root&quot;:true的配置文件 扩展配置文件一个配置一旦扩展，就可以继承另一个配置文件的所有特征(规则、插件、选项)，且可以修改所有选项。有3中配置： 基本配置，扩展的配置 派生配置，扩展基本配置的配置 最后生成的配置：将派生配置合并到基本配置的结果(the result of merging the derived configurantion into the base configuration.) extends 属性值（2种） 字符串，(配置文件的路径、可共享的配置名称、eslint:recommended(推荐的规则)、eslint:all(所有规则)) 字符串数组，每个附加配置都扩展了它前面的配置 extends属性中的 相对路径、可共享的配置名称，是从它们出现的配置文件的位置解析 配置名称可省略eslint-config-前缀，例如，airbnb 解析为eslint-config-airbnb 使用可共享的配置（npm包）可共享的配置是一个npm包，并导出一个配置对象，必须安装在项目的跟目录中。 extends的属性值 可以省略包的eslint-config-前缀 如何创建一个可共享的配置？ 1、create a Node.js module, 名字以eslint-config-开头，例如 eslint-config-jiang。 npm scoped modules也是支持的，可以命名为@scope/eslint-config，或以其作为前缀。例如 @jiang/eslint-config @jiang/eslint-config-myconfig 2、新建index.js文件，并导出一个配置对象 123456789101112131415module.exports = &#123; globals: &#123; MyGlobales: true, Jiang: &#123; name: &quot;jiang&quot;, age: 29, friends: [&quot;Aime&quot;, &quot;Jack&quot;] &#125; &#125;, rule: &#123; semi: [2, &quot;always&quot;], &quot;no-debugger&quot;: [1], &quot;no-alert&quot;: [0] &#125;&#125; 3、发布可共享的配置包 发布到npm，在package.json 使用peerDependencies字段去声明对eslint的依赖。为了兼容性，声明依赖项推荐使用&gt;=范围语法，即最定要求的eslint版本 12345&#123; &quot;peerDependencies&quot;: &#123; &quot;eslint&quot; : &quot;&gt;= 8&quot; &#125;&#125; 如果共享配置也依赖与其他插件,要将其指定为 前置依赖peerDependency。 如果，共享配置依赖于第三方解析器或其他可共享配置，要将这些包指定为项目依赖dependencies 本地测试，要发布的包 npm link / pnpm link, 全局链接模块，使当前本地包可在系统范围内或其他位置访问 在需要使共享配置的的项目中，npm link eslint-config-myconfig 4、使用可共享的配置 123&#123; &quot;extends&quot;: &quot;eslint-config-myconfig&quot;&#125; 共享多个配置可以在同一个npm包共享多个配置，且为包指定默认配置。例如，新建一个特定配置文件my-special-config.js，包名eslint-config-jiang,通过以下方式访问附加配置 123&#123; &quot;extends&quot;: &quot;jiang/my-special-config&quot;&#125; 如果是 scoped modules，则不能省略 eslint-config命名空间。假设包名@jiang/eslint-config, 123&#123; &quot;extends&quot;: &quot;@jiang/eslint-config/my-special-config&quot;&#125; 使用来自插件的规则插件 也是一个 npm包，可给ESLint添加新规则，导出可共享配置。要确保该npm包安装在ESLint能访问到的目录下。 plugins属性值可以省略包名的前缀eslint-plugin- extends属性值 格式: plugin: + 包名 + / + 配置名称, 例如 plugin:react/recommended 123456789101112&#123; &quot;plugins&quot;: [ &quot;react&quot; ], &quot;extends&quot;: [ &quot;eslint:recommended&quot;, &quot;plugin:react/recommended&quot; ], &quot;rules&quot;: &#123; &quot;react/no-set-state&quot;: &quot;off&quot; &#125;&#125; 配置名称, 在configs选项设置 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566module.exports = &#123; deprecatedRules, rules: allRules, configs: &#123; recommended: &#123; plugins: [ &#x27;react&#x27;, ], parserOptions: &#123; ecmaFeatures: &#123; jsx: true, &#125;, &#125;, rules: &#123; &#x27;react/display-name&#x27;: 2, &#x27;react/jsx-key&#x27;: 2, &#x27;react/jsx-no-comment-textnodes&#x27;: 2, &#x27;react/jsx-no-duplicate-props&#x27;: 2, &#x27;react/jsx-no-target-blank&#x27;: 2, &#x27;react/jsx-no-undef&#x27;: 2, &#x27;react/jsx-uses-react&#x27;: 2, &#x27;react/jsx-uses-vars&#x27;: 2, &#x27;react/no-children-prop&#x27;: 2, &#x27;react/no-danger-with-children&#x27;: 2, &#x27;react/no-deprecated&#x27;: 2, &#x27;react/no-direct-mutation-state&#x27;: 2, &#x27;react/no-find-dom-node&#x27;: 2, &#x27;react/no-is-mounted&#x27;: 2, &#x27;react/no-render-return-value&#x27;: 2, &#x27;react/no-string-refs&#x27;: 2, &#x27;react/no-unescaped-entities&#x27;: 2, &#x27;react/no-unknown-property&#x27;: 2, &#x27;react/no-unsafe&#x27;: 0, &#x27;react/prop-types&#x27;: 2, &#x27;react/react-in-jsx-scope&#x27;: 2, &#x27;react/require-render-return&#x27;: 2, &#125;, &#125;, all: &#123; plugins: [ &#x27;react&#x27;, ], parserOptions: &#123; ecmaFeatures: &#123; jsx: true, &#125;, &#125;, rules: activeRulesConfig, &#125;, &#x27;jsx-runtime&#x27;: &#123; plugins: [ &#x27;react&#x27;, ], parserOptions: &#123; ecmaFeatures: &#123; jsx: true, &#125;, jsxPragma: null, // for @typescript/eslint-parser &#125;, rules: &#123; &#x27;react/react-in-jsx-scope&#x27;: 0, &#x27;react/jsx-uses-react&#x27;: 0, &#125;, &#125;, &#125;,&#125;; 使用eslint:recommended​ 启用eslint推荐的规则子集，rules页中复选框选中的规则 使用eslint:all​ 启用当前eslint版本中所有的核心规则 更精细化配置，overrides属性使用overrides属性，根据配置中文件 glob模式覆盖规则 1234567891011121314&#123; &quot;rules&quot;: &#123; quotes:[&quot;error&quot;, &quot;dobule&quot;] &#125;, &quot;overrides&quot;: [ &#123; &quot;files&quot;: [&quot;foo/*.js&quot;], &quot;excludedFiles&quot;: &quot;*.test.js&quot;, &quot;rules&quot;: &#123; &quot;quotes&quot;: [&quot;error&quot;, &quot;single&quot;] &#125; &#125; ]&#125; 忽略ESlint规则检查1、.eslintignore 文件在项目根目录下创建.eslintignore文件中指定要忽略检查的文件或目录。 每一行一个glob模式，指定要忽略的路径 # 开头的行 被视为注释 路径时相对于当前工作目录的 !是否定模式 1234# Ignore build files except build/test.js!.build.build/*!.build/test.js 2、配置文件 中的ignorePatterns使用ignorePatterns指定要忽略检查的文件 123&#123; &quot;ignorePatterns&quot;: [&quot;*.ignore.js&quot;]&#125; 参考文章 ESLint工作原理探讨-知乎 AST in Modern JavaScript -知乎 原理ESlint 使用Espress把js语法转换成AST，然后通过 AST selectors找到静态代码中内容，再根据 rule 的规则去判断这一段js 是否符合规范。 ESLint 使用 Espree 解析 JavaScript ESLint 使用 AST 去分析代码中的模式 ESLint 是完全插件化的，每个规则都是一个插件，并且可以在运行时添加更多规则 Configuring ESLintESLint 是完全可配置的，有2中方式开配置ESLint: 使用JavaScript注释，把配置信息直接嵌入到代码源文件中 指定一个独立的*配置文件**（.eslintrc.*）* ESLint中可配置以下选项： 运行环境（Environments）， 每种运行环境都带有一组特定的预定义全局变量 全局变量（Globals）， 运行期间可访问的其他全局变量 规则 （Rules），启用了哪些规则，以及其错误级别 插件（Plugins），使用了哪些第三方插件定义的额外规则、运行环境、配置等 配置文件ESlint配置文件支持多种文件格式,如果存在多个配置文件，优先级顺序按如下： JavaScript， .eslintrc.js， 导出一个配置对象。export an object JavaScript(ESM)， .eslintrc.cjs, 在 package.json 中 指定 &quot;type&quot;:&quot;module&quot; YAML，.eslintrc.yaml, eslintrc.yml JSON，.eslintrc.json, ESLint中的json 文件可使用js格式的注释 package.json， eslintConfig属性，指定配置文件路径 2中使用方式 ESLint 会自动查找检测配置文件.eslintrc.*,直到 系统的根目录~/ (除非 指定了root:true） 命令行CLI —config参数 eslint -c muconfig.json myfiletotest.js 共享设置在ESlint配置文件中设置可共享的对象，可提供给所有正在执行的规则去访问，可用于自定义规则中想要去访问相同信息。 123&#123; &quot;settings&quot;: &#123;&#125;&#125; 层叠配置1234567your-project├── .eslintrc.json├── lib│ └── source.js└─┬ tests ├── .eslintrc.json └── test.js 默认情况下，距离要检测文件最近的.eslintrc.*文件优先级最高，其次才是其父目录，直到根目录，当发现配置文件中指定&quot;root&quot;:true,会停止寻找。 配置层次结构优先级(高-&gt;低)： 行内配置 /*eslint-enable*/ 命令行选项 --global,—config,--rule 项目级别 配置 .eslintrc.*或package.json与要检测的文件 在同一目录中 继续 在 其祖先目录中寻找 .eslintrc.*、package.json文件，直到根目录（系统上当前用户的主目录(~/)也被视为根目录，即需要寻找到此停止，在8.0版本，该目录中的配置将被忽略）,或者找到&quot;root&quot;:true的配置文件 扩展配置文件一个配置一旦扩展，就可以继承另一个配置文件的所有特征(规则、插件、选项)，且可以修改所有选项。有3中配置： 基本配置，扩展的配置 派生配置，扩展基本配置的配置 最后生成的配置：将派生配置合并到基本配置的结果(the result of merging the derived configurantion into the base configuration.) extends 属性值（2种） 字符串，(配置文件的路径、可共享的配置名称、eslint:recommended(推荐的规则)、eslint:all(所有规则)) 字符串数组，每个附加配置都扩展了它前面的配置 extends属性中的 相对路径、可共享的配置名称，是从它们出现的配置文件的位置解析 配置名称可省略eslint-config-前缀，例如，airbnb 解析为eslint-config-airbnb 使用可共享的配置（npm包）可共享的配置是一个npm包，并导出一个配置对象，必须安装在项目的跟目录中。 extends的属性值 可以省略包的eslint-config-前缀 如何创建一个可共享的配置？ 1、create a Node.js module, 名字以eslint-config-开头，例如 eslint-config-jiang。 npm scoped modules也是支持的，可以命名为@scope/eslint-config，或以其作为前缀。例如 @jiang/eslint-config @jiang/eslint-config-myconfig 2、新建index.js文件，并导出一个配置对象 123456789101112131415module.exports = &#123; globals: &#123; MyGlobales: true, Jiang: &#123; name: &quot;jiang&quot;, age: 29, friends: [&quot;Aime&quot;, &quot;Jack&quot;] &#125; &#125;, rule: &#123; semi: [2, &quot;always&quot;], &quot;no-debugger&quot;: [1], &quot;no-alert&quot;: [0] &#125;&#125; 3、发布可共享的配置包 发布到npm，在package.json 使用peerDependencies字段去声明对eslint的依赖。为了兼容性，声明依赖项推荐使用&gt;=范围语法，即最定要求的eslint版本 12345&#123; &quot;peerDependencies&quot;: &#123; &quot;eslint&quot; : &quot;&gt;= 8&quot; &#125;&#125; 如果共享配置也依赖与其他插件,要将其指定为 前置依赖peerDependency。 如果，共享配置依赖于第三方解析器或其他可共享配置，要将这些包指定为项目依赖dependencies 本地测试，要发布的包 npm link / pnpm link, 全局链接模块，使当前本地包可在系统范围内或其他位置访问 在需要使共享配置的的项目中，npm link eslint-config-myconfig 4、使用可共享的配置 123&#123; &quot;extends&quot;: &quot;eslint-config-myconfig&quot;&#125; 共享多个配置可以在同一个npm包共享多个配置，且为包指定默认配置。例如，新建一个特定配置文件my-special-config.js，包名eslint-config-jiang,通过以下方式访问附加配置 123&#123; &quot;extends&quot;: &quot;jiang/my-special-config&quot;&#125; 如果是 scoped modules，则不能省略 eslint-config命名空间。假设包名@jiang/eslint-config, 123&#123; &quot;extends&quot;: &quot;@jiang/eslint-config/my-special-config&quot;&#125; 使用来自插件的规则插件 也是一个 npm包，可给ESLint添加新规则，导出可共享配置。要确保该npm包安装在ESLint能访问到的目录下。 plugins属性值可以省略包名的前缀eslint-plugin- extends属性值 格式: plugin: + 包名 + / + 配置名称, 例如 plugin:react/recommended 123456789101112&#123; &quot;plugins&quot;: [ &quot;react&quot; ], &quot;extends&quot;: [ &quot;eslint:recommended&quot;, &quot;plugin:react/recommended&quot; ], &quot;rules&quot;: &#123; &quot;react/no-set-state&quot;: &quot;off&quot; &#125;&#125; 配置名称, 在configs选项设置 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566module.exports = &#123; deprecatedRules, rules: allRules, configs: &#123; recommended: &#123; plugins: [ &#x27;react&#x27;, ], parserOptions: &#123; ecmaFeatures: &#123; jsx: true, &#125;, &#125;, rules: &#123; &#x27;react/display-name&#x27;: 2, &#x27;react/jsx-key&#x27;: 2, &#x27;react/jsx-no-comment-textnodes&#x27;: 2, &#x27;react/jsx-no-duplicate-props&#x27;: 2, &#x27;react/jsx-no-target-blank&#x27;: 2, &#x27;react/jsx-no-undef&#x27;: 2, &#x27;react/jsx-uses-react&#x27;: 2, &#x27;react/jsx-uses-vars&#x27;: 2, &#x27;react/no-children-prop&#x27;: 2, &#x27;react/no-danger-with-children&#x27;: 2, &#x27;react/no-deprecated&#x27;: 2, &#x27;react/no-direct-mutation-state&#x27;: 2, &#x27;react/no-find-dom-node&#x27;: 2, &#x27;react/no-is-mounted&#x27;: 2, &#x27;react/no-render-return-value&#x27;: 2, &#x27;react/no-string-refs&#x27;: 2, &#x27;react/no-unescaped-entities&#x27;: 2, &#x27;react/no-unknown-property&#x27;: 2, &#x27;react/no-unsafe&#x27;: 0, &#x27;react/prop-types&#x27;: 2, &#x27;react/react-in-jsx-scope&#x27;: 2, &#x27;react/require-render-return&#x27;: 2, &#125;, &#125;, all: &#123; plugins: [ &#x27;react&#x27;, ], parserOptions: &#123; ecmaFeatures: &#123; jsx: true, &#125;, &#125;, rules: activeRulesConfig, &#125;, &#x27;jsx-runtime&#x27;: &#123; plugins: [ &#x27;react&#x27;, ], parserOptions: &#123; ecmaFeatures: &#123; jsx: true, &#125;, jsxPragma: null, // for @typescript/eslint-parser &#125;, rules: &#123; &#x27;react/react-in-jsx-scope&#x27;: 0, &#x27;react/jsx-uses-react&#x27;: 0, &#125;, &#125;, &#125;,&#125;; 使用eslint:recommended 启用eslint推荐的规则子集，rules页中复选框选中的规则 使用eslint:all 启用当前eslint版本中所有的核心规则 更精细化配置，overrides属性使用overrides属性，根据配置中文件 glob模式覆盖规则 1234567891011121314&#123; &quot;rules&quot;: &#123; quotes:[&quot;error&quot;, &quot;dobule&quot;] &#125;, &quot;overrides&quot;: [ &#123; &quot;files&quot;: [&quot;foo/*.js&quot;], &quot;excludedFiles&quot;: &quot;*.test.js&quot;, &quot;rules&quot;: &#123; &quot;quotes&quot;: [&quot;error&quot;, &quot;single&quot;] &#125; &#125; ]&#125; 忽略ESlint规则检查1、.eslintignore 文件在项目根目录下创建.eslintignore文件中指定要忽略检查的文件或目录。 每一行一个glob模式，指定要忽略的路径 # 开头的行 被视为注释 路径时相对于当前工作目录的 !是否定模式 1234# Ignore build files except build/test.js!.build.build/*!.build/test.js 2、配置文件 中的ignorePatterns使用ignorePatterns指定要忽略检查的文件 123&#123; &quot;ignorePatterns&quot;: [&quot;*.ignore.js&quot;]&#125; 语言相关的选项指定环境一个环境提供了一组预定义的全局变量。可用的环境：brower、node、commonjs、es6、shared-node-browser、amd、mocha、jest、jquery、mongo、shelljs 使用注释, 在js文件中指定环境 1/* eslint-env node, mocha*/ 在配置文件中，使用env属性来指定环境并设为true 12345678&#123; &quot;env&quot;: &#123; &quot;browser&quot;: true, &quot;commonjs&quot;: true, &quot;es2021&quot;: true, &quot;node&quot;: true, &#125;&#125; 在package.json 中 1234567891011&#123; name:&quot;eslint-demo&quot;, &quot;version&quot;: &quot;1.0.0&quot;, eslintConfig: &#123; &quot;env&quot;: &#123; &quot;browser&quot;: true, &quot;es2021&quot;: true, &quot;node&quot;: true &#125; &#125;&#125; 指定全局变量当访问未定义的变量时，ESLintno-undef规则会发出警告。可在配置文件中定义或使用注释定义全局变量。 使用注释定义全局变量, 默认是可读的，使用writable标识其可被写入 123/* global var1, var2 *//* global var1:writable, var2:writable */ 在配置文件定义全局变量，使用globals属性设置为一个对象, 可用”off”禁用全局变量 1234567&#123; &quot;globals&quot;: &#123; &quot;var1&quot;: &quot;writable&quot;, &quot;var2&quot;: &quot;readonly&quot;, &quot;Promise&quot;: &quot;off&quot; &#125;&#125; 指定解析器ESLint可以指定想要支持的js语言选项，ESlint默认支持 ECMAScript 5 语法。使用parseroptions属性设置一个对象，其属性如下： ecmaVersion, 可设置为3,5(defalut),6，7，8，9，11，或者2015(same as 6)，2016(7)，2017(8)，latest (最新支持的版本) sourceType，类型，script 或 module, allowReserved, 允许使用保留字做标识符 ecmaFeatures, 对象，指定想要使用的附件语言功能。例如 jsx: true, 支持JSX语法 123456789&#123; &quot;parserOptions&quot;: &#123; &quot;ecmaVersion&quot;: &quot;latest&quot;, &quot;sourceType&quot;: &quot;module&quot;, &quot;ecmaFeatures&quot;: &#123; &quot;jsx&quot;: true &#125; &#125;&#125; 援疆计划自我介绍各位领导，下午好，我是刘振江，来自产险科技中心个人客户研发团队，是一名前端工程师。入司2年多，一直在网销非车项目组工作，负责开发维护我们平安保险商城官网，配合业务老师上线各类的营销活动。另外，还参与优化了ITS航母系统内的录单、出单流程，以及开发完善了新产品配置、上下架等功能。总体来讲，做的还可以，需求方满意，自己也小有成就感。 我从小在新疆生活长大，小学、初中在团场上的（农二师26团），高中去了库尔勒，大学考到了武汉，工作来了深圳。对新疆是有感情，也是热爱的。所以当知道公司有”援疆派驻人才”招募计划，我第一时间就报名了，真的希望能借此机会，回到新疆发展，通过努力、扎实的工作，能办出些实事来，去实实在在的为新疆的发展做出贡献。 与此同时，我也想着能通过这份工作，好好的去宣传新疆，让更过的人了解真正的新疆，从而喜欢上新疆。因为我自身感受而言，内地的朋友对新疆了解的不多，往往会把新疆想象成一个神秘、封闭和落后的地方，他们仅仅知道些新疆美食、美景。甚至有些人会有些误解，例如“新疆不安全”，“新疆交通落后，出行不方便”，“新疆干旱没水，到处都是戈壁沙漠”等。 援疆结束后，我希望能够继续留在新疆工作，毕竟新疆潜力巨大，发展一定会越来越好。对我个人而言，则会有很大的个人成长与发展空间。还有一点，父母都在新疆，发小好友，初、高中同学也大都在新疆工作和生活，从家庭、友情方面考虑，留在新疆，应该是好的选择。 问题？ 援疆人才培养方案是怎样的？有培训的具体计划？ 到了新疆，有老师或领导带我们吗？大致工作是什么？需要哪些技能，有没有相应的指导或培训，我们考核指标是怎样？ 希望达成的目标？ 能办出些实事来，能真正让喀什发展的更好，给喀什地区的各族群众带来好处 自己能通过文字、照片、视频等形式记录我的援疆历程，让更多的人知道援疆，去了解新疆，去参与到新疆的建设与发展中。 新疆安全 新疆便民警务站很多 进入餐厅、超市、电影院等公共场所，随身带的大小包都要过安检仪，类似在深圳乘坐地铁过安检一样 安保措施严格繁琐，但为了自治区的长治久安，大家都能体谅和理解 新疆交通 新疆是全国机场数量最多的省区 全疆所有地区地州都通了铁路； 哈密、吐鲁番乌鲁木齐(兰新高铁)。 城际列车，南疆之星（乌鲁木齐-库尔勒），北疆之星(乌鲁木齐-伊宁) 新建公路,最美独库公路/天山公路（独山子-库车），横穿天山，连接南北疆，沿途有那拉提草原（巩乃斯林场），巴音布克草原（九曲十八弯），天山大峡谷，库车大峡谷伊昭公路(伊宁-昭苏)，伊犁 薰衣草， 天马，昭苏马场 塞果高速(赛里木湖-果子沟) 新疆美食囊、拌面、大盘鸡，库尔勒香梨、伊犁的奶茶、阿克苏苹果、库车的小白杏、吐鲁番的葡萄、哈密瓜 新疆美景北疆，高山、草原，湖泊、森林，塞外江南 南疆，沙漠、戈壁，大漠边塞风光，喀什老城、慕士塔格峰、天山大峡谷、罗布泊、塔克拉玛干沙漠 新疆方言 劳道 皮牙子 大肉 勺子- 哈马斯，(全部) 巴郎子、羊缸子(妇女) 麦格来 (过来) 赶巴扎 (国际大巴扎) 喀什新Q， “喀什噶尔”，”玉石集中之地”， 1个县级市、10个县、1个自治县(塔什库尔干塔吉克族) 汉族 28万，维吾尔族 428万 92% 喀什噶尔石榴，莎车巴旦木，伽师瓜，叶城的核桃 帕米尔冰川矿区水","categories":[{"name":"技术总结","slug":"技术总结","permalink":"https://better-jiang.github.io/categories/%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%93/"}],"tags":[{"name":"ESLint","slug":"ESLint","permalink":"https://better-jiang.github.io/tags/ESLint/"}]},{"title":"缺陷控制","slug":"缺陷控制","date":"2022-07-27T07:06:01.000Z","updated":"2023-02-03T12:14:22.424Z","comments":true,"path":"2022/07/27/缺陷控制/","link":"","permalink":"https://better-jiang.github.io/2022/07/27/%E7%BC%BA%E9%99%B7%E6%8E%A7%E5%88%B6/","excerpt":"","text":"流程 代码 自检代码 质量监控 版本控制 代码风格 Snippet， 代码片段 团队 相互监督 意识形态 定期培训、自检 分工明确 协同待办 代码review 项目 制定计划 版本控制 协商沟通 定期校验 纠正措施 备选方案 公司 缺陷管理软件 公司流程 奖惩有度 抽样检查 质量改进 长远计划，动态改进 ESLint","categories":[{"name":"技术总结","slug":"技术总结","permalink":"https://better-jiang.github.io/categories/%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%93/"}],"tags":[{"name":"团队协作","slug":"团队协作","permalink":"https://better-jiang.github.io/tags/%E5%9B%A2%E9%98%9F%E5%8D%8F%E4%BD%9C/"}]},{"title":"英语语法-分词","slug":"英语语法-分词","date":"2022-07-26T02:26:07.000Z","updated":"2023-02-03T12:14:22.424Z","comments":true,"path":"2022/07/26/英语语法-分词/","link":"","permalink":"https://better-jiang.github.io/2022/07/26/%E8%8B%B1%E8%AF%AD%E8%AF%AD%E6%B3%95-%E5%88%86%E8%AF%8D/","excerpt":"","text":"分词是在动词后面加**-ing或-ed,起形容词**的作用 现在分词含有主动、进行之意 123I see the dancing girl. 现在时I saw the dancing girl. 过去时I will see the dancing girl. 将来时 过去分词含有被动之意 1Look at the broke window 动词的三种形态动词有三种形态，现在式、过去式、过去分词，大致分为A-B-C，A-A-A，A-B-A，A-B-C型 A-B-C型 现在式 过去式 过去分词 am/are/is was/were been begin began begun bite bit bitten break broke broken blow blew blown choose chose chosen draw drew drawn drink drank drunk drive drove driven eat ate eaten fall fell fallen fly flew flown forgive forgave forgiven forget forgot forgotten freeze froze frozen give gave given get got gotten go went gone grow grew grown hide hid hidden know knew known lie lay lain mistake mistook mistaken ride rode ridden ring rang rung rise rose risen see saw seen shake shook shaken show showed shown sing sang sung swim swam swum speak spoke spoken steal stole stolen take took taken throw threw thrown wear wore worn write wrote written A-B-B型 现在式 过去式 过去分词 bend bent bent bind bound bound bring brought brought buy bought bought build built built catch caught caught dig dug dug feed fed fed feel felt felt fight fought fought find found found hang hung Hung hear heard heard hold held Held keep kept kept lead ked led lend lent Lent lose lost lost leave left left lay laid laid make made made mean meant meant meet met met pay paid paid sell sold sold shoot shot shot sit sat sat smell smelt smelt shine shone shone sleep slept slept spend spent spent strke struck struck stand stood stood tell told told think thought thought teach taught taught win won won understand understood understood ​ A-A-A型 现在式 过去式 过去分词 let let let cast cast cast cost cost cost cut cut cut hit hit hit hurt hurt hurt put put put read read read set set set shut shut shut spread spread spread A-B-A型 现在式 过去式 过去分词 become became become come came come run ran run","categories":[{"name":"英语拾遗","slug":"英语拾遗","permalink":"https://better-jiang.github.io/categories/%E8%8B%B1%E8%AF%AD%E6%8B%BE%E9%81%97/"}],"tags":[{"name":"语法","slug":"语法","permalink":"https://better-jiang.github.io/tags/%E8%AF%AD%E6%B3%95/"}]},{"title":"英语语法-动词的3种变形","slug":"英语语法-动词的3种变形","date":"2022-07-22T07:20:57.000Z","updated":"2023-02-03T12:14:22.424Z","comments":true,"path":"2022/07/22/英语语法-动词的3种变形/","link":"","permalink":"https://better-jiang.github.io/2022/07/22/%E8%8B%B1%E8%AF%AD%E8%AF%AD%E6%B3%95-%E5%8A%A8%E8%AF%8D%E7%9A%843%E7%A7%8D%E5%8F%98%E5%BD%A2/","excerpt":"","text":"动词原本在句子中应该做谓语，但可以通过改变动词的形态，让它起名词、形容词、分词的作用。 动词不定式， to + V, 起 名词、形容词、副词的作用 动名词，V-ing， 起 名词 的作用 分词， V-ing, V-ed, 起 形容词 的作用 动词不定式**“to + 动词”**， 起名词的作用，在句子中作主、宾、补 I want to drink. “to drink” 表示名词 “喝的东西” I want to drink water. I want to drink coke. I want to eat an apple. 起形容词的作用，修饰名词 I want water to drink. to drink 修饰名词 water， 表示”要喝的水“ 起副词的作用，修饰形容词、副词、动词、句子 I stopped the work to dirnk water. “to drink water” “为了喝水”，用来说明停下工作的目的 动词不定式-名词性用法 主语 To study is my hobby. To play the piano is interesting. 宾语 I like to study. “to study”作宾语 补语 My hobby is to study. My dream is to be a doctor. 动词不定式-形容词性用法形容词修饰名词一般放在名词前（difficult homework），动词不定式起形容词作用时一般放在名词后 (homework to finish) I have no food to eat. 动词不定式和介词连用修饰名词 I have no house to live in. I need a chair to sition. I have no friend to play with. 动词不定式-副词性用法 修饰 形容词， 一般 放在形容词后 This book is difficult. This book is difficult to read. “to read” 修饰 形容词 difficult 修饰 副词 He is to young to go to school. (Hi is so yong that he can’t go to school.)， “to go” 修饰 副词 too 修饰 动词、句子 I wake up early to catch the first train. (表示目的) She goes to the store to buy an apple. I am glad to meet you. (表示理由) He must be mad to do so.(判断的依据) grow , live, awake 这三个动词表示结果 He grew up to be a teacher. (他长大成了老师) She lived to be eighty. (她活到了80岁) I studied hard only to fail. (我努力学习，但还是失败)， 表示结果 动名词在动词后面加-ing，起 名词作用的词就是动名词。动名词只有名词的作用， 在句子中做 主宾补 做主语 Learning English is difficult. = To learn English is difficult. it 作 形式主语，动名词或动词不定式 作 真正主语 It is difficult learning English. = It is difficult to learn English. 做宾语 I like reading a book. = I like to read a book. 做补语 My hobby is collecting stamps. = My hobby is to collect stamps. 介词的宾语 介词是具体表示时间、地点、空间的词，但单独一个介词并不完整。 介词一般用于名词前，其后不接动词、形容词、副词。所有介词后用动词，一定要把动词变为动名词 I am interested in going there. 12345be interested in doing somethingbe found of be sure of be proud ofbe ashamed of 逻辑主语动词不定式 充当逻辑主语I want to succeed. **支配动词不定式（to succeed）的主体 是 逻辑主语(I)**。 I 与句子的主语一致，这是为了避免重复就不再写出逻辑主语。 I want her to succeed. 这个句子的句型为”主语+谓语+宾语+宾语补足语”。 支配动词不定式(to succeed) 的 主体 是逻辑主语，逻辑主语 是 she， 与句子的主语 I 不一样，所有两个都要写出来。且逻辑主语，要用人称代词的宾格形式(her) 在以形式主语it开头的句子中，要用”for + 宾格”写出支配动词不定式的逻辑主语。 如果形式主语it后表示人的特质或性格的形容词，要用”of + 宾格” 12345678It is easy for me to teach English.It is impossible for her to help you.It was easy for me to carry the box.It kind/polite/impolite/wise/smart/foolish of + 宾格 + 动词不定式It is kind of you to help me.It is wise of him to tell the truth. 动名词 充当逻辑主语动名词的用法和动词不定式的名词性用法几乎一样，但在逻辑主语上有差别。动名词的逻辑主语直接使用所有格或宾格形式 12345It is no use your / you predicting the weather. his / him her / her Jane&#x27;s / Jane my mom&#x27;s / my mom 动名词 的逻辑主语 是 事物时，不能用所有格形式，只能用宾格形式 She is always talking about my car having a good seat. 句子的主语(She) 与 支配动名词(having a good seat) 的主体 (my car) 不一致，所有要写出逻辑主语，而逻辑主语是事物，所以只能用宾格形式(my car) 第三类句型的宾语形态在第三类句型中**”主语 + 谓语 + 宾语”，如果动词想作宾语就要变成名词，动词变名词2中方法，动名词** 和 动词不定式的名词性用法 I want to eat. 只能用动词不定式作宾语的动词want、wish、hope、expect(期望)、promise、decide, 含有预期、未来的意思，表示将来会发生的事情 I want to eat. I hope to master English. 只能用动名词作作宾语的动词mind、enjoy、give up、avoid、finish、escape、stop， 有”平时做…”，“过去做….”的意思 可以用动名词、动词不定式作宾语的动词love、like、hate、begin、start、continue，一般表示现在的状态 有些动词不定式和动名词都可作宾语，但意思不同。 动词不定式含有未来的意思，动名词还有过去的意思 I remember sending a postcard. 我记得寄过明信片 I remember to send a postcard. 我记得要寄明信片","categories":[{"name":"英语拾遗","slug":"英语拾遗","permalink":"https://better-jiang.github.io/categories/%E8%8B%B1%E8%AF%AD%E6%8B%BE%E9%81%97/"}],"tags":[{"name":"语法","slug":"语法","permalink":"https://better-jiang.github.io/tags/%E8%AF%AD%E6%B3%95/"}]},{"title":"英语语法-句型","slug":"英语语法-句型","date":"2022-07-15T00:28:39.000Z","updated":"2023-02-03T12:14:22.424Z","comments":true,"path":"2022/07/15/英语语法-句型/","link":"","permalink":"https://better-jiang.github.io/2022/07/15/%E8%8B%B1%E8%AF%AD%E8%AF%AD%E6%B3%95-%E5%8F%A5%E5%9E%8B/","excerpt":"","text":"句子成分 主语： 动作的主人 谓语： 表示某人怎样？做某事？ 宾语： 表示某事，动作、行为的对象 补语： 补充说明主语（”表语”）、宾语 (“宾语补足语”) 5类句型 主语 + 谓语 12345 // + 修饰语I study. I study (hard).She teaches. She teaches (well).My mom cooks. My mom cooks (in the kitchen).We talk. We talk (loudly). 由主语和谓语构成，不需要宾语或补语（谓语不需要宾语或补语），即该句型的动词称为不及物动词 不及物动词：可以单独使用，不需要宾语或补语的动词，以下几类动词是不及物动词 有往来之意的动词，如 来、去、出发、到达等， go、come、begin、start、leave、arrive、move 存在动词，exist、be 发生动词，happen、occur 修饰语：指起修饰作用的词句，包括形容词、副词、介词短语、状语从句 ​ Time flies (like an arrow). Our school stands (on the hill). 主语 + 谓语 + 表语 123I am (a doctor).She looks (happy).I fell (cold). 动词后需要补充说明主语的状态、情况、身份等内容的词句，动词后面加上补语，句子才完整。 表语可由名词、代词、形容词充当，副词、动词不可以做表语 12She is beautifully. (X) You look happily. (X)She is beautiful. You look happy. 可以用在”主语+谓语+表语”句型中的动词有： be动词，become，表示”是……”，”成为……” 1234I am a study. She i pretty. He became a doctor. Tom became crazy. be动词表示”存在、有”时，不需要表语 12God is everywhere. // &quot;上帝无处不在&quot; , 不需要表语就是完整的句子，属于&quot;主语+谓语&quot;The girl is in the kitchen. // &quot;主语+谓语+介词短语&quot; 感官动词 表示”感觉怎么样”，需要补充说明感受，所有必须接形容词表示表语 视觉 look You look beautiful 听觉 sound It sounds great. 嗅觉 smell This smells good. 味觉 taste It tastes delicious. 触觉 feel It feels soft. trun 、seem， 表示 “好像”、”变得”，后面必须接相应的内容进行补充说明 12He seems ill.The leaves turned yellow and red. 主语 + 谓语 + 宾语 相当于 谁(主语) + 做(谓语) + 什么(宾语)， 宾语的位置通常为名词、代词 123I love you.I read this book.I need water. 决定句子类型的谓语动词，在此类句型中的动词都需要接宾语的动词，其自身不能表达完整的意思，后面必须接宾语，被称为及物动词 典型的及物动词： ​ I ike you. He has a pet. I read a poem. I want some water. 动词、形容词及副词不能做宾语： 123You want happy.(x) You want happiness.He makes beautiful.(x) He makes beauty.I need fast.(x) I need fastness. 由于汉语和英语的语言差异，有些单词后面要直接接宾语，不能加介词 marry 和…..结婚 It&#39;s beyond me why she wants to marry me. mention 谈到 Don&#39;t mention it Sorry, I won&#39;t mention it again. enter 进入 I enter the room. resemble 与……想像 I resemble my father. reach 到达 I reached the station. I arrived at the station. await 等待 I awaited her I waited for her. discuss 讨论 It&#39;s hardly the time to discuss it now. attend 参加，出席 I attend the meeting. 主语 + 谓语 + 间接宾语(人) + 直接宾语(事、物) (某人给某人某物) 该句型中的动词表示”给(为)……做……”,称为做授予动词，典型的授予动词： give， I gave her flowers. show , I will show you a picture. bring, She brings me a computer. send, He sends her a flower. teach, She teaches me English. 在间接宾语使用人称代词时，要用宾格形式 主格 宾格 I me we us you you he him she her they them it It “主语+谓语+宾语”和”主+谓+间宾+直宾”间的转换，将表示人的间接宾语移至句尾，并在其前面加上to/of/for,变成”介词+名词”形式的修饰语。需要用到介词for的动词有make、buy、build、cook、choose、get、order、leave、find，动词ask的间接宾语前用of 主+谓+间宾+直宾 主+谓+宾 You teach us English. You teach English to us. I gave him money. I gave money to him. You make me a cake. You make a cake for me. She bought me a bike. She bought a bike for me. I found her the ring. I found the ring for her. May I ask you a favor? May I ask a favor of you? 主语 + 谓语 + 宾语 + 宾语补足语 “主语+谓语+表语”，中的补语是补充说明主语的，称之为表语. He is a spy. “主语 + 谓语 + 宾语 + 宾语补足语”中补语是补充说明宾语的。 We call him a spy. 典型动词,其宾语补足语要用名词、形容词充当 make， 把……制作成….. keep, 让…..保持…… call, 把…..叫做…… think, 认为…… find, 找….. believe, 相信….. elect， 把……选为….. 当谓语动词是感官动词或使役动词时，可以用动词做宾语补足语， 当宾语是无法独立完成动作时，宾语补足语要使用过去分词(含有被动意思) 感官动词，see、watch、look at、smell、taste、hear、listen to、feel、perceive， 宾语补足语用动词原形，或 现在分词（V-ing） V-ing 表示 感受到现在正在进行的动作，动词原形表示感受到了动作的全部过程。 12345I hear him sing. I hear him singing.I saw her clean the room. I saw her celaning the room.You see me dance.(看到跳舞的全过程) You see me dancing. (看到跳舞的某个瞬间) 使役动词，表示”让做某事”，”指使做某事”， 典型的使役动词，make、have、let make、let 的宾语补足语只能用动词原形，不能用V-ing have 同感官动词一样，当宾语或宾语补足语是主动、进行时，宾语补足语可以用V-ing 123456My mom makes me study.My dad has me clean the car.You let me go.My teacher has him running.I had a kite flying high in the sky. 当宾语是无法独立完成动作的事物时，宾语补足语要用含有被动意思的过去分词 123456I heard the music played. // 音乐被演奏I heard my name called. // 名字被叫I saw a girl carried into the hospital. I had my hair permed. // 头发被烫I made my car repaired by enginner. // 车被修理 口诀 名词就作”主宾补”， 补语就是”名代形” 1、主语 + 感官动词 / 使役动词 + 宾语(人，表示主动) + 动词原形 / 现在分词V-ing 12I saw her go/going out of the room.I made my younger brother study for the exam. 2、主语 + 感官动词 / 使役动词 + 宾语(物，表示被动) + 过去分词 123I heard my name called.I made this box broken.I had the box carried by the boy.","categories":[{"name":"英语拾遗","slug":"英语拾遗","permalink":"https://better-jiang.github.io/categories/%E8%8B%B1%E8%AF%AD%E6%8B%BE%E9%81%97/"}],"tags":[{"name":"语法","slug":"语法","permalink":"https://better-jiang.github.io/tags/%E8%AF%AD%E6%B3%95/"}]},{"title":"小白笔记-shell","slug":"小白笔记-shell","date":"2022-07-14T09:02:50.000Z","updated":"2023-02-03T12:14:22.424Z","comments":true,"path":"2022/07/14/小白笔记-shell/","link":"","permalink":"https://better-jiang.github.io/2022/07/14/%E5%B0%8F%E7%99%BD%E7%AC%94%E8%AE%B0-shell/","excerpt":"","text":"1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#!/bin/bashecho &quot;Hello jiang !&quot;for file in `ls /etc`;do echo $filedone # 使用变量name=&quot;jiang&quot;echo $&#123;name&#125;echo $name# 变量名 使用 花括号，确定变量的边界for skill in Ada Coffe Action Java;do echo &quot;I am good at $&#123;skill&#125;Script&quot;done# readonly 定义只读变量myUrl=&quot;https://betterjiang.com&quot;echo $&#123;myUrl&#125;readonly myUrl# myUrl=&quot;2&quot;greeting_2=&#x27;hello, &#x27;$&#123;name&#125;&#x27; !&#x27;echo $greeting_2# 字符串长度echo $name $&#123;#name&#125;# 提取字符串echo $&#123;name:1:4&#125;# 定义数组array=(jiang1 2 3 4jiang 5 6six)# 数组长度length=$&#123;#array[@]&#125;echo $&#123;array[2-1]&#125;echo $length# 数组元素echo $&#123;array[*]&#125;:&lt;&lt;!多行注释。。。。多汗，多雨!:&lt;&lt;EOFline1里呢EOF","categories":[{"name":"烂笔头","slug":"烂笔头","permalink":"https://better-jiang.github.io/categories/%E7%83%82%E7%AC%94%E5%A4%B4/"}],"tags":[{"name":"shell","slug":"shell","permalink":"https://better-jiang.github.io/tags/shell/"}]},{"title":"小白笔记-pnpm","slug":"小白笔记-pnpm","date":"2022-06-22T06:15:55.000Z","updated":"2023-02-03T12:14:22.424Z","comments":true,"path":"2022/06/22/小白笔记-pnpm/","link":"","permalink":"https://better-jiang.github.io/2022/06/22/%E5%B0%8F%E7%99%BD%E7%AC%94%E8%AE%B0-pnpm/","excerpt":"","text":"performant npm，高性能的 npm，由 npm、yarn 衍生而来，解决了 npm/yarn 内部潜在的 bug，极大的优化了性能。 特点 速度快，安装高效 节省磁盘空间 当使用 npm 或 yarn 时，如果有 100 个项目使用到某个依赖(dependency)，就会有 100 份改依赖的副本保存在硬盘上。使用 pnpm 时，依赖会被存储在内容可寻址的存储中(the denpendency wil be sotred in a content-addressable store),所有 用到某个依赖的不同版本，只会将不同版本有差异的文件添加到仓库 所有的文件都会存储在硬盘的某一个位置。当软件包被安装时，包里的文件会硬链接到该位置，不会再占用额外的磁盘空间。可允许跨项目的共享同一版本的依赖。 优化了依赖的 node_modules 结构，创建非扁平化的 node_modules 文件夹 使用 npm 或 yarn 安装依赖项时，所有的包都被提升到模块目录的根目录，因此，项目可以访问到未被添加进当前项目的依赖 默认情况下，pnpm 使用软链的方式将项目的直接依赖添加进模块文件夹的根目录 内置了对 Monorepo 的支持，无需在引入 lerna npm、yarn 面临的问题Npm 安装包的过程 先检查 .npmrc文件，包含以下 npm 配置信息，如 registry,全局缓存目录等 读取 package.json 文件中的依赖信息，根据semver语义化版本信息生成完整的版本依赖树 先查询本地缓存目录，如果有缓存就直接使用，如果不存在，再去 npm 仓库下载到的缓存目录，此过程，会校验包的哈希，以保证安全性 上述过程中依赖树可能存在大量重复的模块，因为它按依赖树的结构进行安装，比如 A，B 模块都依赖了 C 模块，那么 C 模块会在 A、B 模块的 node_modules 目录内重复安装，造成大量的重复和冗余。 npm3 进行了优化，加入了dedupe模块扁平化，尽可能的将所有依赖都发到最顶层node_modules 目录下，如果有重复的模块，且版本相互兼容，就会只保留一个，丢弃其它的。如果版本不兼容，那么只有一个被提升到顶层，其它的会放在其父依赖的 node_modules 目录下，而哪一个被提升到顶层可能不固定，所有在 npm5+版本中新增了package-lock.json用于锁定依赖结构，确保每一次安装出来的目录结构和依赖版本相同。 phantom dependencies (幽灵依赖)由于扁平化的处理方式， 用户可以引用 package.json 中没有声明的依赖。 比如项目 1 使用 依赖 A，其中 A 有一个 A1 包，由于扁平化 A1 包会别提升到项目 node_modules 下，此时在项目 1 中可直接使用 A1 包，将来 A 升级或不在使用 A1 包，那么项目 1 就会出现异常或报错 npm dopplelgangers (npm 包分身)npm 扁平化的处理机制，可能导致心魔中应用多个版本的包，从而导致 需要安装多个版本包 打包出来的文件可能包含多个包 如果该包需要用到单例，会出现异常 pnpm 原理pnpm 安装依赖后 node_modules 目录大概如下： 其中 node_modules 包含 .bin,.pnpm目录以及其它的 npm 包，这些 npm 包与 package.json 中声明的保持一致，因此只有 package.json 中声明过的依赖才能在项目中使用，从而避免了幽灵依赖的问题。 不同于 npm,这些 npm 包都是 symbolic link 符号链接，指向了.pnpm 目录下的包 .pnpm 下的包名规则是 123&lt;organization-name&gt; + &lt;package-name&gt;@&lt;version&gt;/node_modules/&lt;name&gt;组织名+包名@版本号/node_modules/名称(项目名)typescript@4.7.4/node_modules/typescript 因为.pnpm 里面的包路径中加入了版本号信息，因此可以在同一目录下相对扁平化的存储所有的包， 由于每个包又有自己的依赖，为了迎合 node.js 的包查找规则，因此上面的包命名规则中有添加了一层 node_modules 目录，本包的依赖也会在这个目录 内创建 Symbolic link 符号链接，链接到.pnmp 顶层上的包，通过此法，使得每一个包都能正常的使用自己的依赖，但不会污染到顶层的 node_modules,从而避免幽灵依赖的问题 注： node_modules 目录下还存在一部分没有在 package.json 中声明的依赖，比如@jest/type,@vitejs，这是因为一部分包需要在顶层才能使用，比如 eslint、typescript 声明，prettier 插件等，pnpm 会默认将包名含 types，eslint、prettier 等关键词的包提升到顶层。可通过.npmrc中设置public-hoist-pattern[]=来关闭这些提升 Hard Link 和 Store在 linux 文件系统中，保存在磁盘分区中文件都会分配一个编号，称为索引编号(inode index)，文件名和 inode 通常是一一对应的，且允许多个文件名指向同一个 inode, 删除任何一个文件名并不会对 inode 或其它文件有影响。只有当最后一个硬链接删除后才回收 inode 编号并标记对应的 block 为可用，等待其它数据存储后抹去其内容。如此，同一个文件可以有多个文件路径和文件名，但在磁盘中仅仅只有一份内容，避免了重复占用。 项目的 node_modules 目录下的所有文件都是通过硬链接的方式链接到全局 pnpm store 内的文件，以.pnpm 目录下的 vue 为例， 查看 README.md 文件的 inode 编号：64817529 进入 pnpm 全局 stroe 路径，查找 inode 编号 12Users/liuzhenjiang948/.pnpm-store // 全局目录find . -inum 64817529 // 查找对应 inode 所有 npm 包里面的所有文件都会在全局进行存储,存储是根据文件的哈希信息进行散列，这样可以扁平化的存储，而不用按原始的 npm 包目录结构进行存储，节省大量磁盘空间。 pnpm install 安装包的大致过程 判断是否有 pnpm-lock.yaml文件， 如果没有，则根据package.json中声明的版本计算依赖树以及各版本 npm 包的 integrity 值 如果有 且版本跟 package.json 中声明的匹配，就根据pnpm-lock.yaml中各个依赖包的 integrity 信息，并计算对应的 -index.json 文件的完整哈希和路径 如果 stroe 里面有对应的包的-index.json 文件，即有该包的缓存 如果没有的话需联网下载对应的 tar 包，并生成对应的-index.json 文件，并且将包内的文件计算 integrityz 值和哈希 对整个依赖树进行完以上操作后再项目内的 node_modules 目录创建个依赖的符号链接和文件的硬链接完成安装 CLI 命令 pnpm add , -D 安装到 devDependencies, -O 安装到 optionalDependencies pnpm install （i）, 安装项目所有依赖 123Packages are copied from the content-addressable store to the virtual store. Content-addressable store is at: /Users/liuzhenjiang948/Library/pnpm/store/v3 Virtual store is at: node_modules/.pnpm 配置项 默认值/类型 说明 –offline false 为 true，仅使用在store中已有的包，本地找不到，安装失败 –ignore-scripts false 不执行任何项目中package.json和它依赖项中定义的任何脚本 –ockfile-only fasle 只更新pnpm-lock.yaml和package.json，不写入node_modules目录 –fix-lockfile 自动修复损坏的 lock 文件入口 —reporter= default, silent, append-only, ndjson silent: 除致命 errors，不输出记录信息ndjson: 最详细记录信息 pnpm update (up), 更新软件包的最新版本 命令，配置项 说明 pnpm up 按 package.json指定的范围更新所有的依赖项 pnpm up –latest 更新所有依赖项，忽略package.json指定的范围 pnpm up –recursive 递归更新子目录中的依赖包 pnpm up –global 更新全局安装的依赖包 pnpm remove (rm,un,uninstall), 删除指定的包 pnpm link (ln)， 使当前本地包 可在系统范围内 或 其他位置 访问 在项目开发时，需要将一些公用的代码抽离发布成 npm 包，作为项目的依赖去安装使用。但在开发调试中需要频繁的打包发布，再安装依赖，很不方便。为解决此问题，可以使用 link 命令将模块链接到项目中。 假设 项目名 project-jiang，和一个公用组件模块 common，现在需要在项目中使用 common,且 common 是作为项目的 npm 包依赖。 在 common 目录下使用 pnpm link ,将 common 模块创建成本地依赖包 在 project-jiang 项目中，使用 pnpm link common 和本地 common 模块建立链接。此时该项目中的 node_modules 里就会添加一个 common 模块的软连接 pnpm unlink， 取消链接一个系统访问的 package pnpm import, 从另一个软件包管理器的 lock 文件生产 pnpm-lock.yaml， 支持的源文件 package-lock.json,yarn.lock,npm-shrinkwrap.json 查看依赖 pnpm audit, 检查已安装包的已知安全问题，如果发现问题，尝试使用pnpm update，pnpm audit --fix pnpm list, 以树形结构输出所有的已安装package的版本及其依赖 pnpm outdated， 检查过期的 packages 运行脚本 pnpm run ， 运行一个在 package 文件定义的脚本 pnpm test, 运行在 package 的 scripts 对象中test 属性指定的任意的命令 pnpm exec, 在项目访问内执行 shell pnpm dlx, 从源中获取包而不将其安装为依赖，热加载，并运行它公开的任何默认命令的二级制文件 例如 pnpm dlx create-react-app my-app, 使用 create-react-app来初始化一个 react 应用 pnpm create， 从create-*或@foo/create-*启动套件创建项目， 例如pnpm create react-app my-app 管理 Node 环境pnpm env 安装并使用指定版本 node.js pnpm env use --global lts, pnpm env use --global 16, pnpm env use --global latest","categories":[{"name":"烂笔头","slug":"烂笔头","permalink":"https://better-jiang.github.io/categories/%E7%83%82%E7%AC%94%E5%A4%B4/"}],"tags":[{"name":"pnpm","slug":"pnpm","permalink":"https://better-jiang.github.io/tags/pnpm/"}]},{"title":"小白笔记-redis","slug":"小白笔记-redis","date":"2022-06-21T14:01:49.000Z","updated":"2023-02-03T12:14:22.424Z","comments":true,"path":"2022/06/21/小白笔记-redis/","link":"","permalink":"https://better-jiang.github.io/2022/06/21/%E5%B0%8F%E7%99%BD%E7%AC%94%E8%AE%B0-redis/","excerpt":"","text":"Redis特点 高性能，可持久化 key-value 结构，支持多种数据类型 支持事务，数据具有原子性 Redis应用场景 缓存 （读写性能优异） 计数、消息系统（高并发，发布/订阅阻塞队列功能） 分布式会话session，分布式锁 Redis CLi Redis 命令参数 http://doc.redisfans.com/index.html 设置/取值 databases 16 数据库隔离 keys *, 查询 所有key键 exists test, 检查 key 键 是否存在 del test, 删除 key 键","categories":[{"name":"烂笔头","slug":"烂笔头","permalink":"https://better-jiang.github.io/categories/%E7%83%82%E7%AC%94%E5%A4%B4/"}],"tags":[{"name":"redis","slug":"redis","permalink":"https://better-jiang.github.io/tags/redis/"}]},{"title":"大前端-NoSQL数据库的设计与集成","slug":"大前端-NoSQL数据库的设计与集成","date":"2022-06-16T06:00:33.000Z","updated":"2023-02-03T12:14:22.424Z","comments":true,"path":"2022/06/16/大前端-NoSQL数据库的设计与集成/","link":"","permalink":"https://better-jiang.github.io/2022/06/16/%E5%A4%A7%E5%89%8D%E7%AB%AF-NoSQL%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E8%AE%BE%E8%AE%A1%E4%B8%8E%E9%9B%86%E6%88%90/","excerpt":"","text":"NoSQL 易扩展，高性能，高可用 较容易 映射复杂数据（key-value) 无失误特性要求（ACID，原子、一致、隔离、持久） NoSQL 常用场景 内嵌内嵌即存在关联关系的文档，放在同一个文档中，以数组的形式存放。设计思想： 减少了关联查询 适合单类需要描述的属性 不经常变换的属性 父子引用 存在一对多，放在同一文档中，以数组的形式存放 存在一对非常多的情况下，由于文档存放限制，进行反向引用，存放父级 id 设计思想： 引用数据内容是否非常多？ 引用数据量是否非常庞大，而且还在增加？ 数据是否需要单独访问？ 反范式 是否有提升性能的区间？ 数据量的变化是否非常庞大，庞大到更新会异常低效？ 先考虑读写比，才考虑反范式 MongoDB 设计原则 优先考虑内嵌，如果需要单独访问，则不适合 数组不应该无限制的增长 考虑读写比，考虑应用场景，考虑反范式 小江， 温和内敛，平易近人 毕业于中国地质大学（CUG），玩飞盘近 10 年 曾参加过武汉公开赛、深圳公开赛、北京公开赛，广州岭南赛，大连沙滩赛等高水平飞盘赛事 擅长打 cutter，喜欢接盘的感觉 因为玩飞盘，我不再”社恐” RedisKEY TYPE key, 返回key所存储的值的类型 none(key 不存在) string list set zset hash KEYS pattern, 查找所以符合模式 pattern 的 key EXPIRE key sconds, 设置key 的过期时间，单位秒 EXISTS key [key…], 检查给定key是否存在 String Setnx(SET if Not eXists) key value, 在指定的key不存在时，为key设置值 Mset key value [key value…], 同时设置一个或多个key-value对 Get key， 获取指定key的值 Append key value, 将 value 追加到key原来值的末尾 Hash Hset key field value [field value…], 为哈希表中的字段赋值 Hget key field, 返回哈希表中指定字段的值 Hgetall key, 返回哈希表中所有的字段和值 List Lpush element [element…], 将一个或多个值插入到列表的头部 Lpop key, 移出并获取列表的第一个元素 Lrange key start stop, 获取列表指定范围内的元素 Set Sadd key member [memer…], 将一个或多个成员加入到集合，已经存在于集合的成员将被忽略 Smembers key , 返回集合中所有成员 Srem key member [member …]， 移除集合中的一个或多个成员 Transaction Multi, 标记一个事务块的开始 Exec， 执行所有事务块内的命令","categories":[{"name":"烂笔头","slug":"烂笔头","permalink":"https://better-jiang.github.io/categories/%E7%83%82%E7%AC%94%E5%A4%B4/"}],"tags":[]},{"title":"前端八股文","slug":"前端八股文","date":"2022-06-15T01:53:58.000Z","updated":"2023-02-03T12:14:22.423Z","comments":true,"path":"2022/06/15/前端八股文/","link":"","permalink":"https://better-jiang.github.io/2022/06/15/%E5%89%8D%E7%AB%AF%E5%85%AB%E8%82%A1%E6%96%87/","excerpt":"","text":"https 协议的工作原理传送门 # 解读 HTTP1/HTTP2/HTTP3 客户端使用 https 访问服务器，则要求 web 服务器建立 ssl 链接 web 服务器接收客户端的请求后，会将网站的证书（包含公钥），传输给客户端 客户端和 web 服务器端开始协商 SSL 链接的安全（加密）等级 客户端浏览器通过双方协商一致的安全等级，建立会话秘钥，然后通过网站的公钥来加密会话秘钥，传送给网站 web 服务器 通过自己的私钥解密出 会话秘钥 web 服务器 通过 会话秘钥 加密 与客户端之间通信 TCP 三次握手 第一次，建立连接时，客户端**发送 SYN 包(syn=j)**到服务器，并进入SYN_SENT状态，等待服务器确认；SYN(Synchronize Sequence Numbers,同步序列号) 第二次，服务器收到 SYN 包并确认客户的 SYN (ack=j+1),同时也发送一个自己的 SYN 包(syn=k), 即 SYN+ACK 包，此时服务器进入SYN_RECV状态 第三次，**客户端收到服务器的 SYN+ACK 包，向服务器返送确认包 ACK(ack=k+1)**，此包发送完毕后，客户端和服务器进入ESTABLISTHED状态，完成三次握手 TCP 四次挥手 客户端进程发出连接释放报文，并停止发送数据。释放数据报文首部，FIN=1，其 seq=u(等于前面已经出过来的数据的最后一个字节序号+1)，此时，客户端进入FIN_WAIT_1(终止等待1)状态。 服务端收到连接释放报文，发出确认报文，ACK=1，ack=u+1,并带上自己的序列号 seq=v，此时，服务器进入CLOSE_WAIT状态。TCP 服务器通知高层的应用进程，客户端向服务器的方向已释放，这时处于半关闭状态，即 客户端已经没有数据要发送，但服务器若发送数据，客户端仍然要接受。 客户端收到服务器的确认报文后，此时，客户端进入FIN_WAIT_2状态，等待服务器发送连接释放报文，在这之前还需要接受服务器发送的最后的数据 服务器将最后的数据发送完毕后，就向客户端发送连接释放报文，FIN=1，ack=u+1,由于在半关闭状态，服务器很可能又发送了一些数据，假定此时的 seq=w, 此时，服务器进入LAST_ACK状态，等待客户的确认。 客户端收到服务器的连接释放报文后，必须发出确认，ACK=1，ack=w+1,自己的 seq=u+1,此时，客户端就进入TIME_WAIT状态。此时 TCP 连接还没有释放，必须等待一段时间后，当客户端撤销相应 TCB 后，进入CLOSED状态。 服务器只要收到客户端发出的确认，立即进入CLOSED状态，撤销 TCB 后，就结束了 TCP 连接。 TCP/IP 如何保证数据包传输的有序可靠？对字节流分段并进行编号，然后通过 ACK 确认回复 和超时重发 机制来保证 为了保证数据包的可靠传递，发送方把已经发送的数据包保留在缓冲区 并为每个已发送的数据包启动一个超时定时器 如果在定时器超时之前收到对方的应答信息，则取消定时器，释放数据包占用的缓冲区 否则，重传该数据包，直到收到应答 或 重传次数超过最大次数为止 接收方收到数据包后，进行 CRC 校验，正常则将数据交给上层协议，然后给发送方 发送一个累计应答包，表明该数据已收到。如果接收方正好也有数据要发给发送方，应答包也可在数据包中捎带过去。 TCP 和 UDP 的区别 TCP 是面向连接的，UDP 是无连接的 TCP 仅支持单播传输，UDP 提供了单播、广播、多播的功能 TCP 的三次握手保证了连接的可靠性，UDP 是无连接的，不可靠的，对接收的数据不发送确认信号，发送端也不知道数据是否正确接收 UDP 的头部开销比 TCP 的更小，数据传输速率更高，实时性更好 cookie、sessionStorage、localStorage cookie 数据大小不能超过 4K，sessionStorage、localStorage 的存储大，5M+ cookie 设置的过期时间之前一直有效； localStorage 永久存储，浏览器关闭后数据不丢失，除非主动删除；sessionStorage 数据在当前浏览器关闭窗口后自动删除 cookie 数据会自动传递到服务器；sessionStorage、localStorage 数据保存在本地 粘包问题分析、对策TCP 是面向流的协议，粘包问题主要是因为接收方不知道消息之间的界限，不知道一次提取多少字节的数据造成的。而 UDP 是面向消息的协议，每个 UDP 都是一条消息，应用程序必须以消息为单位提取数据，不能一次提取任意字节的数据。TCP 为了提高传输效率，发送方往往要收集到足够多的数据后才发送一个 TCP 段。TCP 会使用优化方法，将多次间隔较小且数据量小的数据，合并成一个大的数据块发送出去，这样接收方就难于分辨。 发送方需要等待缓冲区满才发送，造成粘包 接收方不及时接收缓冲区的包，造成多个包接收粘包有两中情况：粘在一起的包都是完整的数据包，粘在一起的包有不完整的包比较周全的对策：接收方创建一预处理线程，对接收到的数据包进行预处理，将粘连的包分开 从输入 URL 到页面加载的全过程传送门 # DNS 域名解析过程, # 浏览器的工作原理 浏览器输入 url 查找缓存：浏览器先查看浏览器缓存-&gt;系统缓存-&gt;路由缓存中是否有该地址页面，如果有则显示该页面内容，没有，进行域名解析，也是先查看缓存 浏览器缓存：浏览器会记录 DNS 一段时间 操作系统缓存：如果浏览器缓存中不包含这个记录，则会获取操作系统的记录（其保存最近的 DNS 查询缓存） 路由器缓存：如果上述两步均不能成功获取 DNS 记录，则继续搜索路由器缓存 ISP 缓存： 若上述都失败，继续向 ISP 搜索 DNS 域名解析：浏览器向 DNS 服务器发送请求，解析该 URL 中域名对应的 IP 地址。使用 UDP 协议 建立 TCP 连接： 解析出 IP 地址，和服务器建立 TCP 连接（3 次握手） 发起 HTTP 请求： 浏览器发送 http 请求 服务器响应： 服务器对浏览器请求做出响应，并把对应 html 文件发送给浏览器 关闭 TCP 连接：4 次挥手 浏览器渲染：浏览器解析 html 内容并渲染 构建 DOM 树: 词法分析然后解析成 dom 树 构建 CSS 规则树 构建 render 树： web 浏览器将 DOM 和 CSSOM 结合，并构建出渲染树 布局（Layout）：计算每个节点在屏幕中的位置 绘制（Painting)：变量 render 树，并使用 UI 后端层绘制每个节点 JS 引擎解析：调用 js 引擎执行 js 代码（js 解释阶段、预处理阶段、执行阶段生成执行上下文，VO，作用域链，回收机制） 创建 window 对象： window 对象（全局执行环境），当页面产生时就被创建，所有的全局变量和函数都属于 window 的属性和方法，而 DOM 树 会映射到 window 的 document 对象上。关闭网页时，全局执行对环境被销毁 加载文件： js 引擎分析语法、词法是否合法，合法进入预编译 预编译：在预编译过程中，浏览器会寻找全局变量声明，把它作为 window 的属性加入到 window 对象，并给变量赋值为“undefined”；寻找全局函数声明，把它作为 window 的方法加入到 window 对象，并将函数体赋值给它。 解释执行： 执行到变量就赋值，如果变量没有被定义（即没有别预编译就直接赋值），在 es5 非严格模式下此变量会成为 window 的一个属性。函数执行，就将函数的环境推入一个环境的栈中，执行完成后再弹出，控制权交互给之前的环境。 浏览器重排、重绘重排、重绘区别？ 重排/回流(Reflow)， 当 DOM 的变化影响到了元素的的几何信息，浏览器需要重新计算元素的集合属性，在将其摆放在页面正确的位置，这一过程即使重排。重新生成布局，重新排列元素。 重绘(Repaint), 元素的外观属性发生变化，但没有改变布局，即重新将元素外观绘制出来的过程。 如何触发重排、重绘？任何改变用来构建渲染树的信息都会导致一次重排或重绘 添加、删除、更新 DOM 节点 display:none，触发重排和重绘 display:hidden, 只触发重绘，因为无几何变化 移动或给 DOM 节点添加动画 添加一个样式表、调整样式属性 用户行为，调整窗口大小、改变字号、滚动 如何避免重排、重绘？ 集中改变样式，而非一条条地修改 DOM 样式 万万不可把 DOM 节点的属性值放置于循环中当作变量 为动画的元素 设置position 为 fixed或absolute, 这样修改其 CSS 不会重复 reflow 尽量只修改 position为fixed或absolute的元素，这对其它元素影响不大 尽量不使用 table 布局，因为一个很小的变动可能造成整个 table 的 reflow 动画开始 GPU 加速，translate 使用 3D 提示为合成层 合成层的位图，会交由 GPU 合成，比 CPU 处理的要快 当需要 repaint 时，只需要 repaint 本身，不会影响到其他层 对于 transform 和 opacity 效果，不会触发 layout 和 paint 使用 CSS 的 will-change属性 浏览器缓存机制缓存过程分析浏览器和服务器通信的方式 为应答模式，即浏览器发送 http 请求 - 服务器响响应请求。 浏览器第一次向服务器发送请求并得到响应结果，会根据响应报文中 http 头中的缓存标识，决定是否缓存响应结果，是否将响应结果和缓存标识存入浏览器缓存中。 浏览器每次请求，都会 先在浏览器缓存中查找该请求的结果和缓存标识 浏览器每次拿到返回的请求结果都会 将该结果和缓存标识存入浏览器缓存中 强制缓存向浏览器缓存查询请求结果，并根据该结果的缓存规则来决定是否使用，3 中情况 不存在该缓存结果和缓存标识，强制缓存失效，则直接向服务器发起请求 存在该缓存结果和 缓存标识，但结果失效，强制缓存失效，则使用协商缓存（携带该资源的缓存标识、发起 http 请求） 存在改缓存结果和缓存标识，且结果尚未失效，强制缓存生效，直接返回该缓存结果 控制强制缓存的字段 Expires(http1.0) 和 Cache-Control (http 1.1)， 其中 Cache-Control 优先级较高 Expires , 缓存的到期时间，小于此时间，直接使用缓存结果， (客户端、服务端时间不一致) Cache-Control,主要取值 public， 所有内容都将被缓存(客户端、代理服务器都可缓存) private, 默认值 所有内容 只有客户端缓存 no-cache, 客户端缓存内容，是否使用缓存，需要经过协商缓存来验证决定 no-store,所有内容都不被缓存 max-age=xxx, 缓存内容将在 xxx秒后失效 强制缓存存放的位置 from memory cache (内存缓存)， 快速读取、时效性。 将编译解析后的文件，直接存入该进程的内存中，占据该进程一定的内存资源，一旦进程关闭，则改进程的内存会清空。 from disk cache (硬盘缓存)， 将缓存写入硬盘文件，读取缓存时需要对进行 I/O 操作，然后重新解析该内容，速度比内存缓存慢。 协商缓存在强制缓存失效后，浏览器携带缓存标识向服务器发起请求，由服务器根据缓存标识决定是否使用缓存的过程， 2 中情况 协商缓存生效，返回 304 协商缓存失效，返回 200 和请求结果 控制协商缓存字段 Last-Modified / If-Modified-Since 和 Etag / If-None-Match, 其中 Etag / If-None-Match 优先级较高 Last-Modified / If-Modified-Since Last-Modified, 服务器响应请求时，返回该资源文件在服务器最后被修改的时间 If-Modified-Since, 客户端再次发起请求时，携带上次请求返回的 Last-Modified 值，通过此字段告诉服务器该资源上次请求返回的最后修改时间。服务器收到该请求，会根据 If-Modified-Since 字段值与该资源在服务器的最后修改时间做对比，若服务器的资源最后修改时间大于 If-Modified-Since 字段值，则重新返回资源，状态码 200; 否则返回 304，代表资源无更新，继续使用缓存文件 Etag / If-None-Match Etag， 服务器响应请求是，返回当前资源文件的唯一标识( 由服务器生产) If-None-Match,客户端再次发起请求时，携带上一次请求返回的唯一标识 Etag 值，通过此字段值告诉服务器该资源上次请求返回的唯一标识值。服务器收到该请求后，会与该资源在服务器的 Etag 值做对比，一致则返回 304 Not Modified，代表资源无更新，可继续使用缓存文件；不一致则重新返回资源文件，状态码 200 总结 浏览器缓存分为强制缓存和协商缓存，强制缓存优先于协商缓存 若强制缓存生效（Expires 和 Cache-Control,Cache-Control 优先级高），直接使用缓存 若强制缓存不生效，则进行协商缓存（Last-Modified/If-Modified-Since, Etag/If-None-Match, Etag/If-None-Match 优先级高）， 协商缓存由服务器决定是否使用缓存 若协商缓存失效，代表请求的缓存失效，重新换取请求资源，返回 200，在存入浏览器缓存； 若协商缓存生效，返回 304， 可继续使用缓存 BFC(块级格式上下文)BFC 是 Block Formatting Context 的缩写，即块级格式化上下文。BFC 是 CSS 布局的一个概念，是一个独立的渲染区域，规定了内部 box 如何布局，并且这个区域的子元素不会影响到外面的元素。布局规则： BFC 是一个独立容器，容器里面的子元素不会影响到外面的元素 内部 Box 会在垂直方向，一个接一个地放置 Box 垂直方向的距离由 margin 决定，同一个 BFC 的两个相邻 Box 的 margin 会重叠 每个元素的 margin box，与包含块border box 的左边相接触 BFC 的区域不会与 float box 重叠 计算 BFC 的高度时，浮动元素也参与计算高度 元素的类型和 display 属性 决定了此 box 的类型，不同 box 类型有不同的 formatting context 如何创建 BFC？ 根元素， float 的值不为 none position 为 absolute 或 fixed display 的值 为 inline-bloc， table-cell， table-caption overflow 的值 不为 visible 元素水平垂直居中?水平居中 行内元素，text-align:center 确定宽度的块级元素 width 和 margin 实现， margin: 0 auto 绝对定位和 margin-left：(父 width - 子 width) / 2 ,父元素 position: relative 宽度未知的块级元素 display:table + margin 左右 auto display:Inline-block + text-aligin:center 绝对定位+ transform， translateX 移动本身元素的 50% flex 布局 使用 justify-content:center 垂直居中 line-height， 适合纯文字类 父容器 相对定位，子级设置 绝对定位，通过 margin 实现或者 通过 位移 transform flex， table 布局，父级 display：table, 子级 vertical-align 页面布局FLex 布局容器的属性 flex-direction,主轴方向 flex-wrap, 换行规则 flex-flow, flex-direction 和 flex-wrap 的复合属性， flex-flow: row-reverse wrap; justify-content, 水平主轴方向的对齐方式 align-item, 竖直侧轴方向 的对齐方式 align-content, 容器有多行项目时，垂直方向的对齐方式 元素/项目的属性 order, 项目的排列顺序，越小越靠前 flex-grow, 放大比例 flex-shrink,缩小比例，为 0， 则不缩小 flex-basis, 设置伸缩基准值(初始长度) flex, flex-grow ,flex-shrink, flex-basis 的复合属性， 默认值 0 1 auto align-items, 默认 auto,继承父元素 Rem 布局Rem 是相对于 根元素(html) 的 font-size 大小来计算，其本质是具基于宽度的等比缩放。 缺点： 改动多，所有盒子都需要我们去给一个准确的值，才能保证不同机型的适配 在响应布局中，必须通过 js 来动态的控制根元素 font-size 大小。css 与 js 有一定的耦合性，且必须将改变 font-size 的代码放在 css 样式之前 百分比布局子元素的百分比并非完全相对于直接父元素的 height、width。 padding、border、margin 等属性不论是水平 ，还是垂直方向都相对于直接父元素 width border-width, translate、background-size 则相对于自身 清除浮动 添加标签，设置 clear:both 属性 父级添加 overflow 属性，或设置高度 建立 伪元素 选择器 清除浮动 1234567891011&lt;div class=&quot;parent&quot;&gt; &lt;div style=&quot;clear:both&quot;&gt;&lt;/div&gt;&lt;/div&gt;.parent::after &#123; content: &quot;&quot;; display: block; height: 0; visibility:hidden; clear: both;&#125; JS 垃圾回收机制如果存在大量不被释放的内存(堆、栈、上下文)，页面性能会变的很慢。当某些代码操作不能别合理释放，就会造成内存泄露 浏览器垃圾回收机制：浏览器的 js 具有自动垃圾回收机制，垃圾收集器会定期的找出那些不在继续使用的变量，然后释放其内存。 标记清除（mark-and-sweep）：当变量进入上下文，会被加上存在于上下文的标记。当变量离开上下文时，会被加上离开上下文的标记。 垃圾回收程序运行的时候，会标记内存中存储的所有变量，然后将所有上下文中的变量，以及被上下文中的变量引用的变量的标记去掉，之后再有标记的变量就是待删除的（任何在上下文中的变量都访问不到它们了），随后垃圾回收程序做一次内存清理，销毁带标记的所有值并回收它们的内存。 引用计数：记录每个变量被引用的次数，当一个值的引用数减为 0 时，就会被回收 闭包在 js 中变量的作用域属于函数作用域，在函数执行完毕后，作用域就会被清理，内存也随之被回收。但是由于闭包函数是建立在函数内部的子函数，由于其可访问上级作用域，即使上级函数执行完，作用域也不会随之销毁，这时的子函数（即闭包），便拥有了访问上级作用域中变量的权限。 闭包形成的条件 函数的嵌套 内部函数引用外部函数的局部变量，延长外部函数的变量生命周期 闭包的用途 模仿块级作用域 保护外部函数的变量（阻止其被回收） 封装私有变量 创建模块 JS 中 this 的五种情况 作为普通函数执行时，this 执行 window 当函数作为对象的方法被调用时，this 指向该对象 当使用 new 来实例化一个构造函数时，this 指向实例 箭头函数中 this 是在定义时绑定的，指向它的父级作用域 基于 Function.prototype 上的 apply、call、bind 调用，这三个方法都可以显示的指定调用函数的 this 指向 原型&amp;&amp; 原型链 每个构造函数都有原型prototype 每个实例都有隐式原型__proto__ 实例的__proto__指向构造函数的prototype new运算符的实现机制 创建一个新的空对象 设置原型，将对象的原型设置为函数的prototype对象 让函数的this指向该对象， 执行构造函数代码(为这个新对象添加属性) 如果无返回值或返回一个非对象值，则返回该对象，否则会将返回值作为新对象返回 123456new Animal(&#x27;cat&#x27;) = &#123; var obj = &#123;&#125; obj.__proto__ = Amimal.prototype var result = Animal.call(obj,&#x27;cat&#x27;) return typeof result == &#x27;object&#x27; ? result : obj&#125;","categories":[{"name":"技术总结","slug":"技术总结","permalink":"https://better-jiang.github.io/categories/%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%93/"}],"tags":[{"name":"技术总结","slug":"技术总结","permalink":"https://better-jiang.github.io/tags/%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%93/"}]},{"title":"人际交往之困","slug":"人际交往之困","date":"2022-06-14T01:01:20.000Z","updated":"2023-02-03T12:14:22.423Z","comments":true,"path":"2022/06/14/人际交往之困/","link":"","permalink":"https://better-jiang.github.io/2022/06/14/%E4%BA%BA%E9%99%85%E4%BA%A4%E5%BE%80%E4%B9%8B%E5%9B%B0/","excerpt":"","text":"最近有两件事情，让我开始也必须去真正的去思考，要如何处理人际关系？并越发的认识到自己以前的方式是有问题的,事实上也被证明了。内向，不善社交，更不愿社交。每每面对他人时，会紧张，会回避，从而被感觉态度冰冷且无趣。即使如此，却没能保持如一至终，大不了孤渡残生，不能同好友开心相处，也不应去变扭局促的，不自然，不愉快的让其他人适应如此的自己。一味的将不喜社交作为种种借口，其实无非是害怕失败，害怕被鄙夷轻视，改变很难，这是我人生一大坎，如何迈过，我在它面前，犹豫徘徊了 20 多年。仿佛深陷泥泽，四周无人，无助且痛苦的挣扎着，煎熬着。反反复复的幻想着，有朝一日能克服心魔，战胜社恐，于亲朋好友间嬉笑而谈，自然舒适相处。抱着如此幻想，好似有了希望与支撑，日子一点一点过着，不知自己还能坚持多久？更担心现在自己周边的朋友还能对我宽容、理解多久？总有一天，它们会厌倦，会失去耐心，会选择离开。为什么这么久了，你都不去改变？X，不管了，我不做人了，要去改变，大不了不做朋友，如果以后还有机会相识，在尽力补偿吧。不断试错，总结，调整，再尝试。","categories":[{"name":"技术总结","slug":"技术总结","permalink":"https://better-jiang.github.io/categories/%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%93/"}],"tags":[{"name":"反思怪","slug":"反思怪","permalink":"https://better-jiang.github.io/tags/%E5%8F%8D%E6%80%9D%E6%80%AA/"}]},{"title":"小白笔记-微前端","slug":"小白笔记-微前端","date":"2022-06-13T03:43:12.000Z","updated":"2023-02-03T12:14:22.423Z","comments":true,"path":"2022/06/13/小白笔记-微前端/","link":"","permalink":"https://better-jiang.github.io/2022/06/13/%E5%B0%8F%E7%99%BD%E7%AC%94%E8%AE%B0-%E5%BE%AE%E5%89%8D%E7%AB%AF/","excerpt":"","text":"什么是微前端？微前端提供了一种技术可以将多个独立的 web 应用聚合到一起，提供统一的访问入口。 微前端的思路把后端微服务的架构引入到前端，其核心是能够已业务为单位构建端到端的垂直架构，使等单个的团队能够独立自主的进行相关的开发。 微前端的核心思路 是 远程应用程序，包含组件/模块/包的运行时加载。对于用户而言，访问的是一个微前端的容器，容器加载运行在远程服务器上的应用，把这些远程应用作为 组件/模块/包 在 本地浏览器中加载。 组件是底层 UI 库的构建单元 模块是相应运行时的构建单元 包 是 依赖性解析器的构建单元 微前端 是 所提出的应用程序的构建快 微服务主要思路： 将应用分解为小的、互相连接的微服务，一个微服务完成某个特定功能 每个微服务都有自己的业务逻辑和适配器，不同的微服务，可以使用不同的技术去实现。 使用统一的网关进行配置 为什么需要微前端，优势？随着业务复制度的上升，保体积越来越大，每个版本小需求功能都会导致项目的全量部署，测试，上线，费时费力，加剧了出错风险。 在微前端中，web 应用被拆分为多个模块，每个模块可独立开发、测试、部署。更改一个模块不会影响到其他模块。 拆分大应用为小应用，方便迭代更新，且兼容历史应用，实现增量开发 特点/优势 松耦合代码、独立部署 增量开发 团队自洽 通过路由进行跨应用程序通信 解决大型项目迭代问题 解决多团队技术栈不同的问题 如何实现微前端架构？从构建的角度来看有两种，编译时构建、运行时构建 编译时微前端，通查将第三方库中的组件作为包，在构建时引入依赖。这种实现引入新的微前端需要重新编译，不够灵活。编译时的微前端可以通过webComponents，Monorepo实现。 运行时微前端， 一次加载或延迟加载 按需动态将微型前端注入到容器应用程序中。不需要构建，可以动态在代码中定义加载。 Module Federation (webkpack5)中的新特性，主要用来解决多个应用之间代码共享问题。 具体实现方式？基于 iframe 完全隔离的方案 简单，无需改造 完美隔离，js、css 都是独立的运行环境 无法保证路由状态，刷新后路由状态丢失 完全的隔离导致与子应用的交互变的困难 整个应用全量资源加载，性能差 基于 single-spa 路由劫持方案 通过劫持路由的方式来做子应用直接的切换，但计入方式需要融合自身路由，有一定的局限性 qiankun 是对 single-spa 做了一层封装，通过 import-html-entry 包 解析 HTML 获取资源路径，然后对资源进行解析、加载。 京东 micro-app 方案 借鉴 WebComponet 的思想，通过 CustonmElement结合 自定义的 ShadowDom， 将微前端封装成一个类 webComponent 组件，从而实现微前端的组件化渲染 技术选型 single-spa， 第一个微前端框架，其提供较为基础的 api，应用在实际项目中 需要进行大量封装且入侵性强，使用不方便。 qiankun，阿里开源的，基于 single-spa 的上层封装，在国内生态较好，有先行者铺路 EMP， 基于 module federation 实现的一套可以跨应用共享资源的框架，处理具备微前端的能力外，还实现了跨应用状态共享、跨框架组件调用的能力。","categories":[{"name":"技术总结","slug":"技术总结","permalink":"https://better-jiang.github.io/categories/%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%93/"}],"tags":[{"name":"烂笔头","slug":"烂笔头","permalink":"https://better-jiang.github.io/tags/%E7%83%82%E7%AC%94%E5%A4%B4/"}]},{"title":"vite入门笔记","slug":"vite入门笔记","date":"2022-06-06T01:42:39.000Z","updated":"2023-02-03T12:14:22.423Z","comments":true,"path":"2022/06/06/vite入门笔记/","link":"","permalink":"https://better-jiang.github.io/2022/06/06/vite%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B0/","excerpt":"","text":"vite 由两部分组成： 开发服务器，支持原生ES模块，服务器启动，热更新（HRM）的速度更快。 vite 通过将应用中的模块区分为 依赖 和 源码两类。 对于依赖，大多是不会变动的纯js，vite 是会使用esbuild 预构建依赖（它使用Go编写，速度快） 对于源码，通常是一些需要转换的非js文件（如 JSX，CSS，Vue等），时长被编辑。vite 以 原生ESM方式提供源码，只需要在浏览器请求源码时进行转换并按需提供源码。 在vite中，HMR 是在原生ESM上执行的，当编辑一个文件时，vite 只需使已编辑的模块与其最近的HRM边界之间的链 失活，所有无论应用大小如何，HMR 始终能保持快速更新。 vite 也会使用http头来加速整个页面的重新加载。 源码模块的请求，会 根据 304 Not Modified 进行协商缓存。 依赖模块请求，则 设置请求头Cache-Control:max-age=31536000,immutable 进行 强制缓存。 一套构建指令，使用Rollup打包代码，可输出用于生产环境的高度优化过的静态资源。 服务器启动，更新 为什么缓慢？ 在浏览器支持ES模块之前，需要我们对源码进行”打包”，使用工具抓取、处理并将源码模块串联成可以在浏览器运行的文件。所有随着项目体积的增长，每次”打包”时间也越来越久，更新的时间也随之增长。 npm依赖解析和预构建原生ES导入不支持裸模块导入import &#123; someMethod &#125; from &#39;some-dep&#39;, 在浏览器中会抛出一个错误。vite 会检测到所有被加载的源文件中此类裸模块导入，并执行如下操作： 预构建，将 CommonJS / UMD 转换为ESM格式 重写导入为合法的URL， 如/node_modules/.vite/some-dep.js?v=f2123d223,以便浏览器能够正确导入它们 模块热重载 HMRvite 提供已一套 原生 ESM 的HRM API，具有HRM 功能的框架可以利用该API提供即使更新，而无需重新加载页面。vite 内置了HMR 到 Vue 单文件组件和 React Fast Refresh中 Tyscript vite 天然支持引入 .ts文件，但 vite 仅执行.ts文件的转义工作，并不执行或任何类型检查，需要IDE或在构建过程中进行类型检查。如在构建脚本中 使用 tsc --noEmit vite 使用 esbuild 将 ts 转义到 js，比 tsc快很多 客户端类型vite 默认的类型定义是写给它的Node.js API的，要将其补充到一个 vite 应用客户端代码环境中，添加一个d.ts声明文件，可提供以下类型定义补充： 资源导入 (例如，导入一个.vue、.svg文件) import.meta.env 上 vite 注入的环境变量的类型定义 import.meta.hot上的 HMR API 类型定义 12345678/// &lt;reference types=&quot;vite/client&quot; /&gt;declare module &quot;*.vue&quot; &#123; import type &#123; DefineComponent &#125; from &quot;vue&quot;; // eslint-disable-next-line @typescript-eslint/no-explicit-any, @typescript-eslint/ban-types const component: DefineComponent&lt;&#123;&#125;, &#123;&#125;, any&gt;; export default component;&#125; CSS 导入.css文件其内容会被插入到&lt;style&gt;标签中，同时也带有HRM支持。 @import 内联和变基，vite 通过 postcss-import 预配置支持了CSS@import内联， vite 的路径别名也遵从css @import","categories":[{"name":"烂笔头","slug":"烂笔头","permalink":"https://better-jiang.github.io/categories/%E7%83%82%E7%AC%94%E5%A4%B4/"}],"tags":[{"name":"vite","slug":"vite","permalink":"https://better-jiang.github.io/tags/vite/"}]},{"title":"晋升答辩(凉了)","slug":"晋升答辩-凉了","date":"2022-05-30T09:33:27.000Z","updated":"2023-02-03T12:14:22.423Z","comments":true,"path":"2022/05/30/晋升答辩-凉了/","link":"","permalink":"https://better-jiang.github.io/2022/05/30/%E6%99%8B%E5%8D%87%E7%AD%94%E8%BE%A9-%E5%87%89%E4%BA%86/","excerpt":"","text":"大家好，我是来好车主保险开发组 网销非车项目的刘振江 ，是一名前端工程师。我们项目主要负责维护微信保险商城官网，支付宝小程序平安产险，以及对 ITS 电销录单的支持，本人负责组内前端需求评审、任务分配，也做常规需求开发，支持营销活动，组织我们组内代码评审，技术分享。 我是 20 年 7 月份入职的，当时组内仅我一个内编，所有自然成了组内的前端负责人。那时候我们项目组 人多活也多，需求变动频繁，要快速上线，为此大家熟悉什么技术，就用什么，没有一个统一的技术栈，老的有 shtml、jQ，jsp，新的有 vue2、react，同时部署发版也没用神兵流水线进行管理，使用的是 EasyOps，手动上传资源，特麻烦，容易出错。 对于以上问题，借助一次做迁移核心报价需求的机会，我统一了技术栈，选择了最常见也是大家易上手 vue 套件，element ui 组件库。接着逐步的梳理代码，业务逻辑，拆分功能，进行模块化改造。然后在功能封装的基础上，又封装进了 UI、业务逻辑，实现了组件化。后来在代码评审中，又发现大家写代码的风格各异，质量良莠不齐，为此一点一点的制定了些约束规范，例如目录结构规范，命名规范、编码规范，vue 组件开发规范。为了支持产品快速开发，上线，动态的变更，我们逐步搭建了管理平台，来管理产品的配置，上下架，营销活动，以及项目素材等 正因为做了 3 点上面，我们也产生了价值贡献。首先因为升级了报价系统，构建了管理平台，间接提升系统是稳定性，以及能及时响应市场变化的能力。组件化 + 可配置的开发模式，缩短了标准产品上线周期，从 1 周到 1-2 天。一页流式的报价页面，最小化的信息填写，使得报价速度更快，缩短了用户询价、支付的时间，同时提升了电销坐席录/出单效率。统一的技术栈，逐步完善的开发规范，使得组员间协作更高效，同时这也确保了开发质量。另外，在我做常规宠物险类开发需求时，也挖掘并成功申请一项外观专利。 未来我还最想的事情有 4 件， 第一个 是做接口的规范化，能引入一个接口管理平台来维护，因为现在前后端分工明确，接口在前后端联调、对接过程中其启关键作用，规范化能够避免沟通时产生不必要问题。 其次，是能细化部署，每条流水线负责单一功能模块，按需部署，而非现在 每次仅改动一点需求，都要全量部署，做全量的回归测试，既增加了测试同事工作量，又无形中提高了出问题风险。 第 3 个，技术在上升一个台阶，能将 vue2 升级到 vue3，并引入 TS，工程化，重要功能模块，能有单元测试覆盖。 最后，我希望能把我们项目组用的技术、踩的坑，收获的经验教训，能够沉淀整理出来，给分享给新同事或其他需要的团队。再一个梳理组内已开发的组件，对其再做一层抽象，使其能更通用，并搭建出一个小的组件库。 最后，我要感谢我的领导焜哥、伍总，对我的信任，对我想法的支持，给予我充分自主决策的空间，放手让我去做事情。同时 感谢同事对我的包容和支持，能和他们一起愉快工作，共同成长，并作出一些成绩，我自己也挺有成就感的。","categories":[{"name":"技术总结","slug":"技术总结","permalink":"https://better-jiang.github.io/categories/%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%93/"}],"tags":[]},{"title":"ESLint原理理解","slug":"ESLint原理理解","date":"2022-05-30T02:16:07.000Z","updated":"2023-02-03T12:14:22.423Z","comments":true,"path":"2022/05/30/ESLint原理理解/","link":"","permalink":"https://better-jiang.github.io/2022/05/30/ESLint%E5%8E%9F%E7%90%86%E7%90%86%E8%A7%A3/","excerpt":"","text":"为啥要用ESLint?团队成员代码风格不同，水平各异。如果允许成员任意发挥，随意coding，不做任何约束的话，随着项目规模慢慢变大，项目代码将很有可能成为难以维护的屎山。所有对于代码的基本写法需要有约束，当代码编写不合约束时能给出提醒，同时能自动修复，这些正是ESLint 要做的事情。 找出代码中不符合规范的地方，报出异常或错误，给出提示 能自动修复 不合规的代码 自定义规则 ESLint 如何工作？ESLint 是如何读懂代码，甚至自动修复不合规代码呢？关键是AST（抽象语法树），其中 ESLint 是使用espree来生成 AST 的。 ESLint 会遍历 AST，然后在遍历到不同的节点或特定的时机的时候，触发相应的处理函数，在处理函数中抛出错误、提示。 ESLint 流程大致分为 读取配置、加载配置、检验、修复。 读取配置ESLint 首先会从各种配置文件中读取配置，例如 eslintrc 或package.json中的eslintConfig字段中，或使用命令行执行 eslint 时指定任意一个配置文件 先读取给定目录下最近的配置文件 相同目录存在多个配置文件，仅有一个配置文件会被读取，.eslintrc 优先级的配置文件会高于package.json配置 内层目录没有，会默认向外层文件夹逐层读取配置文件， 可通过在配置文件添加root:true来阻止逐层读取 如果多个配置文件里都配置了重复字段的话，离给定目录最近的配置会生效 加载配置ESLint会依次加载配置里的extends,parser,plugin等，其中 extends 是其他配置文件，可以复用插件中的配置或者第三方模块中的配置 ESLint 会递归地去读取配置文件中的extends,最终各个配置对象的顺序是[{内层配置}，{内层配置的extends}，{外层配置}，{外层配置中的extends}]，之后会进行合并操作，具体合并逻辑 对于 parser、processor字段，后面的配置会覆盖前面的配置 对应 env、globals、parserOptions,settings 字段会合并在一起，但只有当后面的配置存在，而前面的没有该字段时，这个字段才会被合并进来，如果前面有，那么后面的相同自读会被摒弃 对应 rules，前面的配置优先级高，如果存在的rule里有参数，参数会被合并 parser 用于解析AST plugin 是用户自定义的插件，可映入自定义规则，以及对非js文件的检查和处理等 检查当获得所有需要的配置后，接下来就会进入检验流程，大致执行顺序 处理 processor processor 是在插件上定义的处理器，并针对特定后缀文件定义preprocess 和 postprocess 两个方法。 preprocess方法接受文件源码和文件名作为参数，返回需要被检测的代码或文件的数组。 postprocess 在文件被检验完后，对所有的lint problem 进行统一处理 解析代码， 获取AST 和 节点 数组，没有指定parser时，默认使用 espress 跑规则 runRules ESLint 的核心就是处理一条一条的规则，如何处理？ 收集AST所有的节点 遍历所有配置中的rule，并通过rule的名称找到对应的rule对象。ESLint 会为rule对象里的AST节点添加相应的监听函数，以便在后面遍历AST节点时可以出发相应的处理函数 再次遍历收集的AST节点，出发相应的节点监听函数，在监听函数中调用方法收集所有的eslint 问题 修复ESLint 的 rule 对AST进行检查，并报错。fixer 则根据 AST节点中保留的 range 信息(源码的下标范围)来修改代码","categories":[{"name":"技术总结","slug":"技术总结","permalink":"https://better-jiang.github.io/categories/%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%93/"}],"tags":[{"name":"eslint","slug":"eslint","permalink":"https://better-jiang.github.io/tags/eslint/"}]},{"title":"九龙山飞盘交流赛","slug":"九龙山飞盘交流赛","date":"2022-05-23T00:37:36.000Z","updated":"2023-02-03T12:14:22.423Z","comments":true,"path":"2022/05/23/九龙山飞盘交流赛/","link":"","permalink":"https://better-jiang.github.io/2022/05/23/%E4%B9%9D%E9%BE%99%E5%B1%B1%E9%A3%9E%E7%9B%98%E4%BA%A4%E6%B5%81%E8%B5%9B/","excerpt":"","text":"已经是赛后第 3 日了，照片、视频也在微信群中发完，讨论比赛的声音渐少渐弱。而我却不太愿参入其中，只是希望赶快遗忘，毕竟羞辱与失落，带着伤与痛，除了令我不好受，更多的是不理解。为何大家能自然的去指责队友，能理所当然的批评他人，而忘记交流和谅解。 失误，配合不畅本就是常态，真没必要过多指责。我们都太高估自己了，自诩高质量训练局，自认为是老鸟，玩盘多年，技术经验兼具，队伍实力比较强。不能输，必须要打出理想的效果，几个教练多少有如此想法。所有我们输不起，不接受失误，打的效果差会感到耻辱，且需要立即调整改变。如此一来，评判、指责多了，没有克制的肆意表现出。无效的惩罚来了，再失误下去，别打了。传盘趋于保守，以至于需要按规定动作执行。有了规定，也就有了指责挑错的依据，渐渐的势头也不对了，每个人都莫名其妙的有了压力，心里上也有了负担，没了乐趣可言。 没有人并非玻璃心，仅是被太理解，也不被理解。为什么平时愉快相处，其乐融融的队友会如此苛责，不能好好交流吗？比赛输赢真的比我们之间的友情更重要吗？我们到底是好友吗？掉盘，没配合好，不能如你所愿的跑位，阻挡你了，真的令你如此气愤而需找人发泄吗？ 玩飞盘，首要是收获乐趣，如果不能，我必然离开。 惩罚只能告诉我们做错了什么，什么又是对的呢？不知道。相反，鼓励告诉我们什么事情做对了，下次还这样做就好了。成功就是做对了几件事，其他千万情况下都是错，错是常态，错是不可预知的。鼓励代替指责，多鼓励队友，能同队友舒适、自然相处，多听听队友的想法，听听他为啥会那要做后，你会理解他的行为，或者你会更无语了，无语就无语吧，别去任意指责他们。没有调研就没有发言权，没有设身处地，就没有感同身受，就会有自我的无法理解而产生的疑惑，气愤。","categories":[{"name":"随笔感悟","slug":"随笔感悟","permalink":"https://better-jiang.github.io/categories/%E9%9A%8F%E7%AC%94%E6%84%9F%E6%82%9F/"}],"tags":[{"name":"飞盘","slug":"飞盘","permalink":"https://better-jiang.github.io/tags/%E9%A3%9E%E7%9B%98/"}]},{"title":"萌新飞盘教练的点滴认知","slug":"萌新飞盘教练的点滴认知","date":"2022-05-05T02:48:35.000Z","updated":"2023-02-03T12:14:22.423Z","comments":true,"path":"2022/05/05/萌新飞盘教练的点滴认知/","link":"","permalink":"https://better-jiang.github.io/2022/05/05/%E8%90%8C%E6%96%B0%E9%A3%9E%E7%9B%98%E6%95%99%E7%BB%83%E7%9A%84%E7%82%B9%E6%BB%B4%E8%AE%A4%E7%9F%A5/","excerpt":"","text":"最近在学弟（嘉伟）组织的飞盘局中做了几次新手教练，讲真挺有压力的，毕竟学员交了钱，且带着对飞盘的热爱和学习的欲望而来，我希望自己能好好的教学，让学员能学到飞盘技术，也能玩的开心，体验到玩飞盘的快乐。 对于一个中度社恐、慢热、不善言辞，也非圈中大牛的我来说，教新人飞盘，其实我挺不自信的，尤其是面对妹子，更会慌张不安。但是，这一切都在好转，我在慢慢改变，通过总结复盘，向其他老师学习，并刻意去练习后，我紧张有所缓解，讲解规则也更清晰有条理，同时也认识一些新朋友。 对于新手而言，最容易犯的错误有下面几点： 传盘时，慌张着急传盘、重心不稳时传盘、不看队友传盘、双腿站定传盘、传盘质量差(高飘，无方向，传盘手势不对) 接盘时，站立等盘、距持盘人太进，拥挤成团、接盘手势不对、无变向甩不开防守人 防守时，看盘不看人、失误转换时漏人 cut-dump-deep 练习 需要讲解地方 cut，变向后 冲向 handler，接盘， （变向摆脱防守人，不要等，防守人会跟上） 接盘后，向前传盘有防守，受阻，dump 回 handler (dump 时 迈步，将防守人移身后， 盘要旋转，有提前量，高度 在 handler 身躯中间部分) go deep 者，注意时机 (可设置目标区域，handler 向目标区域 传，cutter 也向目标区域跑 ) 后面可要讲些简单的横排战术 cutter、handler 站位 cut 、清开 路线 dump、 swing","categories":[{"name":"随笔感悟","slug":"随笔感悟","permalink":"https://better-jiang.github.io/categories/%E9%9A%8F%E7%AC%94%E6%84%9F%E6%82%9F/"}],"tags":[{"name":"飞盘","slug":"飞盘","permalink":"https://better-jiang.github.io/tags/%E9%A3%9E%E7%9B%98/"}]},{"title":"tcp-ip.md","slug":"tcp-ip-md","date":"2022-04-22T08:26:40.000Z","updated":"2023-02-03T12:14:22.423Z","comments":true,"path":"2022/04/22/tcp-ip-md/","link":"","permalink":"https://better-jiang.github.io/2022/04/22/tcp-ip-md/","excerpt":"","text":"封装PDU 协议数据单元物理层 数据位 （bit） 数据链路层 数据帧 （frame） 网络层 数据包 （packet） 传输层 数据段（segment） 应用层 数据 （data） MTU 最大传输单元 以太网 和 IEE802.3 对数据帧 都有限制，最大值 分别为 1500 字节，1492 字节。链路层的这个特性称为 MTU 当 IP 数据报的长度大于 MTU 时，网络层就需要对 数据报 进行 分片 netstat -in 命令 查看 网络接口的 MTU IP 数据报IP 协议是提供的数据传输服务是不可靠、无连接的。 不可靠，不保证数据报能成功到达目的地，发生错误时，丢弃，可靠性全由上层协议来提供。 无连接，每个数据报的处理是相互独立的，可不按发送顺序接收。 普通 IP 数据报 报头长度 20 字节， 版本号，4 位，0100 表示 IPV4， 0110 表示 IPV6 首部长度，4 位，IP 报头长度，包括 选项字段 服务类型（TOS），4 种，最小延时、最大吞吐量、最高可靠性、最小花费，4 个标识位 只能有一个被置为 1 总长度，16 位， 报头+数据部分长度，最长可达 65535 字节 标识/序列号，16 位，标识发送方发送的每一个数据报，如果发送的数据报未分片，则此值一次加 1 （分片）标志：3 位，第一位保留，未使用。第二位 DF（Don’t Fragment）,为 1，未分片。第三位 MF（More Fragment）,为 1，发生分片 偏移：13 位，分片相对于原始 IP 数据报开始处的偏移 生产周期（TTL），8 位，数据报可以经过的最多的路由器个数，如果数据报的 TTL 值被减至 0，丢弃 上层协议，8 位，标识那个协议向 IP 传送数据 ICMP 为 1， TCP 为 6，UDP 为 17 首部校验和：16 位，根据 IP 首部计算的校验和码 源 IP,目的 IP, 选项，数据报中可变长、可选的信息 IP 路由选择route -n 可查看路由表 使用 traceroute 来追踪路由过程 12345678traceroute www.shiyanlou.com1 192.168.43.25 (192.168.43.25) 8.572 ms 4.136 ms 3.803 ms2 * * *3 192.168.196.42 (192.168.196.42) 81.462 ms 38.798 ms 66.947 ms4 192.168.175.106 (192.168.175.106) 45.047 ms 76.935 ms 39.918 ms5 192.168.175.97 (192.168.175.97) 80.681 ms 77.482 ms *6 * * * 记录按序列号从 1 开始，每个记录就是一跳，每跳表示一个网关，每行个时间，是探测数据包向每个网关发送 3 个数据包后，网关响应时间 NAT 技术192.168.X.X 或 172.16.X.X,这是 C 类和 B 类网的私有地址，就是俗称的内网 IP ifconfig eth0, 查看内网 IP 123456789ifconfig eth0eth0 Link encap:以太网 硬件地址 02:42:ac:11:00:04 inet 地址:172.17.0.4 广播:172.17.255.255 掩码:255.255.0.0 UP BROADCAST RUNNING MULTICAST MTU:1500 跃点数:1 接收数据包:40137 错误:0 丢弃:0 过载:0 帧数:0 发送数据包:36312 错误:0 丢弃:0 过载:0 载波:0 碰撞:0 发送队列长度:0 接收字节:11485937 (11.4 MB) 发送字节:29181950 (29.1 MB) ARP (Address Resolution Protocol) 地址解析协议通过 IP 地址，查询对应的 MAC 地址在电脑和路由器中都有一个 ARP 缓存表，保存着近期与自己有过通信的主机的 IP 地址与 MAC 地址对应关系。使用过程： 当主机发送一个 IP 数据报时，会先查询一下自己的 ARP 缓存表 找到对应的 MAC 地址，则将 IP 数据报封装为数据帧，将 MAC 地址放在帧首部 如果查询 IP-MAC 值对 不存在，那么主机向网络中广播发送一个 ARP 请求数据帧，ARP 请求中包含待查询 IP 地址 网络内所有收到 ARP 请求的主机查询自己的 IP 地址，符合则回复一个 ARP 应答数据帧，其中包含自己的 MAC 地址 收到 ARP 应答后，主机将 IP-MAC 对应信息存入自己的 ARP 缓存，然后再据此封装 IP 数据报，再发送数据帧 ARP 代理如果 ARP 请求是从一个网络上的主机发往另一个网络上的主机，那么连接这两个网络的路由器就可以回答该 ARP 请求，此过程称作 代理 ARP ICMP 控制报文协议通信过程中发生各种问题时，ICMP 将问题反馈ping 程序和 traceroute 程序是两个常见的基于 ICMP 协议的工具 使用 tcpdump 命令查看 ping 命令包结构 sudo tcpdump -nnvXSs 0 -c2 icmp 开启监听 12345678910111213141516171819202122ping -c1 mirrors.cloud.aliyuncs.comsudo tcpdump -nnvXSs 0 -c2 icmptcpdump: listening on eth0, link-type EN10MB (Ethernet), capture size 262144 bytes08:31:40.124621 IP (tos 0x0, ttl 64, id 32833, offset 0, flags [DF], proto ICMP (1), length 84) 192.168.42.3 &gt; 100.100.2.148: ICMP echo request, id 3240, seq 1, length 64 0x0000: 4500 0054 8041 4000 4001 68c4 c0a8 2a03 E..T.A@.@.h...*. 0x0010: 6464 0294 0800 a743 0ca8 0001 6cf7 6162 dd.....C....l.ab 0x0020: 0000 0000 b5e6 0100 0000 0000 1011 1213 ................ 0x0030: 1415 1617 1819 1a1b 1c1d 1e1f 2021 2223 .............!&quot;# 0x0040: 2425 2627 2829 2a2b 2c2d 2e2f 3031 3233 $%&amp;&#x27;()*+,-./0123 0x0050: 3435 3637 456708:31:40.126595 IP (tos 0x0, ttl 101, id 31415, offset 0, flags [DF], proto ICMP (1), length 84) 100.100.2.148 &gt; 192.168.42.3: ICMP echo reply, id 3240, seq 1, length 64 0x0000: 4500 0054 7ab7 4000 6501 494e 6464 0294 E..Tz.@.e.INdd.. 0x0010: c0a8 2a03 0000 af43 0ca8 0001 6cf7 6162 ..*....C....l.ab 0x0020: 0000 0000 b5e6 0100 0000 0000 1011 1213 ................ 0x0030: 1415 1617 1819 1a1b 1c1d 1e1f 2021 2223 .............!&quot;# 0x0040: 2425 2627 2829 2a2b 2c2d 2e2f 3031 3233 $%&amp;&#x27;()*+,-./0123 0x0050: 3435 3637 45672 packets captured2 packets received by filter0 packets dropped by kernel UDP 无连接，发送数据之前不需要建立连接，减小开销和时延 尽最大努力交付，不保证交付可靠性 首部开销小，8 字节 UDP 报头，对应从应用层交付下来的 IP 数据报，简单封装 没有拥塞控制，允许拥塞时丢失一些数据 支持一对一，一对多，多对一 UDP 报文UDP 报头+数据部分，UDP 报头总 8 字节，分 4 个字段： 源端口，2 字节，在对方需要回信时可用，不需要时全 0 目的端口，2 字节，必须 长度，2 字节，长度值包括 报头 和数据部分 校验和，2 字节，有错丢弃 TCP 可靠的，面向连接的 点对点，一条 TCP 连接只能连接 2 个端点 可靠传输，无差错，不丢失、不重复、按顺序 全双工 通信，允许双方任何时候都发送数据，连接两端都设有 发送缓存、接收缓存 面向字节流，仅把数据看作一连串的字节序列 建立连接（3 次握手） 客户端发出 请求连接报文段，报头控制位 SYN=1， 初始序列号 seq=x。客户端进入 SYN-SENT(同步已发送)状态 服务端收到请求报文段后，回发确认报文段，报头 控制位 SYN=1，ACK=1，确认号 ack=x+1,自己的初始序列号 seq=y。服务端 进入 SYN-RCVD(同步收到)状态 客户端 收到 服务端的确认报文段后，还要给服务器回发一个确认报文段， 报头控制位 ACK=1，确认号 ack=y+1，序列号 seq=x+1。 至此 TCP 连接建立，客户端进入 ESTABLISHED（已建立连接）状态，服务端 收到确认后，也进入 ESTABLISHED 状态 释放连接（4 次握手） TCP 两端都还处于 ESTABLISHED 状态，客户端停止发送数据，发送一个 FIN 报文段。FIN=1，序号 seq=u。客户进入 FIN-WAIT-1（终止等待）状态 服务端回复确认报文段，确认号 ack=u+1，序号 seq=v，服务端进入 CLOSE-WAIT（关闭等待）状态 客户端收到确认报文段，进入 FIN-WAIT-2 状态，服务端发送完数据后，发出 FIN 报文，FIN=1，序号 seq=w,确认号 ack=u+1,然后进入 LAST-ACK（最后确认）状态 客户端 回复确认报文段，ACK=1，确认号 ack=w+1，序号 seq=u+1，然后进入 TIME-WAIT（时间等待）状态 此时连接还未释放，需要时间等待状态结束 两端才会 CLOSED。 TCP 可靠传输的实现 TCP 报文段的长度可变，根据收发方的缓存状态、网络状态 进行调整 TCP 收到数据后，将回发一个确认报文，以告知发送者收到数据 超时重发 当 TCP 发出一个报文段后，它启动一个定时器，等待目的端 回发的确认，如果不能及时收到一个确认，将重发。 发送者在发送一个报文段后，要暂时保存该报文段的副本，为发生超时重传时使用，收到确认报文后删除该报文段 TCP 将检验报头的校验和，如果发现报文段有差错，则丢弃该报文段，等待超时重传 TCP 将数据按字节排序，报文段通过序号确保顺序 TCP 提供流量控制，两端都有缓存区 TCP 可靠传输的实现 TCP 报文段的长度可变，根据收发方的缓存状态、网络状态 进行调整 TCP 收到数据后，将回发一个确认报文，以告知发送者收到数据 超时重发 当 TCP 发出一个报文段后，它启动一个定时器，等待目的端 回发的确认，如果不能及时收到一个确认，将重发。 发送者在发送一个报文段后，要暂时保存该报文段的副本，为发生超时重传时使用，收到确认报文后删除该报文段 TCP 将检验报头的校验和，如果发现报文段有差错，则丢弃该报文段，等待超时重传 TCP 将数据按字节排序，报文段通过序号确保顺序 TCP 提供流量控制，两端都有缓存区 流量控制、拥塞控制慢启动，加性增，乘性减 慢启动，初始的窗口值很小，按指数规律增长，直到“阈值” 加性增，窗口值达到“阈值”后，每发送一个报文段，窗口值就增加一个单位量 乘性减，无论什么阶段，只要出现超时，则把窗口值 减少 一半","categories":[{"name":"技术总结","slug":"技术总结","permalink":"https://better-jiang.github.io/categories/%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%93/"}],"tags":[{"name":"网络","slug":"网络","permalink":"https://better-jiang.github.io/tags/%E7%BD%91%E7%BB%9C/"}]},{"title":"计算机网络初识","slug":"计算机网络初识","date":"2022-04-13T01:32:16.000Z","updated":"2023-02-03T12:14:22.423Z","comments":true,"path":"2022/04/13/计算机网络初识/","link":"","permalink":"https://better-jiang.github.io/2022/04/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%88%9D%E8%AF%86/","excerpt":"","text":"概念 协议： 一系列规则和约定的规范性描述 数字带宽： 指在单位时间内流经的信息总量 吞吐量： 实际的、可测到带宽 点到点（Point to Point）: 信源机 和 信宿机 之间 的通信 由一段一段的直接相连的机器间通信组成 端到端（End to End）：信源机 和 信宿机 之间 直接通信，好像拥有一条 直接的线路 参考模型/分层分层原则： 信宿机 第 n 层 收到的对象 应与 信源机第 n 层 发送出 的对象完全一致。 分层模型 OSI 七层模型 Applicaiton Presentation 表示层 Session 会话层 Transport Network Data Link 数据链路层 Physical 物理层 TCP/IP 四层模型 Application Transport Internet Network Access 5 层混合参考模型 Application (数据流 Data stream) Transport (数据段 Segment) Network (分组 Packet) Data Link (帧 Frame) Physical (比特流 BIts) 物理层物理层 提供透明的比特流传输，不关心比特流里携带的信息。 呈现 4 大特性 机械特性(mechanical characteristics)， 指明接口所有接线器的形状、尺寸、引脚数、排列等 电气特性(electrical)，指明在接口电缆的各条线 上出现 的电压 范围 功能特性(functional)， 某一电平 的电压 表示 何种意义 规程特性(procedural)，对于不同功能的各种可能事件的出现顺序 信号的传输信号在传输的过程中，可以看成由很多不同频率的分量的传输，因为 高频分量的不等量衰减，接收方收到的信号是衰减和**失真(变形)**的 截止频率：，一般从 0~fc 这一频段，振幅在传输过程不会明显衰减，fc 称为 截止频率 奈奎斯特定理 （无噪声 信道,理想信道） 最大 传输速率 = 2Blog_2V (bps) B, Hz, 物理带宽 V 离散等级 香农定理 （有 噪声 信道） 最大 传输速率 = B log_2(1 + S/N) (bps) B, Hz, 物理带宽 S/N, 信噪比 ， 分贝值 = 10 log_10(S/N)(dB), 例如 噪声 30dB， 则信噪比 S/N = 1000 传输介质 引导性 (有线) 铜线 (同轴电缆，双绞线) 光纤 非引导性(无线) 无线电 卫星 复用技术 频分多路复用 （FDM, Frequency Division Multiplexing) 在干线起点，信道的频谱 被分成 若干频段，每个用户占据其中一段 来传输 自己的信号 到了干线终点， 每个频段 的信号被单独分离出 相邻用户 使用 的 频段之间，通常留有 一定的带宽，以免混淆。 此频段 为 保护带 正校频分多路复用 （OFDM，Orthogonal FDM），没有保护带，频段之间 可相互重叠 波分多路复用 (WDM，Wavelength Division Multiplexing) 按不同的波长，分成若干份，承载不同用户的光信号，到了终点，分离器分离出各子信号 时分多路复用 TDM（Time Division Multiplexing） 在时间上共享信道，将时间划分为非常短的时间片 每个用户周期性 地 在自己的时间片 内使用整个带宽 统计 时分多路复用 （Statistic TDM， STDM） 按需分配：动态分配信道，不是用信道的用户不分配，分给有需要的用户使用 物理层设备 收发器(Transceiver)，将一种形式的信号 转变 成 另一中形式，负责收发信号 中继器(Reapter)，主要功能是再生信号 (去噪、放大)， 让线缆可以延伸得更远，不能过滤流量 集线器 (Hub)， 多端口 的中继器，再生信号，可作为 星型拓扑的中心，它收到一个信号，就广播出去 中继器、集线器 都扩大了冲突域 数据链路层保障 数据传输的有效、可靠 处理传输错误： 差错检测 和 控制 流量控制： 基于速度 基于反馈 成帧将原始的比特流分散到离散的帧中，叫成帧，成帧方法： 字符计数法 带字节/字符填充的标志字节法 每一帧使用特殊的字节/字符作为 开始 或 结束 容易造成 帧界 混淆 比特填充的比特标志法 面向二级制位的帧格式，把所有需要传输的数据以比特位排开，以特殊的位模式01111110作为帧标志， 当帧内容出现一个和帧标志相同的位串时 01111110, 则 在 5 个 1 后插入一个 0，变成 01111101,接收方 自动删除第 5 个 1 后的 0 物理层编码违例法 在曼切斯特编码中，连续高电平或连续低电平 可用作 帧边界 差错处理 纠错， 发现错误，从错误中恢复出正确信息，其需要太多的冗余位，纠错开销大 检错，智能发现错误，不能恢复，但可采用重传， 主要采用 循环冗余码(CRC) 海明距离(Hamming Distance) 码字：包含数据位和校验位的 n 为单元 海明距离： 两个码字之间不同位的数目，异或的结果中，1 的个数 全部码字的海明距离：， 全部码字中任意两个 码字 之间 海明距离的最小值 海明距离的意义：如果海明距离为 d， 则一个码字需要发生 d 个 1 位错误 才能变成另外一个码字 海明距离与检错的关系海明距离为 d+1 的编码 能监测出 d 为差错， 因为在距离为 d+1 的检验码中，只能改变 d 位的值，不可能产生另一个合法码。 海明距离与纠错的关系海明距离为 2d+1 的编码，能纠正 d 位差错，因为此时，如果一个码字有 d 位发生差错，它仍距原来的码字距离最近，可以直接恢复为该码。 纠 1 位错的海明码数据 m 位，冗余位人，编码后的码字位数 n(n=m+r)。因为要传输的数据位是 m 位，需要传输的正确的码字个数 是 2^m，全部码字的个数 2^n,如果每个正确码字 发生 1 位错，能够被纠错，至少发生 1 位错不会变成另外 1 个正确的码字，如果 n 位码字的每一位都发生一次跳变，变成一个错误的码字，那么每个码字至少需要 n+1ge 码字来表示它。所以：(n+1)*2^m &lt;= 2^n, n = m +r; (m+r+1)&lt;=2^r 滑窗协议提高信道利用率 全双共 捎带确认 批量发送数据(滑窗技术，2 个滑窗) 发送窗口，已经发送但还未被确认的帧的序号 接收窗口，期望接收的帧的序号 滑动窗口基本概念 每个待发送帧 被 赋予 一个序列号 seq， seq 的取值范围 0 ~ 2^n -1 (n 位字段) 建立缓存区 发送窗口， 缓存已发送、待确认的帧 顺序接收来自网络层的分组，成帧，赋予序列号 最多保存 W 个 已经发送、等待确认的帧 窗口达到最大值 W 时，强制关闭网络层 接收窗口，缓存期待接收的帧(序号) 对进入窗口的帧 顺序提交网络层，产生确认 落在窗口外的帧被丢弃 窗口滑动条件 接收方收到帧后，首先核对是否 为预期 帧号(frame_expected)，如果是，则 接收并移动接收窗口，frame_expected + 1 发送方 收到应答帧，核对 响应帧号 next_frame_to_send, 如果无误，从网络层取新的帧，移动窗口， next_frame_to_send +1 信道利用率信道传输速率： b (bps) 每帧的大小：k (bits) 来回时间：R (sec) 则 信道利用率： k / (k + bR) 最大 窗口值 W = 2 * BD +1 (BD： 带宽-延迟积） 回退 N 帧回退 N 帧：缓存在发送窗口中的出错帧以及其后续帧全部重发。 (重传帧数多，适用于信道出错率较小的情况) 定义序列号 seq 的取值范围和滑动窗口长度 W 发送方连续 发送至发送窗口满 接受窗口为 1， 对出错帧不确认(引发 超时) 发送方超时重传，从未被确认帧开始 累计确认 n 号帧 的确认到达时，暗含一个 n-1,n-2…等 n 号帧之前的帧也被确认 当采用了累计确认，收到了 n 帧的确认，n 帧之前的帧都可以从缓存中删掉 滑动窗口长度 W 选择 Seq = 0 ~ MAX_SEQ 发送窗口：W = MAX_SEQ 接收窗口： W = 1 选择性重传选择性重传： 只重发出错帧 (重传帧数少，适用于信道质量不好的情况) 接收窗口 存储 差错帧 后继的所有正确帧 发送方 只重传 差错帧 接收方 接收 重传帧，按正确顺序 将 分组 提交 网络层 否定确认 NAK 加快出错帧的重传 对出错帧回送否定确认，使发方不再 等到超时再重传 滑动窗口长度 W 选择 Seq = 0 ~ MAX_SEQ 接收方窗口 W = (MAX_SEQ + 1)/ 2 发送窗口 小于 接收 窗口 介质访问控制层数据链路层被分成了两个子层 介质访问控制层 (MAC ,Madia Access Control) 逻辑链路控制层 (LLC ,Logical Link Control) 数据通信 3 中方式，单播、广播、组播 局域网中主要采用在共享信道上的广播 介质访问控制要解决：某一时刻由哪个工作站共享信道的问题， 通过多路访问协议（Mutiple Access Protocol）动态分配信道资源，提高信道利用率 多路访问协议 随机访问协议 站点争用信道，可能出现站点之间的冲突 ALOHA 协议 ​ 任何一个站点都可以在成帧后立即发送，可能有冲突，并通过信号反馈，检测信道，以确定发送是否成功。如果发送失败，则经过随机延时后再发送 冲突危险期：2t, 信道利用率 18.4% CSMA/CD 协议 ，带冲突检查载波侦听多路访问协议 先听后发，边发边听， 经侦听，如果介质空闲，开始发送； 如果忙，持续帧听，一旦空闲立即发送 如果发生冲突，等待一个随机分布的时间 在发送的同时也接受自己的信号，监测发送情况，一旦收到的信号与发出的不一致，说明有冲突 发送站 感知冲突后 立即停止发送，并且发送一个简短的阻塞信号，通知网上各站有冲突，都等待一段随机分布时间后，再按 CSMA/CD 方式重发该帧。 受控访问协议 站点被分配占用信道，无冲突 二层交互/二层设备可用网桥（Bridges）将很多 LAN 连接起来 网桥工作在 DLL 层，通过检查MAC 地址做出转发帧的决策。 它不检查网络层，所以，IPV4，IPV6 分组 均可穿越网桥 内部转发表？ 扩散算法，当网桥不知道目的地址时（不在表中），它会将这帧从除来的 LAN 外的所有 LAN 转发出去 逆向学习，网桥从 到达帧的源地址 认识 到 源地址 对应的那台机 是在帧来的那个 LAN 上，并把它写入 MAC 地址表 凡往表中加入记录，也必须同时打下时戳 到达帧的源地址在表中已有记录，将时间戳更新为当前时间 网桥 周期 性地 扫描表，将那些超时的记录从表中删除 NIC 网卡 和上层通信 提供一个独特的 MAC 地址标识符 封装过程的一部分，为传输比特流打包 为访问共享介质提供访问策略 创建信号和介质的接口， 内建转发器 交换机 LAN 交换机 是 多端口网桥 连接 LAN 网段 使用 MAC 表，决定帧 转发的端口 常被用来替换 集线器，以改善现有网络性能 支持 VLAN 虚拟局域网络 三种交互方式 存储转发 直通交换 无分片交互 网络层所做之事： 将源端 数据包 通过路由（路由选择），一路送到 接收方 IP 地址 IP 地址，标识收/发数据的机器。32 位二进制位标识，约 43 亿个 32 位 被 分成 4 个 8 位组 相邻 8 位组之间 用 .分割 每个 8 位组 转换成十进制，即 0 - 255 IP 地址分类，A,B,C,D,E 5 类 A 类 前 1 个字节 标识网络地址，后 3 个字节 标识 主机地址 第 1 个字节 十进制表示 取值范围 0-127， 二进制，0000 0000 - 0111 1111 网络总数 128 个，每个网络最多容纳 2^24 - 2 台 主机 B 类 前 2 个字节标识 网络地址，后 2 个字节 标识 主机地址 第 1 个字节用十进制表示 取值范围 128-191,二级制 1000 0000 - 1011 1111 网络总数 2^14 个， 每个网络最多容纳 2^16 - 2 台 主机 C 类 前 3 个字节 标识 网络地址，后 1 个 字节 标识 主机地址 第 1 个字节 用十进制 表示 的取值范围 192 - 223 , 二级制 1100 0000 - 1101 1111 网络数 2^21 个，每个网络最多容纳 256 (2^8 -2) 台主机 D 类 224.0.0.0 ~ 239.0.0.0 E 类 240.0.0.0 ~ 254.0.0.0 网络地址： 主机部分 全为 0 的 IP 地址 广播地址： 主机部分 全为 1 的 IP 地址 保留的 IP 地址 32 位全为 0 ，0.0.0.0， 当前主机 32 位 全为 1，255.255.255.255 广播地址 127.0.0.0, 环回地址 127.0.0.1, 本机地址 子网规划子网掩码 路由器使用子网掩码决定分组往哪个子网转发 路由器 采用 “AND”操作(目标 IP 和 子网掩码)，得到目的网络地址 广播地址： 主机部分全为 “1” 的 IP 地址 网络地址： 主机部分 全为 “0”的 IP 地址 某单位分到一个 C 类网络 193.71.56.0，要分成 5 个 子网，每个子网连接 20 台主机？ 需要向最后 一个 8 位组(主机位) 借 3 位， 2^3 = 8, 可创建 8 个子网 剩下 5 位 可用 IP 地址 2^5 = 30, 大于 20，满足每个子网 20 台主机 子网掩码： 1111 1111.1111 1111.1111 1111.1110 0000, 255.255.255.224, (或者 /27) 子网序号 网络地址/子网掩码 子网 网络地址 广播地址 可用地址范围 1 193.71.56.0/27 193.71.56.0/255.255.255.224 193.71.56.0 193.71.56.31(000 11111) 193.71.56.1~30 2 193.71.56.32 193.71.56.63(001 11111) 193.71.56.33~62 3 193.71.56.64 193.71.56.95(010 11111) 193.71.56.65~94 4 193.71.56.96 193.71.56.127(011 11111) 193.71.56.97~126 5 193.71.56.128 193.71.56.159(100 11111) 193.71.56.129~158 6 193.71.56.160 193.71.56.191(101 11111) 193.71.56.161~190 7 193.71.56.192 193.71.56.223(110 11111) 193.71.56.193~222 8 193.71.56.224 193.71.56.255(111 11111) 193.71.56.225~254 IP 寻址IP 寻址、MAC 寻址？ 路由器处理分组，决策依据：路由表？ 互联网和网络层 在网络层上，可以将整个互联网 看作 一组互联的子网络和自治系统 IP 协议将整个互联网粘合起来 IP 的任务就是提供一种尽力而为的方法，将数据报 从 源端 传送 到 目的端 路由器路由器处理 接到一个分组后 打开分组， 提前出目的 IP 地址 确定目标网络，查找路由表 重新封装，转发， TTL-1，置换 源和目的 的 MAC 地址，计算校验和、可选分片等 除了路由表，路由器内部还有一种ARP 表（所有子网设备的 IP-MAC 映射） 动态路由协议 距离矢量 路由选择协议(DV) 每个路由器 维护 两个 向量，Di (从该路由器到所有其他路由器的距离)和 Si(对应的下一跳) 在邻居路由之间 交换 路由信息 每个路由器 根据收到的信息，更新自己的路由表 简单，交换的信息太大，路由信息传播慢，收敛慢，不适合大型的网络 链路状态 路由选择协议(LS) 发现 其邻居节点们，了解它们的网络地址； 路由器启动时，发送一个特别的hello 分组，收到 hello 分组的路由器回发 一个应答，包含其全球唯一的名字 设置到 每个邻居的成本度量， 测量往返时间，多次测量，设置该线路的开销 构造一个分组 （周期性的构造、发送，或右特别事件发生，路由器 down），包含其 所了解的所有信息， 包括： 发送方标识 序列号， 随着新分组的产生而递增， 路由器会记录下 它 看到的所有 源路由器-序列号 对 年龄 邻居列表 到邻居的成本/量度 发送这个分组给所有其他的路由器 当一个新分组到达时，路由器根据它的记录 分组是新的，则泛洪，转发出去 重复分组，则 丢弃 如果分组的序列号 比对应 的源路由器发送到此 的序列号还小，则被当做过时信息被拒绝 计算 到每个路由器的最短路径 一旦 一个路由器 获得了全部的链路状态分组 ，就可以构造出全网络图 使用 最短路径算法 计算路由器之间的最短路径 计算的结果是一个树，形成相应的路由，安装在路由表中，引导数据分组的转发 NAT 网络地址翻译NAT netaddress translate： 私有 IP 地址和公有 IP 地址之间的转换。 内部网络使用私人地址，当内网需要同外网通信时，私人地址转换成合法的公有地址 NAT 转换器完成，其维护一个地址转换表 如果传输层不采用 TCP 或 UDP，采用其它的协议，NAT 将无法工作 **PAT port address translate： ** 将多个私有 IP 地址映射到 同一个公有 IP 地址 的不同端口 ICMP 互联网控制协议 IP 分组传送不可靠，丢包，拥塞，延迟、抖动 ICMP 用来向 源端 报告 问题或状况 ICMP 也常用来测试网络 ICMP 工具 ping 命令 将向目标站点发送一个 ICMP 回声请求 报文，如果站点接受到该报文，必须向源站点发回 一个 ICMP 回声应答报文，则认为目的站点 是可达的，否则不可达 tracert 命令 通过 ICMP 超时报文 来 得到 一张途径 的路由器列表 源主机向目的主机发送一个 IP 报文，并设置 TTL 为 1，到达第一个路由器时，TTL 减 1，为 0，则改路由器回发 一个 ICMP 数据报 超时报文，则源主机 取出路由器的 IP 地址 即为 途径的第一个路由端口地址，依此类推，发送第二个报文，设置 TTL 为 2，第三、第四个 IP 数据报，…… 直到 到达目的主机 ARP Address Resolution Protocol 地址解析找到给定 IP 地址所对应的 MAC 地址 ARP 更高效优化措施 缓存 ARP 结果 在 ARP 请求中包括 源机 的 IP-MAC 地址的映射 每台机器在启动时，广播它的 IP-MAC 地址对 免费 ARP当一台主机启动时，或接口的配置发生改变，会发送一个免费 ARP 缺省网关当源设备需要的目的地址与自己不在同一个网络时，如果源 不知道 目的的 MAC 地址，它必须使用路由器的服务 使它的数据达到目的。 缺省网关， 与 源设备所处的网段相连 的路由器接口 上 的 IP 地址 拥塞解决拥塞根源，负载 大于 资源 增加资源 在某些点之间使用更多的通道 增加 带宽 把流量分散 到 多条路径 启用空闲或备份的路由器 降低负载 拒绝 为某些 用户服务 给某些 用户的服务 降低 等级 让用户 更有预见性地 安排 其需求 抑制分组、逐条抑制 流量整形调节数据传输的平均速率，突发数据流 漏桶， 每个时钟，仅允许固定数量分组发送出去，不稳定的流 变成 稳定流 每个主机连接到网络的接口中 有一个 漏桶 当桶 中有分组时，输出速率是恒定的，当桶空时，输出速率 为 0 当桶满时，分组将别丢弃 令牌桶 当大量数据突发时，令牌桶算法 允许输出加快到某种程度 以每 T 秒 产生一个令牌的速度 往同中输入令牌 一个分组要发送的时候，必须要从桶中取出一个令牌 允许累积令牌，最多 n 个(令牌桶的容量) 其他，资源预留、准入控制、分组调度 传输层UDP 无连接的传输协议 UDP 数据段 ，8 字节 头部 + 数据 长度域表示的长度包括 头部 和数据 总共的长度 检验和 是可选的 端口范围 0 -65535 TCP 可靠的 端到端， 字节流 发：封装 TCP 实体接收到本地进程的用户数据流，将其分割成不超过 64KB 的分片 (实践中，通常分割成 1460 字节，以通过以太网传输，1500 - 40 ) 收：解封装 当包含 TCP 数据段的报文 到达 某台机器时，被提交给传输实体，将其重构出原始的字节流 TCP 连接 上 的每个 字节 都有 自己独有的 32 位 序列号 TCP 使用的基本协议， 具有动态窗口大小的滑动窗口协议 TCP 数据段头 源端口，目的端口， 用来跟踪 同一时间内通过网络的不同会话，每个端口 对应一个应用程序 序列号， 字节号，32 位，初始序列号，随机产生 确认号， 期望接收的字节号 32 位 TCP 段头长度，单位 32 位，4 字节 保留域/字段 当紧急指针使用时，URG被置为 1，表明有紧急数据，优先处理； 紧急指针是一个相对于 当前序列号的字节偏移量，标明紧急数据从哪里 开始 ACK 可设置为 1/0, 1 表示 确认号有效，0 无效 PUSH， 带有 PUSH 标志的数据，应该立刻 送到上层，不需要缓存它 REST， 用来重置一个已经混乱的连接 SYN，用在连接建立的过程 SYN=1，ACK=0， 连接请求 SYN=1，ACK=1， 连接接受 FIN， 用来释放连接，它表示 发送方 已经没有数据要传输了，但 可以继续接收数据 Window size， 告诉对方 可以发送的数据字节数，从确认字节号开始 TCP 三次握手三次握手建立连接是一个同步的过程，交换初始序列号，保证后续的每一个字节的可靠传输 第一次 ： 发方 连接请求， SYN=1，ACK=0， 初始序列号seq=x 第二次： 收方 回发 连接接受，SYN=1，ACK=1, 初始序列号seq=y, 确认号、期望接收的字节序列号 ack=x+1 第三次： 发方，最后确认，建立连接， SYN=0，ACK=1，序列号 seq=x+1, 确认号 ack=y+1 TCP 连接释放任何一方在没有数据要传送时，都可以发送一个FIN 置位的 TCP 数据段 TCP 传输策略 接收端 不请求对方发送短数据段 延迟 窗口变更信息，使接收缓冲区足够大 发送方 尽量不发送数据含量小的数据段 缓存应用层的数据，达到一定量再发送 TCP 拥塞控制拥塞检测（Congestion detection）， 所有 TCP 算法都假设超时是由拥塞引起的，并且通过监视超时情况来判断 拥塞控制（Congestion prevention），连接建立时，双方选择一个合适的窗口大小，接收方根据自己的缓冲区大小 来指定窗口的大小 拥塞窗口发送方 需要维护 2 个窗口，接收者窗口，拥塞窗口(反映目前网络的容量)，取两者中较小的窗口 慢启动算法， 决定拥塞窗口大小 连接建立时，发送者 用当前使用的最大数据段长度 初始化 拥塞窗口，发送一个最大的数据段 如果在 定时器超期之前收到确认， 将拥塞窗口翻倍，然后发送数据端，直到超时 如果发送 4096 字节没问题，但发送 8192 字节，超时，则拥塞窗口设置为 4096 个字节 阈值 除了使用接收者窗口，拥塞窗口，还使用第三个参数阈值，初始为 64k 当一个超时发生时，阈值降为当前拥塞窗口的一半，同时将拥塞窗口设置为一个最大数据段长度 使用慢启动算法来 决定 网络容量，拥塞窗口增长到阈值时 停止指数增长 从这个点开始，每次成功的传输 都会让 拥塞窗口 线性增长 应用层DNS 域名系统 域名 是大小写无关的 各组成部分的名字最多 63 个字符长，整个路径不超过 255 个字符 每个域名自己控制它 下面的子域的划分 资源记录 每个域，都可以有一组跟它相关联的资源记录 DNS 的主要功能是将 域名映射到资源记录上 资源记录 包括 5 部分 域名 Domain name, 此条记录适用于哪个域 生存期 Time to Live， 指示 该 记录的稳定程度 类别 Class， 对于互联网信息，总是 IN 类型 Type， 什么类型的记录 A ， ipv4 AAAA， ipv6 值 Value 域名解析将域名 映射 为 IP 地址的方法、过程 应用程序 调用 解析器（resolver）的库函数，把名字作为参数传给该函数(gethostbyname()) 解析器发送一个UDP 分组给本地 DNS 服务器，它会负责查找，并将对于 IP 地址返回给解析器 如果查询的域名落在 该域名服务器的管辖范围内，它将返回权威资源记录 （来自管理该记录的权威机构，总是正确的，和缓存的记录不同，后者可能过期） 如果本地没有该信息，那么本地域名服务器向 根域名服务器发送一条查询此域的消息 解析器返回结果给应用程序 优化方法，高速缓存，减少查询环节，提高效率","categories":[{"name":"烂笔头","slug":"烂笔头","permalink":"https://better-jiang.github.io/categories/%E7%83%82%E7%AC%94%E5%A4%B4/"}],"tags":[{"name":"网络","slug":"网络","permalink":"https://better-jiang.github.io/tags/%E7%BD%91%E7%BB%9C/"}]},{"title":"操作系统初识","slug":"操作系统初识","date":"2022-03-30T00:53:57.000Z","updated":"2023-02-03T12:14:22.423Z","comments":true,"path":"2022/03/30/操作系统初识/","link":"","permalink":"https://better-jiang.github.io/2022/03/30/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%88%9D%E8%AF%86/","excerpt":"","text":"OS 基本概念操作系统是控制软件 管理应用程序 为应用程序提供服务 分配资源 CPU (CPU 调度、进程、线程) 内存 (物理内存、虚拟内存) 磁盘 (文件系统) 管理外设 并发、并行 并发(concurrent)，在一段时间内多个程序交替运行 并行(parallel), 在一个时间点上有多个程序同时运行 启动、中断、异常、系统调用启动BIOS： Basic Input Output System， 一组固化到 ROM 上的程序，是计算机启动时加载的第一个程序 BIOS 启动固件 作用 基本输入输出程序 系统设置信息 开机后自检程序 系统自动程序(BIOS) 将加载程序从磁盘的引导扇区(512 字节)加载到 0x7c000,之后跳转到 0x7c00 加载程序(bootloader) 将操作系统代码、数据从硬盘加载到内存，并跳转到操作系统起始地址 中断、异常、系统调用 中断(hardware interrupt)， 来自硬件设备的处理请求； 异步响应 异常(exception)，非法指令或其他原因导致当前指令执行失败； 同步响应 系统调用(system call)， 应用程序主动向操作系统发出的服务请求； 异步或同步 中断（中断、异常、系统调用）处理机制 硬件处理，在 CPU 初始化时 设置 中断使能标志； 依据内部或外部事件设置中断标志 依据 中断向量表 调用相应中断服务例程 软件 现场保存 (编译器) 中断服务处理 (服务例程) 清除中断标记 (服务例程) 现场恢复 (编译器) 中断嵌套 硬件中断服务可被打断 不同硬件的中断源可能在硬件中断处理时出现 硬件中断服务例程中 需要 临时禁止中断请求 中断请求会保持到 CPU 做出响应 异常服务例程 可被 打断、嵌套 异常服务例程执行时 可能出现硬件中断 异常服务例程可能出现缺页 系统调用的实现 每个系统调用对应一个系统调用号， 系统调用接口根据系统调用号来维护表的索引 系统调用接口调用内核态中的系统调用功能实现，并返回系统调用的状态和结果 用户不需要知道系统调用的实现， 仅需设置调用参数和获取返回结果 函数调用、系统调用 差异 系统调用 INT和 IRET指令 发生 堆栈切换、特权级 转换 函数调用 CALL 和 RET 指令 没有 堆栈切换 中断、异常、系统调用的开销 引导机制 建立内核堆栈 验证参数 内核态映射到用户态的地址 内核态独立地址空间 内存管理(物理内存) - 连续分配内存的层次结构 CPU 内部 包含 ALU(算术逻辑单元)、MMU(内存管理单元)、寄存器、cache,其容量小， 访问速度快。 主存(物理内存)，存放操作系统和各应用，通过 交换/分页和 磁盘交互，将永久保存的数据放到磁盘中(虚拟内存) 操作系统的内存管理 抽象，逻辑地址空间 保护，独立地址空间 共享，访问相同内存 虚拟化，更大的地址空间 操作系统的内存管理方式目前多数操作系统采用 按需页使虚拟存储 重定位(relocation) 分段(segmentation) 分页(paging) 虚拟存储 (virtual memory) 地址空间 物理地址空间， 硬件支持的地址空间，起始地址 0， 到 MAX_sys 逻辑地址空间，在 CPU 运行的进程中看到的地址，起始地址 0， 到 MAX_prog ， 通过映射关系，落在物理空间上。 逻辑地址生成过程： C 程序通过编译、汇编、链接 link、载入（重定位）生产可执行文件，将逻辑地址映射到物理空间上。 C 程序中函数的位置(入口)，变量名就是逻辑地址， 编译后(.o 文件)起始地址为 0，把变量名和函数名转为相应的从 0 开始的连续逻辑地址 link 把多个.o 文件和成一个，存放在硬盘中，通过 loader 应用程序把可执行文件载入内存中执行，这里有分配地址空间和映射(偏移)的过程 物理地址生产过程： CPU 执行指令，ALU 需要逻辑地址的内存内容，发生请求、传递参数，参数就是逻辑地址 查表，根据 CPU 中 MMU，查表 将 逻辑地址 转换为 物理地址 找到后 CPU 给内存发请求，请求一个物理地址 内存会通过总线把内容传递给 CPU，CPU 执行指令 地址生成时机和限制 编译时 假设起始地址已知； 如果起始地址改变，必须重新编译 加载时 如果编译时起始位置未知，编译器需生成可重定位的代码； 加载时，生成绝对地址 执行时 执行时代码可移动 需要地址转换（映射）硬件支持 连续内存分配给进程分配一块不小于指定大小的连续的物理内存区域 内存碎片， 空闲内存不能被利用 外部碎片，分配单元之间的未被使用内存 内部碎片，分配单元之内的未被使用内存，取决于分配单元大小是否要取整 动态分区的分配策略 最先匹配(First Fit Allocation)，分配 n 个字节，使用第一个可用的空间比 n 大的空闲块 原理/实现 空闲分区列表按 地址顺序排序 分配过程时，搜索一个合适的分区 释放分区时，检查是否可与临近的空闲分区合并 优、缺点 简单、在高地址空间有大块的空闲分区 外部碎片，分配大块时较慢 最佳匹配(Best Fit Allocation), 分配 n 个字节，查找并使用不小于 n 的最小空闲分区 原理/实现 空闲分区列表按大小排序 分配时，查找合适分区 释放时，查找并合并临近的空闲分区 优缺点 大部分分配的尺寸较小时，效果很好； 可避免大的空闲分区被拆分；可减小外部碎片的大小 产生外部碎片，释放分区较慢，容易产生很多无用的小碎片 最差匹配(Worst Fit Allocation)， 分配 n 个字节，使用尺寸不小于 n 的最大空闲分区 原理/实现 空闲分区列表按由大到小排序 分配时，选最大的分区 释放时，检查是否可与临近的空闲分区合并，并调整空闲分区列表顺序 优缺点 中等大小的分配较多时，效果最好， 避免出现太多的小碎片 释放分区慢，产生外部碎片，容易破坏大的空闲分区，导致后续难以分配大的分区 碎片整理通过调整进程占用的分区位置来减少/避免分区碎片 碎片紧凑(compaction) 通过移动分配给进程的内存分区，以合并外部碎片 条件： 所有的应用程序可动态重定位 问题：， 何时移动？ 开销？ 分区对换(swapping in/out), 通过抢占并回收处于等待状态进程的分区，以增大可用内存空间 问题：换哪个程序？开销？ 内存管理(物理内存) - 非连续分配连续分配有缺点 分配给程序的物理内存必须连续 存在碎片(外部、内部) 内存分配的动态修改困难 内存利用率教低 非连续分配分配给一个程序的物理空间是非连续，提高内存利用效率和管理灵活性 优点 允许共享代码和数据 支持动态加载和动态链接 缺点 有额外的管理开销， 要建立虚拟地址和物理地址之间的转换 如何实现虚拟地址和物理地址的转换？ 软件实现(灵活、开销大) 硬件实现(够用，开销小) 段式存储管理段的概念 表示访问方式和存储数据等属性相同的一段地址空间 其对应一个连续的内存块 若干个段组成进程逻辑地址空间 段访问 段基址 + 段内偏移 逻辑地址由二元组(s, addr)表示， s 段号， addr，段内偏移 页式存储管理页帧（帧、物理页面 Frame） 将物理地址空间划分为大小相同的基本分配空间单位 2 的 n 次方，如 512，4096 内存物理地址的表示，二元组(f,o) = f * 2^S + o f, 帧号，F 位，共有 2^F 个 帧 o，帧内偏移，S 位， 每帧有 2^S 字节 页面（页、逻辑页面 Page） 将逻辑地址空间也划分为相同大小的基本分配单位 帧、页 大小必须是相同的 进程中的逻辑地址的表示，二元组(p,o) = p*2^S + o p ,页号 (P 位， 2^P 个页) o, 页内偏移(S 位， 每页有 2^S 字节) 页到帧的转换 （地址映射） 逻辑地址到物理地址的转换 页表， 保存了逻辑地址到物理地址之间的映射关系 MMU、TLB 逻辑地址中的页号 是连续的，物理地址中的帧号是不连续的 不是所有的页都有对应的帧，缺页 具体过程： 首先 CPU 得到逻辑地址，逻辑地址分块，一块表示页号，一块表示页内偏移。通过查找页表，页表的索引就是页号，内容是帧号。帧号+偏移，就是物理地址，找到对应的内存空间 页表 每个进程都有一个页表 每个页表对应一个页表项 页表项标志 存在位 (resident bit) 修改位 (dirty bit) 引用位 (clock/reference bit) 其随进程运行状态而动态变化 页表基址寄存器(PTBR， Page Table Base Register) 页式存储管理机制的性能问题 内存访问性能， 访问一个内存单元需要 2 次内存访问 第一次，获取页表项 第二次，访问数据 页表 大 小 ，可能非常大 如何 处理？ 缓存、间接访问 快表(TLB，Translation Look-aside Buffer)快表是一种高速缓冲存储器，用缓冲近期访问的页表项 过程 根据逻辑地址推算出目标页表项的索引，查询快表 若命中，则结合逻辑地址的低若干位推算出最终物理地址 若没有命中，则去查页表并更新对应的页表项到 TLB 中 当 TBL 被写满又有新的页表项要写进来，则按照策略擦除快表中的一个旧页表项 间接访问，多级页表通过间接引用将页号分成 k 级，使等将对一个大地址范围的寻址分为对几个小的页表的寻址 优点：可离散存储，进程中未使用的页暂存时可以不用为其建立页表，只有在进程实际需要一个页表时才给该页表分配内存 大地址空间问题？逻辑地址空间增长速度快于物理地址空间 思路， 不让页表与逻辑地址空间的大小相对应，让页表与物理地址空间的大小相对于 页寄存器(Page Registers) 每个帧 与 一个 页寄存器 管理，寄存器内容包括: 使用位， 此帧是否 被 进程占用 占用页号，对应的页号 p 保护位 示例 物理内存大小： 4096 _ 4096 = 4K_ 4K = 16 MB 页面大小： 4096 bytes = 4KB 页帧数： 4096 页寄存器使用的空间(假设每个页寄存器占 8 字节)： 8 * 4096 = 32KB 则页寄存器带来的开销： 32K/16M = 0.2% 虚拟内存的大小： 任意 优点， 本身物理存址小，节省空间，不再是每个进程都要页表，整个系统只用 一个 缺点， 需求高，需要软硬件配合，有冲突 反置页面 基于 HASH 映射值查找对应页表项中的帧号 段页式存储管理在端式存储的基础上，给每个段 加 一级页表 逻辑地址： 段号 + 若各个页号 + 页内偏移 物理地址：帧号 + 页内偏移 内存共享，通过指向相同的页表基址，实现进程间的端共享 虚拟存储覆盖技术在较小的可用内存中运行较大的程序 依据程序逻辑结构，将程序划分为若干功能相对独立的模块 将不会同时执行的模块共享同一块内存区域 必要、常用功能的代码和数据 常驻内存 可选，不常用功能，只在需要时装入 内存 不存在调用关系的模块 可相互 覆盖，共用同一块内存区域 交互技术增加正在运行或需要运行的程序的内存 将暂时不用运行的程序放到外存 换入换成的基本单位，整个进程的地址空间 局部性原理程序在执行过程的一个较短时期，所执行的指令的地址，指令的操作数地址都局限于一定区域； 存在时间、空间、分支局限性； 局部性原理的意义：该原理表明 理论上虚拟存储技术是可以实现的 虚拟存储技术物理内存+ 磁盘 = 虚拟存储 只把部分程序放到内存中，从而运行比物理内存大的程序，有操作系统自动完成 实现进程在内存和外外存直接的交换，从而获得更多的空闲内存空间 原理： 在装入程序时，只把当前指令执行需要的部分页、段装入内存 当执行到指令或数据不存在时(缺页、缺段异常)，处理器通知操作系统将相应的页、段调入内存 操作系统将内存中暂时不用的页、端保存到外存 实现方式： 虚拟页式存储 虚拟段式存储 基本特征： 不连续性 物理内存 分配 非连续 虚拟地址空间 使用 非连续 大用户空间， 提供给用户的虚拟内存 可 大于 时间的物理内存 部分交换，只对部分虚拟地址空间进行 调入 和 调出 技术支持： 硬件，页式或短时存储中 地址转换机制 操作系统，管理内存和外存 间 页、端的换入、换出 虚拟页式存储管理在页式存储管理的基础上，增加 请求调页 、页面置换 思路 当用户程序要装载到内存运行时，只装入部分页面，就启动程序运行 进程在运行中发现有需要的代码或数据不在内存时，想系统发出缺页异常请求 操作系统在处理缺页异常时，将外存中相应的页面调入内存，使得进程能继续运行 虚拟页式存储中 页表项 结构 驻留位： 表示该页面是否在内存； 1 在 内存，0 在外存，访问时缺页异常 修改位： 表示在内存中的该页是否被修改过； 回收物理页面时据此决定是否把内容写会外存 访问位：表示该页面是否被访问过(读、写)，被访问过设置为 1 保护位：表示该页面的允许访问方式，只读、可读写、可执行等 缺页异常的处理流程 1、如果在内存中有空闲的物理空间，则分配一个物理页帧 f，然后转至 5，否则 2 2、采用某种页面置换算法，选择一个被替换的物理页帧，其对应的逻辑页为 q，（如果没修改过可直接释放，如果修改位是 1，则要写会外存） 3、如果 q 被修改过，则把它写回外存 4、把 q 对应页面驻留位设置为 0 5、把需要访问的页面 p 装入物理页面 f 中 6、修改 p 对应页表项，驻留位设置 1，物理页帧设置为 f 7、重新执行产生缺页的指令 页面置换算法当出现缺页异常，需要调入新的页面而内存已满时，置换算法选择被置换的物理页面 目标： 尽可能减少页面的调入调出次数 把未来不再访问或短期内不访问的页面调出 页面锁定（frame locking） 描述 必须 常驻内存的逻辑页面 操作系统的关键部分 要求响应速度的代码和数据 页表中的锁定标志位 局部页面置换算法置换页面的选择范围 仅限于 当前进程占用的物理页面内 最优页面置换算法(OPT) 思路：未来最长时间不访问的页面 作为置换页面 实现： 缺页时，计算内存中每个逻辑页面的下一次访问时间，选择未来最长时间不访问的页面 特征： 理想情况，OS 无法实现 先进先出算法(FIFO) 思路： 选择在内存驻留时间最长的页面进行置换 实现： 维护一个记录所有位于内存中的逻辑页面，链表元素按驻留内存的时间排序，链首最长，链尾最短；出现缺页时，置换链首页面，新页面添加值链尾 特征： 性能差，调出的页面可能是常用页面； 出现 Belady 现象 最近最久未使用算法(LRU) 思路： 选择最长时间没被引用的页面进行置换；如果某些页面长时间未被访问，则它在将来还可能长时间不会访问 实现： 维护一个按最近一次访问时间排序的链表，链首是最近刚刚访问的页面，链尾是最久为使用的页面 访问内存时，找到相应页面，并把它移到链首 缺页时，置换链表尾节点的页面 特征： 最优置换算法的一种 近似， 开销比较大 时钟页面置换算法(Clock) 思路： 仅对页面的访问情况进行大致统计； 在页表项增加 访问位，描述页面在过去一段时间的内存访问情况 实现： 各页面组成环形链表，指针指向最先调入的页面 访问页面时，在页表项纪录页面访问情况， 访问位 1 (初始时 0) 缺页时，从指针处开始顺序查找 未被访问的页面进行置换 从指针当前位置顺序检查环形链表 访问位 为 0 ， 则置换该页面 访问位 为 1，则 置为 0，指针移动到下一个页面，直到找到可置换的页面 ∫ 特征： 是 LRU 和 FIFO 的折中 最不常用算法(LFU) 思路：选择页面访问次数最少的页面 实现： 对每个页面设置访问计数器，当一个页面被访问+1,置换数值最小的页面 特征： 开销，硬盘计数器开销，排序查找开销 Belady 现象采用 FIFO 算法时，可能出现分配的物理页面增加，缺页次数反而升高的异常现象 LRU、FIFO、CLock 算法比较 LRU 和 FIFO 本质上都是先进先出的思路 LRU 依据 页面的 最近访问时间排序， 需要动态的调整顺序 FIFO 依据 页面 进入 内存的时间排序，是固定不变的 LRU 可 退化 成 FIFO， 页面进入内存后没被访问，最近访问时间 与 进入内存的时间 相同 LRU 算法性能较好，但系统开销大 FIFO 系统开销较小，但会发生 Belady 现象 Clock 是它们的折中 页面访问时，不动态调整页面的在链表中的顺序，仅做标记 缺页时，再把它移动到链表末尾 对应 未被访问的页面，Clock 和 LRU 算法表现的一样好 对于被 访问过的页面，Clock 算法 不能记录 准确访问顺序，而 LRU 算法可以 全局页面置换算法置换页面的选择范围 是 所有可换出的 物理页面 进程在不同阶段的内存需求是变化的，分配给进程的内存也需要在不同阶段有所变化 工作集算法 思路： 换出不在工作集中的页面 实现： 访问链表，维护窗口内的访存页面链表 在防存时，换出不在工作集的页面，缺页时，换入页面，更新访存链表 工作集一个进程当前使用的逻辑页面集合，用二元函数 w(t,Δ)，t 是当前时刻，Δ 是工作集窗口，一个定长的页面访问的时间窗口。t+Δ 构成一个时间段，w(t,Δ)就是在当前时刻 t 之前的 Δ 时间内所有访问页面组成的集合，在随 t 不断更新。 在进程开始后，随着访问新页面逐步建立起较稳定的工作集 常驻集在当前时刻，进程实际驻留在内存当中的页面集合 缺页率算法 缺页率： 缺页次数/内存访问次数= 1/缺页的平均时间间隔 思路： 动态调整常驻集的大小； 若缺页率高则增加工作集来分配更多的物理页面，过低则减少工作集来减少其物理页面。 抖动和负载控制抖动：如果分配给一个进程的物理页面太少，常驻集远小于工作集，则缺页率很大，频繁在内外存之间替换页面，使进程的运行慢，此状态为”抖动” 产生抖动原因： 随着驻留内存的进程数目增加，分配给每个进程的物理页面数据不断减少，缺页率上升。因此 OS 要选择一个适当的进程数目和进程需要的帧数，在并发和缺页率之间达到平衡。 负载控制： 通过调节并发进程数来进行系统负载控制。平均缺页间隔时间 = 缺页异常处理时间 进程进程定义一个具有一定独立功能的程序在一个数据集合上的一次动态执行过程 只有当一个程序被 OS 加载到内存中，cpu 对其执行时，这个过程是动态的，称为进程 进程的组成进程包含了正在运行的一个程序的所有状态信息 代码 数据 状态寄存器 通用寄存器 进程占用系统资源 进程特点 动态性，动态的创建、结束进程 并发性，可并独立调用并占用处理机运行 独立性，不同进程的工作相互独立 制约性，因访问共享数据、资源，或进程间同步 而产生制约 进程与程序的联系 进程是操作系统处于执行状态程序的抽象 进程 = 执行中的程序 = 程序(静态文件) + 执行状态 同一个程序的多次执行过程对应不同进程 进程执行需要资源，内存（保存代码、数据），CPU(执行指令) 进程控制块 (PCB，Process Control Block) 操作系统管理控制进程运行所用的信息集合 操作系统用 PCB 来描述 进程的基本情况 以及 运行变化的过程 PCB 是 进程存在的唯一标志 PCB 三大类信息 进程标识，本进程标识、父进程标识、用户标识 处理机状态保存，保存进程的现场信息，主要是寄存器 进程控制信息 调度和状态信息，调度进程、处理机使用情况 进程间通信信息，通信相关的各种标识、信号 存储管理信息，指向本进程映像存储空间的数据结构，内存信息 进程所用资源， 打开使用的系统资源 有关数据结构连接信息，与PCB 相关的进程队列 PCB 组织方式 链表，同一状态的进程其 PCB 成一链表，多个状态对应多个不同的链表；如 就绪链表、阻塞链表 索引表，同一状态的进程归入一个索引表(由索引执行 PCB)，多个状态对应多个不同的索引表 进程生命周期 创建 引起进程创建情况 系统初始化 用户请求创建一个新进程 正在运行的进程执行了创建进程的系统调用 执行 内核选择一个就绪的进程，让它占用处理机并执行 等待 进入等待的情况 请求并等待系统服务，无法马上完成 启动某种操作，无法马上完成 需要的数据没有到达 抢占 进程抢占的情况 高优先级进程就绪 进程执行当前时间用完 唤醒 唤醒进程情况 被阻塞进程需要的资源被满足 被阻塞进程等待的事件到达 进程只能被别的进程或操作系统唤醒 结束 进程结束情况 正常退出 错误退出 致命错误 被其他进程杀死 进程挂起处于挂起状态的进程映像在磁盘上，以减少进程占用的内存 挂起状态 等待挂起状态(Blocked-suspend)，进程在外存 并等待某事件的出现 就绪挂起状态(Ready-suspendReady-suspend)，进程在外存，但只要进入内存即可运行 挂起状态转换 从内存转到外存 等待 -&gt; 等待挂起， 没有进程处于就绪状态，或就绪进程 要求更多内存资源 就绪 -&gt; 就绪挂起，当有高优先级等待进程（系统认为会很快就绪的）和低优先级就绪进程 运行 -&gt; 就绪挂起，对抢占式分时系统，当有高优先级等待挂起进程因事件出现而进入就绪挂起 在外存时的状态转换 等待挂起 -&gt; 就绪挂起， 有等待挂起进程 因相关事件出现 激活， 外存到内存，需要运行该进程时 就绪挂起 -&gt; 就绪，没有就绪进程，或 挂起就绪进程高于 就绪进程 等待挂起 -&gt; 等待， 当一个进程释放足够内存，并有高优先级等待挂起进程 状态队列由操作系统维护一组队列，表示系统中所有进程的当前状态 不同队列表示不同状态 线程线程概念线程是进程的一部分，描述指令流 执行状态。它是进程中的指令执行流 的最小单元，是CPU 调度的基本单位 线程 = 进程 - 共享资源 线程优缺点 一个进程中可同时存在多个线程 各个线程之间可以并发执行 各个线程之间可共享地址空间和文件等资源 一个线程崩溃，会导致其所属进程的所有线程崩溃 线程、进程 比较 进程是资源分配单位，线程是 CPU 调度单位 进程拥有一个完整的资源平台，线程只独享指令流执行的必要资源，如寄存器、栈 线程能减少并发执行的时间（切换时间短，能直接通信）和空间开销(共享内存和文件资源) 进程控制进程切换(上下文切换)切换时机 暂停当前运行状态，从运行状态变成其他状态 调度另一个进程，从就绪状态变成运行状态 进程切换要求 切换前，保存进程上下文 切换后，恢复进程上下文 要快速切换 保存进程生命周期信息(寄存器、CPU 状态、内存地址空间) 进程控制块 PCB 内核为每个进程维护了对应的进程控制块(PCB) 相同状态的进程的 PCB 放置在同一队列 进程创建 (fork/exec) fork() 复制一个进程，复制父进程信息，创建一个新的子进程。 复制父进程所有变量和内存 复制父进程的所有 CPU 寄存器 子进程的 fork()返回 0 父进程的 fork()返回进程标识符 子进程使用 getpid()获取 PID exec() 加载 新程序取代当前运行进程 进程等待和退出 wait() 用于 父进程等待子进程的结束 子进程 结束 时通过 exit()向父进程返回一个值，父进程通过 wait()接受并处理这个值 有子进程存活时，父进程进入等待状态，等待子进程的返回结果；当子进程调用 exit()时，唤醒父进程，将 exit()返回值作为父进程中的 wait()调用的返回值() 有僵尸子进程等待时，wait()立即返回其中一个值 无子进程存活时，wait()立即返回 exit(),进程的有序终止 将调用才是作为 进程的”结果” 关闭所有打开的文件等占用资源 释放内存 释放大部分 进程相关的内核数据结构 检查父进程是非存活 存活，保留结果的值 直到 父进程需要它，进入僵尸（zombie）状态 没有，释放所有的数据结构，进程结束 清理所有等待的僵尸进程 处理机调度 进程切换，切换 CPU 的当前任务，从一个进程/线程到另一个，保存当前在 PCB/TCB 中的执行上下文，读取下一个的上下文 CPU 调度，从就绪队列中挑选一个进程/线程作为 CPU 将要运行的下一个进程/线程 调度准则 CPU 使用率： CPU 处于忙状态的时间百分比 吞吐量：单位时间内完成的进程数量 周转时间：进程从初始化到结束的总时间 等待时间：进程在就绪队列中的总时间 响应时间：从提交请求到产生响应所花费的总时间 调度算法 先来先服务（FCFS，First Come，First Served)，依据进程进入就绪状态的先后顺序 优点，简单 缺点 平均等待时间波动大，短进程可能排在长进程后面 I/O 资源和 CPU 资源利用率低，CPU 密集型进程导致 I/O 设备闲置，反之亦然 短进程优先，选择就绪队列中执行时间最短进程 占用 CPU 进入运行状态 SPN，Shortest Process Next (短进程)， SJF，Shortest Job First (短作业) SRT，Shortest Remaining Time (短剩余时间) 优点： 具有最优平均周转时间 缺点： 可能导致饥饿，连续的短进程会使长进程无法获得 CPU 资源 需要预知未来，预估 CPU 使用的时间 最高响应比优先 (HRRN，Highest Response Ratio Next) R = (等待时间 + 执行时间) / 执行时间 在短进程优先算法的基础上改进，不可抢占，关注进程的等待时间，可防止长进程无限期推迟 时间片轮转 (RR， Round Robin) 时间片，分配处理机资源的基本时间单元 开销，额外的上下文切换； 时间片太长，等待时间过长，极限情况下，退化成 FCFS 时间片太小，反应迅速，但产生大量上下文切换，增加开销 多级队列(MQ，Multilevel Queues) 就绪队列分为 多个相对独立的队列，调度在队列间进行，每个队列拥有自己的调度策略。如 前台交互，使用 RR，保证响应速率；后台/批处理，使用 FCFS 队列间调度 固定优先级，先前台，再处理后台，可能导致饥饿 时间片轮转，每个队列都等到一个确定的，能够调度其进程的 CPU 总时间。如 80%CPU 时间用于前台，后台 20% 多级反馈队列 (MFQ， Multilevel Feedback Queues) 优先级队列中的时间片轮转有动态调整 一个进程可以在不同队列中移动，N 级优先队列 每个队列内部 使用 RR 轮换 时间片大小随优先级增加而增加，若进程在当前时间片没有完成，则降到下一个优先级 I/O 幂集型进程 停留 在 高优先级 公平共享 (FSS，Fair Share Scheduling) 同步互斥 原子操作(Atomic Operation)， 一次不存在任何中断或失败的操作，要么成功，要么操作没执行 利用 2 个原子操作实现一个锁 Lock.Acquire 在锁别释放前一直等到，然后获得锁 如果 2 给线程都在等待同一个锁，并且同时发现锁被释放了，那么只有一个能够获得锁 Lock.release 进程间交互关系 互斥(mutual exclusion)， 一个进程占用资源，其它进程不能使用 死锁 (deadlock)，多个进程各占用部分资源，形成循环等待 饥饿 (starvation)， 一个进程一直得不到资源，而其它进程可能轮流占用资源 临界区 (Critical Section)1234entry section // 进入区 cirtical section // 临界区exit section // 退出区 remainder section 临界区，进程中 访问临界资源的一段 需要 互斥执行的代码 进入区，检查可否进入临界区的一段代码，如果可，则设置”正在访问临界区”标志 退出区，清除”正在访问临界区”标志 临界区访问规则 空闲则入，没有进程在临界区，任何进程可进入 忙则等待，有进程在临界区，其他进程不能进入 有限等待，等待进入临界区的进程 不能无限期等待 让权等待，不能进入临界区的进程，应释放 CPU 锁 (抽象的数据结构) 一个二进制变量 Lock::Acquire(), 锁被释放前一直等待，然后得到锁 Lock::Release()， 锁释放后，唤醒任何等待进程 信号量与管程 信号量(Semaphore)信号量，是操作系统提供的一种协调共享资源的方法 信号是一种抽象数据结构，由一个整形变量和两个原子操作组成 P(), sem—, 如果 sem&lt;0,等待，类似 Lock::Acquire() V(),sem++, 如果 sem&lt;=0,说明当前有等着的进程，唤醒在信号量上的进程，一个或多个 信号量分类 二级制信号量，约等于锁，取值 0，1 资源信号量，资源数目为任何 非负值 用信号量解决生产-消费问题生产者 —&gt; 缓冲区 —&gt; 消费者 一个或多个生产者 在生产数据后 放在 一个缓存区 中 单个消费者从缓冲区 取出数据 任何时刻只能有一个生产者 或消费者 可访问缓冲区 (互斥访问) 缓存区空时，消费者必须等待生产者 (条件同步) 缓冲区满时，生产者必须等待消费者 (条件同步) 管程 管程，是一种用于多线程互斥访问 共享资源的程序结构。其组成： 一个锁，控制管程代码的互斥访问 0 或多个条件变量，管理共享数据的并发访问 条件变量 进入管程的线程因资源被占用而进入等待状态 每个条件变量表示一种等待原因，对应一个等待队列 Wait() 将自己阻塞在等待队列 唤醒一个等待者或释放管程的互斥访问 Signal() 将等待队列中的一个线程唤醒 如果等等待队列为空，则等同于 空操作 死锁、进程通信死锁，一组阻塞的进程，持有一种资源，等待获取另一个进程所占用的资源，而导致谁都无法执行。 死锁必要条件 互斥 持有并等待 无抢占，一个资源只能被进程自愿释放 循环等待，形成闭环 死锁处理方法 死锁预防(Deadlock Prevention)， 确保系统永远不会进入死锁状态 限制申请方式，任何时刻都不满足死锁的必要条件 互斥 - 把互斥的共享资源 封装 成可同时访问 只有并等待， 进程请求资源时，要求它不持有任何其它资源；允许进程在开始执行时，一次请求所有需要的资源 非抢占，进程请求不能立即分配的资源，则释放已占用资源；只在能够同时获得所有需要资源时，才执行分配操作 循环等待， 对资源排序，要求进程按顺序请求资源 死锁避免 (Deadlock Avoidance)，在使用前进行判断，只允许不会出现死锁的进程 请求资源 利用额外的先验信息，在分配资源时判断是否会出现死锁，只在不会死锁时分配资源 要求进程声明需要资源的最大数目 限定提供、分配的资源数量，确保满足进程的最大需求 动态检查 资源分配状态，确保不会出现环形等待 死锁检测和恢复(Deadlock Detection &amp; Recovery)，在检查到死锁后，进行恢复 允许系统进入死锁 维护系统的资源分配图 定期调用死锁检测算法 搜索 图中是否存在死锁 出现死锁时，用死锁恢复机制 进行恢复 安全状态 系统处于安全状态，一定没有死锁 系统处于不安全状态，可能出现死锁 银行家算法银行家算法是一个避免死锁产生的算法，它以银行借贷分配策略为基础，判断并保证系统处于安全状态 客户在第一次申请贷款时，声明所需最大资源量，在满足所有贷款要求并完成项目时，及时归还 客户贷款数量不超过银行拥有的最大值时，银行家尽量满足客户需要 类比 银行家 - 操作系统 资金 - 资源 客户 - 申请资源的线程 进程通信(IPC， Inter-Process Communication) 直接通信，一条链路对应一对通信进程，没对进程间只能有一个链路存在 间接通信 通过操作系统维护的消息队列实现进程间的消息 每个消息队列都有一个唯一的标识 只有共享了相同消息队列的进程，才能够通信 共享内存 共享内存是把同一个物理内存区域同时映射到多个进程的内存地址空间的通信机制 进程，每个进程都 文件系统文件系统是操作系统中管理持久性数据的子系统，提供数据存储和访问功能 文件是具有符号名，由字节序列构成的数据项集合。 它是文件系统的基本数据单元。文件名是文件的标识符号 文件系统的功能 分配文件磁盘空间，管理文件块(位置或顺序)，管理空闲空间，分配算法 管理文件集合，定位(文件及其内容)，命名，文件系统结构 数据可靠和安全， 安全(多层次保护数据)，可靠 文件头： 文件系统元数据中的文件信息(文件属性、文件存储位置、顺序) 文件描述符 内核跟踪进程 打开的所有文件，操作系统为每个进程维护一个打开文件表；文件描述符就是打开文件的标识 文件描述符： 操作系统在打开文件表中维护的打开文件状态和信息 文件指针： 最近一次读写位置； 每个进程分别维护自己的打开文件指针 文件打开计数： 当前打开文件的次数， 当最后一个进程关闭文件时，将其从打开文件表中移除 文件的磁盘位置：缓存数据访问信息 访问权限： 每个程序访问模式信息 文件的 用户视图 和 系统视图用户视图， 持久的数据结构 系统视图， 数据块的集合(块时逻辑存储单元，扇区是物理存储单元) 用户视图 到 系统视图数据块 是 文件系统中基本操作单位，即使每次只访问 1 字节的数据，也需要缓存目标数据的一个数据块(4096 字节 4KB) 进程度文件 获取字节 所在的数据块 返回数据块内对应部分 进程写文件 获取数据块 修改数据块中对应部分 写回数据块 访问模式 顺序访问， 按字节一次读取 随机访问，随机读取 索引访问，依据数据特征索引 分层文件系统文件是以目录的方式组织起来 目录： 是一类特殊的文件， 其内容是文件索引表&lt;文件名，指向文件的指针&gt; 文件别名， 2 个多多个文件名 关联 同给一个文件 硬链接， 多个文件项 指向 一个文件，删除时，可能有个隐形计数器，删除一次减一，直到为 0 时才真正删除 软链接，以快捷方式指向其他文件 (通过存储 真实文件 的逻辑名称 来实现)。 删除时，这个别名成为一个空指针 名字解析(路径遍历)把逻辑名字转换成物理资源，递归先读文件头，在读数据块，搜索子项 依次遍历路径名，在文件系统中找到实际文件位置 遍历文件目录 直到 直到目标文件 例如： 解析 /bin/ls 读取根目录的文件头(在磁盘固定位置) 读取根目录的数据块 ，搜索 “bin” 项 读取 bin 的文件头 读取 bin 的数据块 ，搜索 “ls” 项 读取 ls 的文件头 文件系统挂载一个文件系统需要先挂载才能被访问，挂载点 在用户 看来 相当于 目录。 将额外的文件系统 与 根文件系统的某个 现存的目录建立关联关系，进而使得该目录作为其他文件访问入口 虚拟文件系统(VFS，Virtual File System)对不同文件系统的抽象，提供相同的文件和文件系统接口，管理所有文件和文件系统关联的数据结构 文件系统的基本数据结构 文件卷控制块 每个文件系统一个 文件系统详细信息 块、块大小、空余块、计数/指针等 文件控制块 每个文件一个 文件详细信息 访问权限、拥有者、大小、数据块位置等 目录项 每个目录项一个 将目录项 数据结构及树型布局 编码成 树型数据结构 指向文件控制块、父目录、子目录等 文件系统的存储结构 持久存储在外存 当需要时加载进内存 卷 控制块，当文件系统挂载时进入内存 文件 控制块，当文件被访问是进入内存 目录节点，在遍历一个文件路径时进入 内存 文件系统打开文件的数据结构 文件描述符 每个被打开的文件都有一个文件描述符 文件状态信息 (目录项、当前文件指针、文件操作设置…) 打开文件表 每个进程一个进程打开文件表 有一个系统级的打开文件表 有文件被打开时，文件卷就不能被卸载 文件分配如何表示分配给一个文件数据块的位置和顺序 分配方式 连续分配 文件头指定起始块和长度 最先匹配，最佳匹配 优点，文件读取表现好，高效的顺序和随机访问 缺点，碎片，文件增长问题(预分配、按需分配) 链式分配 文件以数据块链表方式存储，文件头 包含 了 第一块 和 最后一块 的指针 优点，创建、增大、缩小容易；没有碎片 缺点，无法实现随机访问；可靠性差(破坏一个链，后面的数据块就丢了) 索引分配 为每个文件创建一个索引数据块，指向文件数据块的指针列表；文件头 包含了索引数据块 指针 优点，创建、增大、缩小容易；没有碎片，支持直接访问 缺点，文件很小时，存储索引开销大；大文件索引难处理 UFS 多级索引分配 文件头包含 13 个指针 前 10 个指针指向数据块 第 11 个指针 指向 索引块 第 12 给指针指向二级索引块 第 13 个指针指向三级索引块 空闲空间管理用位图代表空闲数据块列表 使用简单但是可能会是一个很大的向量表， 160G 磁盘 -&gt; 40M 数据块 -&gt; 5MB 位图 假设空闲空间在磁盘中均匀分布，则找到 “0”之前要扫描 n(数据块总数)/r(空闲块总数) 磁盘分区、文件卷通常磁盘通过分区来最大限制 减少寻道时间 分区 是 一组柱面的集合 每个分区 都可视为 逻辑上独立的磁盘 文件卷： 已个拥有完整文件系统实例的外存空间，通常常驻在磁盘的单个分区上 多磁盘管理使用多磁盘可改善 吞吐量（通过并行），可靠性和可用性 （通过冗余） RAID 冗余磁盘队列（RedundantArray of Inexpensive Disks） RAID-0，磁盘条带化 把数据块分成多个子块，存储在独立的磁盘中；通过独立磁盘上并行数据块访问 提供更大的磁盘带宽 RAID-1，磁盘镜像 向 2 个磁盘写入，从任何一个读取；可靠性成倍增长，读取性线性增加 RAID-4，带校验的磁盘条带化 数据块级 的磁盘条带化 + 专用奇偶校验磁盘； 能从任意一个故障磁盘中恢复 RAID-5，带分布式校验的磁盘条带化 I/O 子系统常见设备接口类型 字符设备，键盘、鼠标、串口等，以字节单位顺序访问，get(),put() 块设备，磁盘驱动器、光驱等，均匀的数据块访问，原始 IO 或文件系统接口，内存映射文件系统接口 网络设备，以太网、无线、蓝牙等，格式化报文交换，send/receive 网络报文，网络接口 同步、异步 I/O 阻塞 I/O，”wait” 读数据时，进程 将进入 等待状态，直到完成数据读取 写数据时，进程 将进入 等待状态，直到设备完成数据写入处理 非阻塞 I/O， “Don’t Wait” 立即从 read/write 系统调用返回，返回值 为成功传输字节数，可能为 0 异步 I/O， “Tell Me Later” 读数据时，使用指针标记好用户缓冲区，立即返回；稍后内核将填充缓冲区并通知用户 写数据时，使用指针标记好用户缓冲区，立即返回；稍后内核 将 处理数据并通知用户 I/O 结构CPU 北桥连 高速设备， 南桥 连 IO 设备 CPU 与设备的连接 设备控制器： CPU 与 IO 间的接口，向 CPU 提供特殊指令和寄存器 IO 地址： CPU 用来控制 IO 硬件，内存地址或端口号 CPU 与设备的通信方式： 轮询 、设备中断、DMA（直接内存访问） IO 指令、内存映射 IO IO 指令，通过 IO 端口号访问 设备寄存器，特殊 CPU 指令 内存映射 IO，设备寄存器/存储 被映射到 内存物理地址空间中 通过 内存 load/store 指令 完成 IO 操作 MMU 设置映射，硬件跳线或程序启动是设置地址 I/O 请求声明周期 CPU 与 设备控制器 的数据传输 **程序控制 IO(PIO)**， 通过 CPU 的 load/store 传输所有数据 硬件简单、编程容易，消耗的 CPU 时间和数据量成正比 适用于简单的、小型的设备 I/O 直接内存访问（DMA）， 设备控制器可 直接 访问 系统总线，控制器直接与内存互相传输数据 设备传输数据不影响 CPU，需要 CPU 参与设置 适用高吞吐量 I/O 通过直接 I/O 寻址 读取 磁盘数据 I/O 设备通知操作系统的机制 操作系统需要了解设备状态 I/O 操作完成时间 I/O 操作遇到的错误 通知方式 CPU 主动轮询 ：IO 设置在特定的状态寄存器中放置状态和错误信息，操作系统定期检测寄存器 设备中断","categories":[{"name":"烂笔头","slug":"烂笔头","permalink":"https://better-jiang.github.io/categories/%E7%83%82%E7%AC%94%E5%A4%B4/"}],"tags":[{"name":"编程认知","slug":"编程认知","permalink":"https://better-jiang.github.io/tags/%E7%BC%96%E7%A8%8B%E8%AE%A4%E7%9F%A5/"}]},{"title":"linux 入门","slug":"linux-入门","date":"2022-03-27T07:16:11.000Z","updated":"2023-02-03T12:14:22.422Z","comments":true,"path":"2022/03/27/linux-入门/","link":"","permalink":"https://better-jiang.github.io/2022/03/27/linux-%E5%85%A5%E9%97%A8/","excerpt":"","text":"常用快捷键 按键 作用 Ctrl+d 键盘输入结束或退出终端 Ctrl+s 暂停当前程序，暂停后按下任意键恢复运行 Ctrl+z 将当前程序放到后台运行，恢复到前台为命令 fg Ctrl+a 将光标移至输入行头，相当于Home键 Ctrl+e 将光标移至输入行末，相当于End键 Ctrl+k 删除从光标所在位置到行末 Alt+Backspace 向前删除一个单词 Shift+PgUp 将终端显示向上滚动 Shift+PgDn 将终端显示向下滚动 shell 常用通配符 字符 含义 * 匹配 0 或多个字符 ? 匹配任意一个字符 [list] 匹配 list 中的任意单一字符 [^list] 匹配 除 list 中的任意单一字符以外的字符 [c1-c2] 匹配 c1-c2 中的任意单一字符 如：[0-9][a-z] &#123;string1,string2,...&#125; 匹配 string1 或 string2 (或更多)其一字符串 &#123;c1..c2&#125; 匹配 c1-c2 中全部字符 如{1..10} 一次创建多个文件，touch jiang_&#123;1..10&#125;.txt, 创建 jiang_1.txt - jiang_10.txt 用户、文件权限管理查看用户who命令，常用参数 参数 说明 -a 打印能打印的全部 -d 打印死掉的进程 -m 同am i，mom likes -q 打印当前登录用户数及用户名 -u 打印当前登录用户登录信息 -r 打印运行等级 用户组在 Linux 里面每个用户都有一个归属（用户组），用户组简单地理解就是一组用户的集合，它们共享一些资源和权限，同时拥有私有资源。 groups lilei , 查看用户lilei 的用户组信息 sudo usermod -G sudo lilei, 给用户添加 用户组 sudo deluser lilei --remove-home, 删除用户， —remove-home 一并删除工作目录 文件访问权限 一个目录同时具有读权限和执行权限才可以打开并查看内部文件，而一个目录要有写权限才允许在其中创建其它文件，这是因为 目录文件实际保存着该目录里面的文件的列表等信息 变更文件所有者sudo chown liuzhenjiang fileName, 修改 fileName 文件的所有者为 liuzhenjiang 修改文件权限 方式一： 二进制数字表示每个文件有三组固定的权限，分别对应 拥有者、所属用户组、其他用户。文件的读写执行 对应字母 rwx，以二进制 表示 111，十进制 表示 7。 rw-rw-rw-，换成对应的十进制 为 666， 这表示 文件的 拥有者、所属用户组、其他用户 具有 读写权限，不具有执行权限 chmod 600 fileName, 修改 fileName 权限 为 600 方式二： 加减赋值操作chmod go-rw fileName g ,o,u, 表示 group(用户组),others(其他用户)，user(用户) +,-, 增加、去掉相应权限 目录结构FHS 文件系统规范： https://refspecs.linuxfoundation.org/FHS_3.0/fhs-3.0.pdf 环境变量添加自定义路径到”PATH”环境变量PATH 里面路径以:作为分隔符, 添加路径 一定要使用绝对路径 1PATH=$PATH:/home/shiyanlou/mybin 在每个用户的 home 目录中有一个 shell 每次启动时默认执行的一个配置脚本，用来初始化环境，其中就包括添加用户自定义环境变量等。 shell 是 zsh，它的配置文件 是.zshrc shell 是 bash， 它的配置文件是.bashrc 将添加环境变量的命令追加 (&gt;&gt;) 到.zshrc中， 1echo &quot;PATH=$PATH:/home/shiyanlou/mybin&quot; &gt;&gt; .zshrc 搜索文件与搜索相关的命令 常用的 有 whereis,which,find,locate whereis ，简单快速，直接从数据库中查询，而非从硬盘中依次查找 搜索 二进制文件，原码文件，man 帮助文件 所在的路径 12whereis find/usr/bin/find locate，通过查询/var/lib/mlocate/mlocate.db数据库来检索信息，不过这个数据库不是实时更新的，系统有定时任务每天自动执行updatedb命令来更新数据库 -c参数，统计数目 1locate /usr/share/*.jpg // 查找/usr/share/ 下 所有jpg文件 which , shell 内建的命令，通常用于确定 是否安装了某个 指定的程序 12which man/usr/bin/man find ，功能强大，不但可以通过文件类型、文件名进行搜索，还可以根据文件的属性(文件时间戳、文件权限等)进行搜索。 基本的命令 格式 find [path][option] [action] 与时间相关的命令参数 参数 说明 -atime 最后访问时间 -ctime 最后修改文件内容的时间 -mtime 最后修改文件属性的时间 以 -mtime c 参数举例 -mtime n, 在 n 天之前的”一天之内”修改过的文件 ， n 为 0 ，表示当天 有改动的文件 -newer file, 列出比 file 文件还要新的文件名 文件打包与解压缩 文件后缀名 说明 *.zip zip 程序打包压缩的文件 *.rar rar 程序压缩的文件 *.7z 7zip 程序压缩的文件 *.tar tar 程序打包，未压缩的文件 *.gz gzip 程序（GNU zip）压缩的文件 *.xz xz 程序压缩的文件 *.bz2 bzip2 程序压缩的文件 *.tar.gz tar 打包，gzip 程序压缩的文件 *.tar.xz tar 打包，xz 程序压缩的文件 *tar.bz2 tar 打包，bzip2 程序压缩的文件 *.tar.7z tar 打包，7z 程序压缩的文件 文件系统操作 、磁盘管理查看磁盘、目录的容量 df 命令查看磁盘容量 df -h du 命令 查看 目录的容量 du -h, 易读方式展示 du -h -d 0, 查看 1 级目录的信息 -d 参数，指定目录的深度 简单磁盘管理 创建虚拟磁盘 使用dd命令，从/dev/zero设备 创建一个容量 为 256M 的空文件 virtual.img 1dd if=/dev/zero of=virtual.img bs=1M count=256 使用 mkfs命令格式化磁盘 成为 文件系统 1sudo mkfs.ext4 virtual.img 使用 mount 命令 挂载磁盘到目录树, mount 命令查看主机已经挂载的文件系统 mount 命令的一般格式 123mount [options] [source] [directory]mount [-o [操作选项]] [-t 文件系统类型] [-w|--rw|--ro] [文件系统源] [挂载点] 磁盘分区 ， fdisk 管道管道是一种通信机制，常用于进程间的通信，网络通信通常通过 scoket，它的表现形式就是将每一个进程的输出（stdout）直接作为下一个进程的输入(stdin)。 匿名管道 ,命令行中的|符号 ls -al | less, 具名管道，通常只会在源程序中用到 cut ,打印某一行的某个字段12345678910# 以 ：为分隔符的第1个字段和第6个字段cut /etc/passwd -d &#x27;:&#x27; -f 1,6# 前五个（包含第五个）cut /etc/passwd -c -5# 前五个之后的（包含第五个）cut /etc/passwd -c 5-# 第五个cut /etc/passwd -c 5# 2 到 5 之间的（包含第五个）cut /etc/passwd -c 2-5 grep, 查找匹配字符串grep 命令一般形式 grep [命令选项]... 用于匹配的表达式 [文件]... 12345678# 查看环境变量中以 &quot;yanlou&quot; 结尾的字符串export | grep &quot;.*yanlou$&quot;# 搜索 当前用户目录下所有包含 &quot;shiyanlou&quot;的文本文件，并显示出现在文本中的行号# -r 递归搜索子目录中文件# -n 打印匹配项行号# -I 忽略二进制文件grep -rnI &quot;shiyanlou&quot; ~ wc, 简单计数工具12345678910111213 # 行数wc -l /etc/passwd# 单词数wc -w /etc/passwd# 字节数wc -c /etc/passwd# 字符数wc -m /etc/passwd# 最长行字节数wc -L /etc/passwd# 统计/etc 下面所有目录数ls -dl /etc/*/ | wc -l sort 排序sort 命令将输入按一定方式排序后再输出。支持的排序有按字典排序，数字排序，按月份排序，随机排序，反转排序等 123# -t 参数 指定字段的分隔符，-k 字段号，指定对哪一个字段进行排序# 默认以字典排序，-n 参数 按照数字排序cat /etc/passwd | sort -t&#x27;:&#x27; -k 3 -n 文本处理 tr 命令， 用来删除一段文本信息中的某些文字，或将其进行转换 1234567# 删除 &quot;hello shiyanlou&quot; 中所有的&#x27;o&#x27;，&#x27;l&#x27;，&#x27;h&#x27;$ echo &#x27;hello shiyanlou&#x27; | tr -d &#x27;olh&#x27;# 将&quot;hello&quot; 中的ll，去重为一个l$ echo &#x27;hello&#x27; | tr -s &#x27;l&#x27;# 将输入文本，全部转换为大写或小写输出$ echo &#x27;input some text here&#x27; | tr &#x27;[:lower:]&#x27; &#x27;[:upper:]&#x27;# 上面的&#x27;[:lower:]&#x27; &#x27;[:upper:]&#x27;你也可以简单的写作&#x27;[a-z]&#x27; &#x27;[A-Z]&#x27;，当然反过来将大写变小写也是可以的 join 命令，将两个文件中包含相同内容的那一行合并在一起 123456789cd /home/shiyanlou# 创建两个文件echo &#x27;1 hello&#x27; &gt; file1echo &#x27;1 shiyanlou&#x27; &gt; file2join file1 file2# 将 /etc/passwd 与 /etc/shadow 两个文件合并，指定以&#x27;:&#x27;作为分隔符sudo join -t&#x27;:&#x27; /etc/passwd /etc/shadow# 将 /etc/passwd 与 /etc/group 两个文件合并，指定以&#x27;:&#x27;作为分隔符，分别比对第4和第3个字段sudo join -t&#x27;:&#x27; -1 4 /etc/passwd -2 3 /etc/group paste 命令， 在不对比的情况下，将多个文件合并，以 tab隔开 1234567echo hello &gt; file1echo shiyanlou &gt; file2echo www.shiyanlou.com &gt; file3# -d 指定合并的分隔符 :paste -d &#x27;:&#x27; file1 file2 file3# -s 合并时， 每个文件为一行paste -s file1 file2 file3 数据流重定向linux 默认提供了三个特殊设备 文件描述符 设备文件 说明 0 /dev/stdin 标准输入 1 /dev/stdout 标准输出 2 /dev/stderr 标准错误 文件描述符： 一个非负整数，实际上它是一个索引值，指向内核为每一个进程所维护的该进程打开文件的记录表。当程序打开一个现有文件或创建一个新文件时，内核向进程返回一个文件描述符。 标准错误重定向标准输出和标准错误虽然都指向终端屏幕，但实际上它们不一样。需要使用文件描述符 1234# 将标准错误重定向到标准输出，再将标准输出重定向到文件，注意要将重定向到文件写到前面cat Documents/test.c hello.c &gt;somefile 2&gt;&amp;1# 或者只用bash提供的特殊的重定向符号&quot;&amp;&quot;将标准错误和标准输出同时重定向到文件cat Documents/test.c hello.c &amp;&gt;somefilehell 在输出重定向文件描述符前加&amp;，否则 shell 会当做重定向到一个文件名为 1 的文件 永久重定向当需要某一部分的命令的输出全部进行重定向，可使用 exec命名实现永久重定向。 exec命令，使用指定的命令替换当前 Shell, 即 使用一个进程替换当前进程，或指定新的重定向 12345678# 先开启一个子 Shellzsh# 使用exec替换当前进程的重定向，将标准输出重定向到一个文件exec 1&gt;somefile# 后面你执行的命令的输出都将被重定向到文件中，直到你退出当前子shell，或取消exec的重定向（后面将告诉你怎么做）lsexitcat somefile 进程-工作管理bash 支持 job(工作控制)，通过 &amp; 符号，可让命令在后台运行 ls &amp; crtl + z可是 工作停止并丢到后台中 jobs命令 查看 被放置在后台的工作 fg [jobnumber], 将后台的工作拿到前台开 123# 后面不加参数提取预设工作，加参数提取指定工作的编号# ubuntu 在 zsh 中需要 %，在 bash 中不需要 %fg [%jobnumber] bg [jobnumber], 在后台运作指定 job kill -signal jobnumber/pid, 对 job 或 pid 对于进程 进行操作 kill 常用信号值 信号值 作用 -1 重新读取参数运行，类似与 restart -2 如同 ctrl+c 的操作退出 -9 强制终止该任务 -15 正常的方式终止该任务 进程查看、控制ps 静态查看当前进程的信息； top实时查看进程的状态；pstree查看当前活跃进程的树形结构 ps aux ，罗列所有的进行信息，ps aux | grep zsh, 查找匹配的进程 Kill 命令当一个进程结束时，或者异常结束时，会向其父进程返回一个，或接受一个 SIGHUP 信号 而做出的结束进程。这个 SIGHUP 信号不仅可以有系统发送，也可以使用kill命令来发送这个信号，来操作进程的结束或重启等等 正则表达式grep 命令用于打印输出文本中匹配的模式串，其常用参数 参数 说明 -b 将二进制文件作为文本来进行匹配 -c 统计以模式匹配的数目 -i 忽略大小写 -n 显示匹配文本所在行的行号 -v 反选，输出不匹配行的内容 -r 递归匹配查找 -A n n 为正整数，表示 after 的意思，除了列出匹配行之外，还列出后面的 n 行 -B n n 为正整数，表示 before 的意思，除了列出匹配行之外，还列出前面的 n 行 --color=auto 将输出中的匹配项设置为自动颜色显示 特殊符号 参数 说明 -b 将二进制文件作为文本来进行匹配 -c 统计以模式匹配的数目 -i 忽略大小写 -n 显示匹配文本所在行的行号 -v 反选，输出不匹配行的内容 -r 递归匹配查找 -A n n 为正整数，表示 after 的意思，除了列出匹配行之外，还列出后面的 n 行 -B n n 为正整数，表示 before 的意思，除了列出匹配行之外，还列出前面的 n 行 --color=auto 将输出中的匹配项设置为自动颜色显示 1234567891011121314# grep默认是区分大小写的，这里将匹配所有的小写字母echo &#x27;1234\\nabcd&#x27; | grep &#x27;[a-z]&#x27;# 将匹配所有的数字echo &#x27;1234\\nabcd&#x27; | grep &#x27;[0-9]&#x27;# 将匹配所有的数字echo &#x27;1234\\nabcd&#x27; | grep &#x27;[[:digit:]]&#x27;# 将匹配所有的小写字母echo &#x27;1234\\nabcd&#x27; | grep &#x27;[[:lower:]]&#x27;# 将匹配所有的大写字母echo &#x27;1234\\nabcd&#x27; | grep &#x27;[[:upper:]]&#x27;# 将匹配所有的字母和数字，包括0-9，a-z，A-Zecho &#x27;1234\\nabcd&#x27; | grep &#x27;[[:alnum:]]&#x27;# 将匹配所有的字母echo &#x27;1234\\nabcd&#x27; | grep &#x27;[[:alpha:]]&#x27;","categories":[{"name":"烂笔头","slug":"烂笔头","permalink":"https://better-jiang.github.io/categories/%E7%83%82%E7%AC%94%E5%A4%B4/"}],"tags":[{"name":"linux","slug":"linux","permalink":"https://better-jiang.github.io/tags/linux/"}]},{"title":"2022成长小记","slug":"2022成长小记","date":"2022-03-10T03:16:47.000Z","updated":"2023-02-03T12:14:22.422Z","comments":true,"path":"2022/03/10/2022成长小记/","link":"","permalink":"https://better-jiang.github.io/2022/03/10/2022%E6%88%90%E9%95%BF%E5%B0%8F%E8%AE%B0/","excerpt":"","text":"0309 移动端支付跳转 bug 修复(部分型号手机微信内置浏览器，不支持 localStorage) https://dmzstg1.pa18.com/pa18shopnst/quote/mobile/index.html#/P020024 马威、胡喜康工作交接安排 (交接人 李镇鹏、陈典银) 裸金属容器部署 (李志永 LIZHIYONG072) ，springcloud ， 支持前端的微服务部署 http://docs.paic.com.cn/#/post/21956400 http://docs.paic.com.cn/#/post/21956583 http://docs.paic.com.cn/#/post/21956447 (nginx 容器化) PKS (Pingan Kubernetes cluster Service， 容器集群服务) 前端微服务 了解 新版官网,报价登录，token 无效，登录失败,增加提示 宠物险 2 款 ZP010138， ZP010140，宠物险年龄更改(增加至 10 岁) 0310 PMP 模拟测试 5 极客时间-vue3 B 站自习室-英语在用(80min) 忍不住玩了几局大乱斗，心里依然感觉，上班太累，下班后要犒劳自己 博客 项目 gitLab 搭建，迁移 骑车至大学城 做 PMP 模拟测试 到 7 点 40 左右才下班，并且降噪的耳机在房子没带来，所以骑车时听不了歌曲，那就不骑车区大学城了，改天吧，或许是明天，但明天很重要的 lpl 比赛要看，大概率也骑不了 早睡、少食 0327 疾风计划-操作系统 做核酸检测 早睡，少食 blog 项目迁移 至 gitlab 0328 疾风计划 - 操作系统 蓝桥实验 - linux 入门 移动端 外呼授权弹窗功能 新版官网 cookie xss 安全漏洞修复 骑车 至 大学城 (19:20-20:20) 早睡，晚餐少食 英语音标-B 站直播(21:10-22:20) 晚饭出公司，楼下吃了兰州拉面，耽误些许时间，外加公司看视频至 20:00 后才骑车回去，至房间已 22 点后，计划被打乱，那就看看综艺，躺平睡觉了~ 0329 疾风计划-操作系统 (视频完结) 蓝桥实验- linux 入门，笔记 骑车 至 大学城 早睡、简食晚餐 英语音标 （公司亦可学习） 下午做核酸，排队时间远超平常，又遇业务临时问题，排查处理至 19 点 30，故再次拖延 发版准备，请延期年假 (不然作废)， 摸鱼 核算检查 0330 宠物险，投保须知、声明文件接口处理 疾风计划 - 操作系统复习、梳理 疾风计划 - 计算机网络 下午运动、拉伸 原周日的龙华飞盘训练因报名人数不足取消，也就找了理由~ 早睡、晚餐少食 英语音标学习 下午休假在房子里，没抵住玩游戏 LOL 的诱惑，直接玩到深夜，哎。。。 0410 dmz 代码库 无用代码 清除 接口 cookie xss 漏洞 处理 疾风计划 - 操作系统复习笔记 疾风计划 - 计算机网络 (数据链路层) 完成部分，课程多少为止，以为能看完 英语音标学习(不可拖延) 还是拖延了，但学英语的决心又强烈了，因想着后面能找到远程外企的工作，未来互联网公司出海趋势必现 早睡、晚餐少食 没早睡，想着英语听力，看部外语电影，就到晚上 1 点多了 简单拉伸 假期飞盘训练，再次取消，左脚莫名其妙的伤了，不便走路，也就更有理由不运动 0411 配合后端，无用功能下线 后管-礼物清单导入 后管- 淘宝客户经营上传 疾风计划-操作系统 复习笔记 疾风计划- 计算机网络 (数据链路层) 英语音标学习(在公司也行，时间上别挑挑拣拣) 早睡、晚餐水果 又开始了~ 0513 数据结构(蓝桥-Python) vue3 重点知识速通 代码核减 疾风计划 - 编译原理 (16-18 讲) 开始 写作 - 【假如明天去旅行】 总想找个一大段时间，安静的，提前梳理好大纲的在去动笔，可真的难以办到，不受控的加班、随时的计划变更，捉摸不定的心情波动，都会对此产生影响。该如何是好？现在我还没答案，也许之后会从某本书，某个人那里所有启发顿悟，那就先等等看吧。 午餐 2 个菜，晚餐少食 0516 数据结构 (蓝桥-python) 午餐 2 素菜，高质量 午休 代码核减(大胆点，无用代码，果断清理) 疾风计划-软件工程 洗衣服、袜子 0606 数据结构(蓝桥-python) 午餐 粥+2 素菜，晚餐少食 疾风计划-人工智能原理 飞盘教学，基本功正/反手 + huck (早溜去赶地铁，早睡) 阶段总结，文字 晚上飞盘活动，回去太晚没时间，得改 0613 早睡，睡前不玩手机 疾风计划 - 人工智能原理(part7-8) Part8 未完成 微前端入门了解 微信读书 (微信小程序相关) 飞盘教学，规则讲解，表情管理，自信、不紧张 0615 早睡，睡前不玩手机 又玩手机至深夜 2 点左右，咋纠正呢？ 疾风计划 - 人工智能原理（完结） 微信读书 - 《少年中国说》 大前端 发版，下班后没时间看，上班不敢大胆看视频~ 年中总结 不知咋写？ 0623 早睡，不看手机 忍不住要看~，到 2 点多才慢慢有睡意。眼睛干涩难受，似乎要滑至破罐破摔之态，怎么去阻止呢？如果是为了玩会，能有自我控制的时间，以达到心理上的平衡（工作真真辛苦，我在人世不甘心如此，一天一定要有自己的快乐时间），那么替换成读书，看杂志亦可 代码库梳理（新版报价、新版官网），部署改造 前端八股文 飞盘 pick up 局，横排战术讲解、讲话文稿，正手传盘 微信读书 - 小程序 0624 早睡，不看手机，手机放别处 飞盘，多传正手，多讲话 微信读书 - 小程序 前端八股文 代码库梳理 0630 年中总结 骑车至大学城 研究生 预研 (在职、非全日职，国外) 感觉不太靠谱，费用巨大，需要15万+；另外已经报名申请”援疆计划”，如果顺利通过，又是一番崭新天地~ 0705 年中 人才测评 英语音标快速过一遍 大前端- redis学习 日记","categories":[{"name":"成长小记","slug":"成长小记","permalink":"https://better-jiang.github.io/categories/%E6%88%90%E9%95%BF%E5%B0%8F%E8%AE%B0/"}],"tags":[{"name":"成长小记","slug":"成长小记","permalink":"https://better-jiang.github.io/tags/%E6%88%90%E9%95%BF%E5%B0%8F%E8%AE%B0/"}]},{"title":"等来的完美时刻?","slug":"等来的完美时刻","date":"2022-03-10T02:59:16.000Z","updated":"2023-02-03T12:14:22.422Z","comments":true,"path":"2022/03/10/等来的完美时刻/","link":"","permalink":"https://better-jiang.github.io/2022/03/10/%E7%AD%89%E6%9D%A5%E7%9A%84%E5%AE%8C%E7%BE%8E%E6%97%B6%E5%88%BB/","excerpt":"","text":"等周末有时间了在去跑步，这几天就好好休息。 等晚上回房子了在学习英语，公司网络差，有人在，不好开口跟读。 等下午有大段时间了在认真写写代码，上午可能有事，或许要回邮件，也有概率处理生产问题。 等具有较好文笔，读书百卷后，兼具文学修养时，才去想着，有勇气去写作投稿。 等忍无可忍时，有无法反驳的条件后，才敢去宣泄。 等找到良机后，才想着和多年老友联络一番。 因为要等，并幻想期盼那一刻的到来，好像只要时间一到，自己能焕然一新，现阶段所有的烦恼全无。那一刻过后，我能坚持跑步，好好学习英语，认真写代码，能笔耕不辍，甚至出书立著…… 所以，我希望时间快到过去，熬过这段时间，一切都会变好。 所以，这期间，我无所约束，开始放纵，暴饮暴食，熬夜打 LOL，无所畏惧的刷 B 站视频，只为躲过这无用的时间。 其实，现在你怎样，那一刻你大概率还是怎样，当下就是生活本身模样，你自身的底色。 为啥一定要等到完美时刻才开始呢？ 现在不也能开始吗？ 如果害怕失败， 就要去直面失败，了解失败，甚至是习惯失败。 战胜恐惧的最好办法，就是直面恐惧，用魔法打败魔法。","categories":[{"name":"随笔感悟","slug":"随笔感悟","permalink":"https://better-jiang.github.io/categories/%E9%9A%8F%E7%AC%94%E6%84%9F%E6%82%9F/"}],"tags":[{"name":"反思怪","slug":"反思怪","permalink":"https://better-jiang.github.io/tags/%E5%8F%8D%E6%80%9D%E6%80%AA/"}]},{"title":"我回来了","slug":"我回来了","date":"2022-03-03T22:30:57.000Z","updated":"2023-02-03T12:14:22.422Z","comments":true,"path":"2022/03/04/我回来了/","link":"","permalink":"https://better-jiang.github.io/2022/03/04/%E6%88%91%E5%9B%9E%E6%9D%A5%E4%BA%86/","excerpt":"","text":"有很多话，我想说，不仅仅是告诉自己，也想告诉他人…. 所以我开始写博客… 写着，写着，就不想写了，因为没人知道，没人反馈 只会自己偶尔看看，回想一下当时之境 感慨时间飞逝，白云苍狗 顿时鸡血来袭，能力满满 宏达计划喷涌而出，奋力学习，坚持码字 不久的将来，就有收获 可是，现实残酷 会打破所有不切实际的幻想 三天打鱼两日晒网者，最是深得体会 原来一切没那么简单 空想多了，日后见仅是空想 日后也就不再空想了 多次被现实教训，空想无用后 干脆，躺了 令那些在乎你的人，摸不着头脑 也让自己在乎的人，失望 原来，你也被缴枪，想吃皇粮","categories":[{"name":"就要表达","slug":"就要表达","permalink":"https://better-jiang.github.io/categories/%E5%B0%B1%E8%A6%81%E8%A1%A8%E8%BE%BE/"}],"tags":[]},{"title":"asw初见","slug":"asw初见","date":"2022-03-03T10:03:57.000Z","updated":"2023-02-03T12:14:22.422Z","comments":true,"path":"2022/03/03/asw初见/","link":"","permalink":"https://better-jiang.github.io/2022/03/03/asw%E5%88%9D%E8%A7%81/","excerpt":"","text":"ssh 更改端口号、本地配置、秘钥连接12345678910111213141516netstat -anlp |grep sshd 查看 sshd 端口号vim /etc/ssh/sshd_config 更改 ssh 配置 默认端口semanage port -a -t ssh_port_t -p tcp #PORTNUMBER// 服务器 ssh 公钥 存储地址AuthorizedKeysFile .ssh/authorized_keys// 本机 生成 秘钥对，将公钥 复制到 服务器的 ~/.ssh/authorized_keys// 本机 shh configHost love Port 22 HostName 119.45.124.197 User root IdentityFile ~/.ssh/id_rsa IdentitiesOnly yes linux 命令查看系统版本：lsb_release -a查看内核版本：uname -a查看磁盘空间占用情况：df / df -Th查看系统进程：top 文档型 (touch,mkdir,cat,echo,cd,vi) 尾部插入内容 echo ‘123’ &gt;&gt; text.txt 替换所有内容 echo ‘123’ &gt; text.txt 功能型 （下载，压缩、解压缩） 下载，weget 资源连接 https://dlcdn.apache.org/tomcat/tomcat-10/v10.0.16/bin/apache-tomcat-10.0.16.tar.gz yum install 包名 cent oS yum whatprovides 命令， 反查匹配的包 解压 tar zxvf 资源文件名 apache-tomcat-10.0.16.tar.gz z: gz 结尾 的压缩文件， x: 解压 v: 显示解压过程 f: 解压到当前文件同名的文件夹中 硬件型 （进程、服务，磁盘、网络） ps -ef | grep sshd 查看进程 Kill -9 pid 9 强制结束进程 service sshd status 查看服务 netstat 显示网络相关信息 linux 目录结构home 个人目录 etc 软件配置文件 etc/hostname 主机名 sys 系统目录 usr 系统可执行文件 var 存放日志文件 docker主要特性 文件、资源、网络隔离 变更管理，日志记录 写时复制 文件系统隔离，每个进程容器运行在完全独立的根文件系统 网络隔离，可以使用 cgroup 为每个进程容器分配不同的系统资源，如 CPU、内存 日志记录，docker 会收集和记录每个进程容器的标准流（stdout、stderr、stdin），用于实时检索 安装 、启动Install on CentOS 更换国内镜像源 12345678910// 修改文件vi /etc/docker/daemon.json&#123;&quot;registry-mirrors&quot;: [&quot;https://docker.mirrors.ustc.edu.cn&quot;]&#125;// 重启sudo systemctl daemon-reloadsudo systemctl restart docker 安装 mysql1234567891011121314// 启动 mysql root/jiang, 映射到28001 端口，// 本地仓库没有的话，会去远端仓库拉去docker run --name jiang-mysql -e MYSQL_ROOT_PASSWORD=jiang -p 28001:3306 -d --restart=always mysql--name 指定容器名称-p 指定映射端口，前面是映射端口，后面 是容器运行端口-d 后台运行--restart=always 容器开机运行mysql 镜像名称1、进入 容器， docker exec -it jiang-mysql bash2、登录mysql， mysql -uroot -pjiang docker composehub.docker jiang2202 / 1小2江 &#x31;&#x34;&#51;&#x33;&#x35;&#51;&#x39;&#x35;&#x31;&#x34;&#64;&#x71;&#113;&#x2e;&#x63;&#x6f;&#x6d; 安装docker compoe install 123456// 1、安装sudo curl -L &quot;https://github.com/docker/compose/releases/download/1.29.2/docker-compose-$(uname -s)-$(uname -m)&quot; -o /usr/local/bin/docker-compose// 2、给执行权限 sudo chmod +x /usr/local/bin/docker-compose // 3、检查 docker-compose --version docker-compose 配置docker-compose.yml 文件 启动 docker-compse up -d 12345678910111213mysql1: image: mysql environment: - MYSQL_ROOT_PASSWORD=jiang ports: - 28002:3306mysql2: image: mysql environment: - MYSQL_ROOT_PASSWORD=2022 ports: - 2022:3306 nodenpm 发布 切换镜像源 123// 查看npm config lsnpm set registry https://registry.npmjs.org/ 添加 npm 账户 1npm add better-jiang 发布、更改版本 1234npm publish// 版本 按次序增加npm version [najor | minor | patch] 真机调试 Chrome + Android. Safari + ios 浏览器，chrome://inspect/#devices android 开发者模式，调试模式， usb 连接，手机电脑 相同网络 Fiddler / Charles (mac) 【数据劫持】 Weinre, Spy-Debugger, vConsole AWS1234567891011121(X)小2江!ubuntu@ip-172-31-87-88 Ubuntu 22.04 LTSssh -i &quot;rsa-jiang.cer&quot; ubuntu@ec2-52-71-25-178.compute-1.amazonaws.comssh -i &quot;rsa-jiang.cer&quot; ubuntu@ec2-18-206-231-80.compute-1.amazonaws.comroot@ip-172-31-87-88 1小2江hub.docker jiang2202 / 1小2江 1433539514@qq.com","categories":[{"name":"技术总结","slug":"技术总结","permalink":"https://better-jiang.github.io/categories/%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%93/"}],"tags":[]},{"title":"前端模块化","slug":"前端模块化","date":"2020-06-05T04:09:17.000Z","updated":"2023-02-03T12:14:22.422Z","comments":true,"path":"2020/06/05/前端模块化/","link":"","permalink":"https://better-jiang.github.io/2020/06/05/%E5%89%8D%E7%AB%AF%E6%A8%A1%E5%9D%97%E5%8C%96/","excerpt":"","text":"模块可以理解为独立且通用的代码单元，是一个实现特定功能的文件。所谓模块化只要就是解决代码分隔、作用域隔离、模块之间的依赖管理等问题。 模块化的优点： 避免变量污染、命名冲突 可维护性；模块是独立的，测试、修改都可独立进行 重用代码；通过模块的导出、引入的方式，避免代码的拷贝 早期模块化方式 函数封装，缺点：污染全局变量，变量命名冲突，模块成员之间没有关系 对象封装，缺点：外部可随意修改内部成员变量 立即执行函数（闭包），缺点：代码量大，闭包有成本，影响性能 script标签顺序引入 js 文件，缺点：污染全局变量，命名冲突，依赖关系不明显，不利于维护 模块化规范常见的模块化规范有： CommonJS、AMD（Asynchronous Module Definition）、CMD（Common Module Definition）、ES6 Module CommonJS CommonJS 采用 同步加载模块的策略，只有加载完成后才会之下后续操作。 CommonJS 是服务端模块的规范，Node.js 就是采用该规范。 在 CommonJS 的规范中，每一个 js 文件就是一个独立的模块上下文（module context），在该上下文中默认创建的属性都是私有的。即在一个文件定义的变量，是私有的，对其他文件是不可见的。 require和module关键字，实现了模块导入、对外暴露 12345678910111213function aModule() &#123; let name = &quot;jiang&quot;; this.foo = function () &#123; console.log(&quot;&gt;&gt;&gt; hello &quot; + name); &#125;; this.bar = function () &#123;&#125;;&#125;module.exports = aModule; // 对外暴露// 引入 模块 aModulelet a = require(&quot;./aModule&quot;);let aa = new a();aa.foo(); // &gt;&gt;&gt; hello jiang require 中文件的查找策略 AMD 异步模块定义 AMD 优先照顾浏览器的模块加载场景，使用异步加载和回调的方式 使用define方法，来定义模块、引入模块。该方法需要三个参数：模块名称、依赖数组、回调函数 RequireJS 遵循 AMD 规范 12345678define([&quot;module1&quot;, &quot;module2&quot;], function (module1, module2) &#123; function foo() &#123; module1.foo(); &#125; return &#123; foo: foo, &#125;;&#125;); ES6 Module 通过 import 引入模块，export 导出模块 每一个模块只加载一次，并缓存 一个模块就是一个单例 模块中的值属于 动态 只读 引用，不允许修该 12345678export let foo = &#123; name: &quot;jiang&quot;, age: &quot;25&quot;,&#125;; // 导出// 引入模块import &#123; foo &#125; from &quot;./foo.js&quot;;console.log(foo.age); ES6 模块与 CommonJS 模块的差异 CommonJS 模块输出的是一个值的拷贝，原始类型的值会被缓存，ES6 模块输出的是值的引用，且是动态的只读的引用,不会缓存，对它进行重新赋值会报错 1234567891011121314151617181920// a.jslet counter = 3;function incCounter() &#123; counter++;&#125;module.exports = &#123; counter, get getCounter() &#123; return counter; &#125;, incCounter,&#125;;// a1.jslet a = require(&quot;./a&quot;);console.log(a); // &#123; counter: 3, getCounter: [Getter], incCounter: [Function:incCounter] &#125;console.log(a.counter); // 3a.incCounter();console.log(a.counter); // 3console.log(a.getCounter); // 4 a.js模块加载后，它的内部变化就影响不到counter了，因为counter是是一个原始类型的值，会被缓存。写成 get 函数，就能得到内部变动后的最新值了。 1234567891011// b.jsexport let counter = 3;export function incCounter() &#123; counter++;&#125;// b1.jsimport &#123; counter, incCounter &#125; from &quot;./b&quot;;console.log(counter); // 3incCounter();console.log(counter); // 4 ES6 模块，遇到import，就会生成一个只读引用，等到脚本真正执行时，再根据这个只读引用，到被加载的那个模块去读值 CommonJS 模块在运行时加载，ES6 模块在 编译时就输出接口，在静态解析阶段就会生成 处理循环加载不同，CommonJS 模块，脚本代码在require的时候，就会全部执行，一旦出现某个模块被”循环加载”，就只输出已执行的部分，还未执行的部分不会输出；ES6 模块是动态引用的，在真正取值的时候 需要 开发者自己去保证，能取到值。 123456789101112131415161718// c.jsexports.done = false;var d = require(&quot;./d&quot;);console.log(&quot;在c.js 中，d.done = %j&quot;, d.done);exports.done = true;console.log(&quot;c.j 执行完毕&quot;);//d.jsexports.done = false;var c = require(&quot;./c&quot;);console.log(&quot;在 d.js 中， c.done = %j&quot;, c.done);exports.done = true;console.log(&quot;d.js 执行完毕&quot;);//c_d.jsvar c = require(&quot;./c&quot;);var d = require(&quot;./d&quot;);console.log(&quot;在 c_d.js 之中, c.done=%j, d.done=%j&quot;, c.done, d.done); 123456$ node.exe c_d.js在 d.js 中， c.done = falsed.js 执行完毕在c.js 中，d.done = truec.j 执行完毕在 c_d.js 之中, c.done=true, d.done=true","categories":[{"name":"技术总结","slug":"技术总结","permalink":"https://better-jiang.github.io/categories/%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%93/"}],"tags":[]},{"title":"CSS查缺补漏","slug":"CSS查缺补漏","date":"2020-06-02T04:03:41.000Z","updated":"2023-02-03T12:14:22.422Z","comments":true,"path":"2020/06/02/CSS查缺补漏/","link":"","permalink":"https://better-jiang.github.io/2020/06/02/CSS%E6%9F%A5%E7%BC%BA%E8%A1%A5%E6%BC%8F/","excerpt":"","text":"background background-position：设置背景图片的起始位置 background-attachment：背景图是否在视口内固定，或者随它的包含块一起滚动（scroll，fixed） background-size：设置背景图片大小，（auto，cover，contain， width height） margin margin 的 百分比值，是按其包含元素的宽度计算 边距塌陷/折叠 （Margin Collapse）：元素底部和另一个元素的顶部边距有时会折叠成一个边距，即 2 个元素中最大的边距。只发生在上下边距，左右边距不会发生。3 种发生情况; 同一层相邻元素之间 没有内容将父元素和后代元素分开 如果没有 border，padding，行内内容，也没有创建块级格式 上下文或清除浮动 来分开一个块级元素的 margin-top 与 其 内一个或多个后代块级元素的 margin-top；同理，margin-bottom 也是。。则会出现父级块元素和其内后代块元素外边界重叠，重叠部分最终会溢出到父级块元素外面。 空的块级元素：当一个空元素 margin-top 直接贴到元素的 margin-bottom 时也会发生边界折叠。 以上边距折叠，只发生在 Block-Level 的元素，浮动元素或绝对定位元素（脱离了正常文档流，且会生成块级的框，变成inline-block元素）不会。 Test text-transform: 设置文本的大小写形式，uppercase, lowercase, capitalize(首字母大写) text-indent：设置文本第一行的缩进 letter-spacing：字符之间的距离 word-spacing：单词之间的距离 white-spacing：如何处理 内部的空白？ text-shadow： 字体阴影效果 text-overflow：如何处理未显示的溢出内容？显示一个省略号，或一个自定义字符串 text-overflow:clip | ellipsis | initial | inherit Font @font-face： 引入外部字体（本地或在线） Display ，visibility**display:none**，从 DOM 删除元素，该元素不再占据空间 visiblity: hidden,隐藏元素，但该元素仍在布局中占据空间 z-index在 CSS 中所有的盒模型元素都处于三维坐标系中，除了常用的横坐标和纵坐标，还可以沿着”在轴”层叠摆放，使用z-index属性来指定，当前层在 z 轴的位置。具体规则如下 不含 z-index 属性，默认的摆放规则（从底到顶顺序） 根元素的背景和边界 普通文档流里的块元素（无 position,或者 position: static）,按照 HTML 中的出现顺序堆叠 定位元素按 HTML 中的出现顺序堆叠 浮动元素的摆放规则 使用 z-index 改变层叠顺序 在使用 z-index 属性时，只有定位元素，且 z-index 不等于 auto 时（即position 值为 absolute（绝对定位）或 relative（相对定位）且 z-index 值不为 auto 的元素），才会创建层叠上下文。 当没有指定 z-index 时，默认为 0，所有元素被渲染在默认层（0 层） 层叠上下文层叠上下文的形成条件： 文档根元素 position 值为 absolute 或 relative，且 z-index 的值部位 auto 的元素 position 值为 fixed 或 sticky 的元素 flex 容器的子元素，且 z-index 值不为 auto opacity 属性值小于 1 的元素 子级层叠上下文被视为其父级层叠上下文的一个独立单元，子级层叠上下文的 z-index 值只在父级中才意义，即比较 z-index 时，先比较父级的 z-index 水平/垂直 居中 块元素水平居中，给定宽度，左右 margin:auto 文本水平居中，text-align:center 图片水平居中，display:block 左右 margin:auto 块元素 左、右对齐，绝对定位（ position:absolute），或 使用 浮动 ，并清除浮动 文本 垂直 居中 ，上下设置 padding 或 line-height 等于 height 块元素 水平/垂直居中，使用 position 和 transform； 注意元素 marign：0 块元素 水平/垂直居中，使用 flexbox 媒体查询 @media 响应式布局响应式导航 过渡（transition）&amp; 动画 （animation） 提示框，指示三角标 遮盖层 &amp; 图像 &amp; 过渡效果","categories":[{"name":"技术总结","slug":"技术总结","permalink":"https://better-jiang.github.io/categories/%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%93/"}],"tags":[{"name":"css","slug":"css","permalink":"https://better-jiang.github.io/tags/css/"},{"name":"面试","slug":"面试","permalink":"https://better-jiang.github.io/tags/%E9%9D%A2%E8%AF%95/"}]},{"title":"CSS命名（规范/约定）","slug":"CSS命名（规范-约定）","date":"2020-06-01T00:26:06.000Z","updated":"2023-02-03T12:14:22.422Z","comments":true,"path":"2020/06/01/CSS命名（规范-约定）/","link":"","permalink":"https://better-jiang.github.io/2020/06/01/CSS%E5%91%BD%E5%90%8D%EF%BC%88%E8%A7%84%E8%8C%83-%E7%BA%A6%E5%AE%9A%EF%BC%89/","excerpt":"","text":"CSS 命名为什么规范？根据自身经历总结，因混乱、不规范的 CSS 命名所导致的问题有以下几点： 没规范，也就没有限制，每次命名时会东想西想很久，浪费时间。 没规范，命名随意，不能很好的反映该元素的在文档中的结构、功能，、状态、样式，语义不明，下次在看时，难懂。 没规范，命名混乱，甚至会发生命名冲突情况，难复用。 如果是多人合作开发，每个人都随意命名，他人解读不便，增加了修改和维护的难度。 所以，好的 CSS 命名规范对个人或团队都挺重要的，按规范命名，不必花费过多的思考时间；语义明确的名称，能一眼看出该元素的结构、功能、状态、样式等信息；规范的命名，团队成员之间都比较容易解读，更易复用，不仅可以提高开发效率，而且有益于后期修改和维护。 网上查询了关于 CSS 样式命名的资料，其中比较常用的思想: BEM,像 在我项目中用的iview UI，饿了么的element-ui，以及阿里的 Ant Design 这些开源的 UI 组件库中的 CSS 命名都是基于BEM的思想。 什么是 BEM？BEM 的意思是 块(Block)、元素(Element)、修饰符(Modifier)，其基本命名规则就是组件名+元素名+修饰符名 块(Block)， 一个块就是一个独立有实际意义的组件或模块，并且每一个块在逻辑和功能上是相互独立的。例如，button,form等。 元素(Element)， 它属于块的一部分，没有独立的意义，在语义上要绑定到它的块上。例如，from-item绑定在form块上;form-item-label元素又是绑定在from-item块上的。 修饰符(Modifier)，它是块或元素的标志，用来表示它们的外观、行为、或状态。例如button-circle 圆形按钮,button-success成功状态的按钮。 CSS 命名规范/约定 CSS 样式文件表命名 命名 说明 master.css 、main.css 、style.css 主要的样式 base.css 基础，公用 layout.css 布局，排版 theme.css 主体 font.css 文字、字体 form.css 表单 mend.css 补丁 print.css 打印样式 页面结构相关命名 命名 说明 header 页面 头部 nav 导航 main 页面 主体 sidebar 侧栏 content 内容 container 容器 wrapper 包装容器，一般用于布局，控制内部 footer 页面 底部 left right center 页面 左 右 中 部分 导航相关命名 命名 说明 nav 导航 mainnav 主导航 subnav 子导航 breadcrumb 面包屑导航 pageheader 页头 导航 （返回 按钮） sidebar 侧边导航 leftsidebar 左侧导航 rightsidebar 右侧导航 menu 菜单 submenu 子菜单 dropdown 下拉菜单 title 标题 summary 摘要 语义化的小部件命名 命名 说明 logo 标志 brand 品牌 banner 横幅图片、广告 login 登陆 logout 登出 loginbar 登陆条 register 注册 search 搜索 serchbar 搜索条 icon 图标 share 分享 digg 顶 like 喜欢 guild 指南 vote 投票 partner 合作伙伴 flink 友接 aboutus 关于我们 contact 联系我们 company 公司介绍 culture 企业文化 honor 公司荣誉 aptitude 企业资质 copyright 版权 news 新闻 download 下载 service 服务 joinus 加入 top / rank 排名 ad 广告 help 帮助 tips 小技巧 note 注释 info 信息 toggle，switch 开关 attach 附件 captioning 字幕 notification 通知 avatar 头像，图像 状态相关命名 命名 说明 previous 前一个 next 后一个 current 当前的 show 显示的 hide 隐藏的 open 打开的 close 关闭的 default 默认的 selected 选择的 active 有效的，激活的 disabled 禁用的 danger 危险的 primary 主要的 success 成功的 warning 警告的 error 出错的 info 提示的 lg 大型的 sm 小型的 md 中型的 xs 超小型的 collapsed 收起的 常用小 组件命名，介绍 组件名 介绍 Button 按钮 ButtonGroup 按钮组 Icon 图标 Grid 栅格布局，24 等分（ view UI ，浮动 + 百分比宽度，and Design， flex+百分比框 Layout 布局，旗下可嵌套 Header,Sider,Content,Footer List 列表，可承载文字、图片、段落等，常用于后台数据展示 Card 卡片，一种容器，用来显示文字、列表、图文等信息聚合在卡片容器中展示 Collapse 折叠面板，可折叠，展开的内容区域 Split 面板分隔，将一部分区域，分隔成可拖拽调整宽、高的 2 部分区域 Divider 分割线 Cell 单元格 Menu 导航菜单 accordion 是否开启手风琴模式（即只能展示一个子菜单） Breadcrumb 面包屑导航，显示网站的层级结构，告知用户当前位置 Tabs 标签页，选项卡切换 Dropdown 下拉菜单 Page 分页 Anchor 锚点，跳转到页面的指定位置 Steps 步骤条 LoadingBar 加载进度条，用于页面加载、异步请求，文件上传、下载等 Input 输入框 Radio 单选框 Checkbox 多选框 Switch 开关 Select 选择器，可支持单选、多选、搜素 AutoComplete 自动补全 Slider 滑块，用于在数值区间进行选择，支持连续或离散值 DatePicker / TimePicker 日期，时间选择器 Cascader 级联/层级 选择，常用于省市区、公司级层等选择 Transfer 穿梭框 Rate 评分 Upload 上传 ColorPicker 颜色选择 Badge 徽标，在通知图表或用户头像的右上角，提醒用户处理 Avatar 头像 Affix 图钉，固定在屏幕上，不随页面滚动而滚动 BackTop 返回顶部 Alert 警告提示 Message 提示信息，操作反馈，自动消失 Notice 通知提醒，通知，或系统主动推送，可关闭 Modal 模态对话框，在浮层中显示、并引导用户进行操作 Drawer 抽屉，从父区域边缘滑入，覆盖部分父区域内容 Tree 树形控件，展示事物的层级关系 Tooltip 文字提示气泡框，代替 元素title提示 Poptip 提示气泡框 Progress 进度条 Tag 标签 Carousel 走马灯，图片、卡片轮播 Timeliine 时间轴 Spin 加载中，用于页面和区块的加载中状态 Skeleton 骨架屏，在需要等待加载内容的位置提供一个占位图形组合","categories":[{"name":"技术总结","slug":"技术总结","permalink":"https://better-jiang.github.io/categories/%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%93/"}],"tags":[{"name":"css","slug":"css","permalink":"https://better-jiang.github.io/tags/css/"}]},{"title":"HTTP强缓存、协商缓存","slug":"HTTP强缓存、协商缓存","date":"2020-05-26T23:23:37.000Z","updated":"2023-02-03T12:14:22.422Z","comments":true,"path":"2020/05/27/HTTP强缓存、协商缓存/","link":"","permalink":"https://better-jiang.github.io/2020/05/27/HTTP%E5%BC%BA%E7%BC%93%E5%AD%98%E3%80%81%E5%8D%8F%E5%95%86%E7%BC%93%E5%AD%98/","excerpt":"","text":"浏览器缓存缓存是一种保存资源副本并在下次请求时使用改副本的技术。浏览器缓存是浏览器会把用户最近请求过的资源 存储在本地，当再次请求该资源时，浏览器会拦截请求，直接返回本地存储的资源，而不会在去源服务器重新下载。好处： 缓解服务器端压力 加快客户端网页加载速度 减少冗余的数据传输 浏览器缓存过程 浏览器首次请求资源时，因本地无缓存，向 web 服务器发送请求，服务器响应请求 + 缓存相关（Cache-Control,Expires,Etag,Last-Modified）的头部字段信息，浏览器进行缓存。 浏览器后续再次请求资源时，会根据该资源缓存的头部字段信息，来决定使用 强缓存 or 协商缓存？ 获取该资源缓存的头部字段信息，根据Cache-Control 和 Expires来判断是否过期。没过期，从缓存中获取该资源。 已过期，向服务端发送请求时 通过If-None-Match头字段 将Etag发送给服务器,服务器对比客户端发过来的 Etag 是否与服务器相同，相同证明资源未修改过，返回 304，继续使用本地缓存；若不同，返回 200+最新新资源。 通过If-Modified-Since头字段 将Last-Modified发送给服务器，服务器根据最后修改时间判断客户端的资源是否为最新的，是最新的，返回 304，客户端继续使用本地缓存，不是最新的，返回 200+最新资源。 强缓存强缓存利用Cache-Control和Expires字段来控制的，设置资源的过期时间,如果没过期，从缓存读取该资源，过期了则向服务器请求资源。Cache-Control的优先级高于Expires Cache-Control (http1.1)cache-control:max-age=3600，代表着资源的有效期是 3600 秒,其他常用的值： no-cache: 不使用本地缓存。使用协商缓存 no-store: 禁止浏览器缓存资源，每次请求资源，都会向服务器发送请求，并返回完整资源 public: 可以被所以用户缓存，包括客户端用户和 CDN 等中间代理服务器 private: 只能被客户端用户的浏览器缓存 Expires(http1.0)它的值是绝对时间格式的 GMT 格式的字符串（expires:Wed, 27 May 2020 00:19:59 GMT）。表示该资源的失效时间。发送请求在该失效时间之前，使用本地缓存，否则向服务器请求资源。明显缺点：服务器与客户端有时间偏差，如果偏差较大，导致缓存混乱 协商缓存协商缓存由服务器来决定缓存是否可用，所以客户端于服务器要通过某种标识来进行通信，从而让服务器判断请求资源是否使用缓存。只有由 2 组头字段进行标识：Etag / If-None-Match和Last-Modified / If Modified-Since Etag / If-None-MatchETag是一个资源的校验码，可以保证每一个资源是唯一的，资源变化会导致Etag变化，服务器根据浏览器上送的If-None-Match的值来判断是否缓存可以。当服务器返回 304 响应时，Etag重新生成，响应头部还会把这个Etag返回 Last-Modified / If -Modified-Since浏览器首次请求资源时，服务器响应头会带字段Last-Modified，表示该资源的最后修改时间。当浏览器再次请求资源时，会在请求头的字段带If-Modified-Since，该值就是之前响应的的Last-Modified的值。服务器根据资源的最后修改时间判断是否使用缓存。","categories":[{"name":"技术总结","slug":"技术总结","permalink":"https://better-jiang.github.io/categories/%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%93/"}],"tags":[{"name":"http","slug":"http","permalink":"https://better-jiang.github.io/tags/http/"},{"name":"面试","slug":"面试","permalink":"https://better-jiang.github.io/tags/%E9%9D%A2%E8%AF%95/"}]},{"title":"面试小记","slug":"面试小记","date":"2020-05-26T05:23:37.000Z","updated":"2023-02-03T12:14:22.422Z","comments":true,"path":"2020/05/26/面试小记/","link":"","permalink":"https://better-jiang.github.io/2020/05/26/%E9%9D%A2%E8%AF%95%E5%B0%8F%E8%AE%B0/","excerpt":"","text":"自投简历已有一周时间，电话面试 4 次，现场面试 1 次，机测 2 次。总得来讲是挺好，没被面试官吊打，其所提问题，都在我射程范围内。毕竟为此认真准备近 2 个月时间，这种因付出，而有收获的感觉蛮爽滴。但是，还有 2 个遗憾之处： 1. 自我介绍，条理不清 ，有些啰嗦自我介绍时，因没特意准备，所以每次面试都张口就来，条理常常不清，会不自然的于自认为小有成就的项目上，花费过多时间介绍，啰啰嗦嗦。自我介绍流程公式：基本信息 + 个人技术栈 + 项目（2-3 个，重点介绍 1 个与公司强相关的） + 亮点/加分项 2. 知识点讲解不深入因面试官所提的问题，我基本都会，有的甚至写过总结类的博客。所以，膨胀了，回答很简单，直接给出了结论，不做过多解释，完事。那感觉就像高手之间的过招，点到为止，面试官应该知道我回答的是什么，也清楚我的实力。正因为此，单次回答问题的时间短，同等时间的面试过程里，我要回答更多的问题。问题越多，我遇到不会的或回答有误的机率越大，这对我很不利。 最近在 B 站，刷了些财经类很火的视频，里面常用的讲解套路可以一用。有 4 个关键词：以我为准，先说结论，举个例子，幼儿园化 以我为准，对自己所说负责，有百分比的把握。这就要求自己对问题所涉及知识点、原理要深入了解，并实测验证过。 先说结论，能让面试官快速判断对错，如果错了，面试官一般会给出正确提示，再据提示谈谈自己的理解。而不是，在南辕北辙的讲完后，得出一个错误结论，浪费时间。 举个例子，结论说了，就要说理由，最好的方法 ，就是举个实际的例子，使面试官有有代入感，更易理解。 幼儿园化，言语要简单易懂，有条理，连幼儿园的小朋友都能听懂并明白。哎，我那“高手过招，点到为止”的回答方式，太可笑了。 关于机测一个华为的算法题，一个平安的 IQ 测试。大多数网友都表示太难，哭了。 华为算法题 对于华为算法题，，因没有系统学习过算法、数据结构，我很害怕，所以没有第一时间去做，而是准备了几天，首次在牛客网刷算法题，总结 ES6 中 数组、字符串新方法，Map、Set 数据结构。同时在本地 IDE 中配置了一样的运行环境，并解决了一直困扰的输入/输出问题。 今早上 6 点多，我醒了。 点击了华为的机测链接，录入信息，登陆，心跳加速，激动紧张，深呼吸，站了起来，跳了几下，又坐下。读题，思考，草稿纸上写了，划掉，再写再划，反反复复，终于理顺思路。打开本地 IDE，写下代码，调测，出错，改代码，再调测，再改代码…,最后成功了。提交测试验证，case 通过率 0%，开始找原因，时间过了很旧，是默认给出的输入，输出代码有问题，多亏我有所准备，用准备的输入/输出代码替换其默认给的，解决。再次提交测试验证，通过率 0%，再次排查，时间所剩不多，还有 10 多分钟，看到网页上有个自测按钮，之前涮题时从未用过，抱着试一试的态度，找到了错误之处，因为要在本地调测，加类些输出语句，之后并未移除。所以，在提交测试，总是通不过。再次提交测试，通过率 0%，感觉自己已经凉透，还是 7 分钟。最后的，我再次认真读了一遍题目，原来它要输出 最长连续字符串的长度，不是字符串本身。更改后，再次提交测试，case 通过率 60%，我及格了，开心极了。那种在前期准备，过程中不放弃，通过自我能力，再加上一点运气，于最后时刻，战胜强敌，夺取胜利的感觉，别提有多爽了！ 平安 IQ 测试 40 题，每题 60s 或 90s，时间很急，必须争分夺秒。前 2 题没来的及选答案， 归纳题没时间看完题目，图形推理题找不出规律，图表类题读不通选项，只好瞎蒙。但即便如此，我依然感觉良好，因为为此准备了一个下午，总结的答题技巧很是受用，最起码让我多做正确 7、8 个题，答对 12 题，就是正常智商了。 最终结果也如我所料，我通过。 最后总结凡事预则立，不预则废，事先有准备，有计划，就比较容易得到成功。不提前准备，仓促上阵，就会发生错误和后悔的事。以前所做的莽事，历历在目： 没准备去面试，一问三不知，返给简历，直接拒绝；临行前，未收拾好行李，查清去火车站线路，所需时间，而错过火车。没热身，直接上去飞盘比赛，结果 跑不动，并受伤。 虽然做不到事事能有备无患，但有所准备，面对困难时，我会更从容，思考更全面，更充满希望，也会坚持的更久些。而非恐惧，迷茫，放弃，后悔。","categories":[{"name":"随笔感悟","slug":"随笔感悟","permalink":"https://better-jiang.github.io/categories/%E9%9A%8F%E7%AC%94%E6%84%9F%E6%82%9F/"}],"tags":[{"name":"面试","slug":"面试","permalink":"https://better-jiang.github.io/tags/%E9%9D%A2%E8%AF%95/"}]},{"title":"CSS面试题（更新中）","slug":"CSS面试题（更新中）","date":"2020-05-24T01:12:19.000Z","updated":"2023-02-03T12:14:22.421Z","comments":true,"path":"2020/05/24/CSS面试题（更新中）/","link":"","permalink":"https://better-jiang.github.io/2020/05/24/CSS%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%88%E6%9B%B4%E6%96%B0%E4%B8%AD%EF%BC%89/","excerpt":"","text":"选择器，优先级优先级：!important &gt; 内联样式 style &gt; ID 选择器 &gt; 伪类选择器 = 属性选择器 = class 选择器 &gt; 伪元素 = 元素(类型)选择器 = 关系选择器 &gt; 通配符选择器 5 中类型：基本选择器、组合选择器、属性选择器、伪类选择器、伪元素选择器 1 基本选择器 选择器 示例 示例说明 .class （类选择器） .button 匹配 class 中包含 button 类的元素 #id （Id 选择器） #app 匹配 id 为 app 的元素 element （元素选择器） p 选择所有 p 元素 * （通配符选择器） * 匹配任何元素 2 组合选择器 选择器 示例 示例说明 a,b (多元素选择器) ul,ol 匹配 ul 元素或 ol 元素 a b （后代选择器） div p 匹配 div 元素所有后代元素中的 p 元素 a&gt;b (子元素选择器) div&gt;p 匹配 div 元素所有的直接子元素中的 p 元素 a+b （直接相邻兄弟元素） div+p 匹配 div 元素之后的相邻同级的 p 元素 a~b (普通兄弟元素) div~p 匹配 div 元素之后的同级的 p 元素，无论是否相邻 3 属性选择器 选择器 示例 示例说明 [attribute] 简单的属性选择器 [href][title] 选择同时带有 href 和 title 属性的元素 [attribute=value] 根据具体属性值选择 [href=&quot;www.betterjiang.com&quot;][title=&quot;刘振江博客&quot;] 选择 href 属性值为 www.betterjiang.com,并且 title 属性值为刘振江博客的所有元素 [attribute~=value] 包含 p[class~=”warning”] 选择 class 属性值中包含 warning 的 p 元素 [attribute^=value] 开头 img[src^=”person”] 选择 src 属性值以“person”开头的 img 元素 [attribute$=value] 结尾 img[src$=”.png”] 选择 src 属性值以”.png”结尾的 img 元素 [attribute*=value] 包含 img[src*=”dog”] 选择 src 属性值中包含子串”dog”的 img 元素 [attribute &#124; =value] 等于 或以 value- 开头 img[src &#124; =”dog”] 选择 src 属性值等于”dog”或以”dog-“开头的 img 元素 4 伪类选择器 状态伪类 选择器 示例 示例说明 :link a:link 选择未访问的链接 :visited a:visited 选择访问过的链接 :hover a:hover 鼠标悬浮于 a 元素的状态 :active a:active 选择被激活的链接 :focus input:focus 选择当前拥有输入焦点的 input 元素 :not(selector) :not(p) 选择不是 p 元素的元素 结构化伪类 选择器 示例 示例说明 :first - child p:first-child 选择 p 元素的第一个子元素 :first-of-type p:first-of-type 选择每个父元素是 p 元素的第一个 p 子元素 :last-child p:last-child 选择所有 p 元素的最后一个子元素 :last-of-type p:last-of-type 选择每个 p 元素是其母元素的最后一个 p 元素 :not(selector) :not(p) 选择所有 p 以外的元素 :nth-child(n) p:nth-child(2) 选择所有 p 元素的第二个子元素 :nth-last-child(n) p:nth-last-child(2) 选择所有 p 元素倒数的第二个子元素 :nth-last-of-type(n) p:nth-last-of-type(2) 选择所有 p 元素倒数的第二个为 p 的子元素 :nth-of-type(n) p:nth-of-type(2) 选择所有 p 元素第二个为 p 的子元素 :only-of-type p:only-of-type 选择所有仅有一个子元素为 p 的元素 :only-child p:only-child 选择所有仅有一个子元素的 p 元素 :target #news:target 选择当前活动#news 元素(点击 URL 包含锚的名字) 表单相关 选择器 示例 示例说明 :disabled input:disabled 选择所有禁用的表单元素 :enabled input:enabled 选择没有设置 disabled 属性的表单元素 :in-range input:in-range 选择在指定区域内的元素 :out-of-range input:out-of-range 选择不在指定区域内的元素 :valid input:valid 选择条件验证正确的表单元素 :invalid input:invalid 选择条件验证错误的表单元素 :required input:required 选择设置 required 属性的表单元素 :optional input:optional 选择没有 required 属性，即设置 optional 属性的表单元素 :read-only input:read-only 选择设置 readonly 只读属性的元素 :read-write input:read-write 选择处于编辑状态的元素；input，textarea 和设置 contenteditable 的 HTML 元素获取焦点时即处于编辑状态。 :checked input:checked 匹配被选中的 input 元素，input 元素包括 radio 和 checkbox :empty p:empty 匹配所有没有子元素的 p 元素 5 伪元素选择器 选择器 示例 示例说明 ::first-letter （首字母，仅用于块级元素） p::first-letter 匹配 p 元素的首字母 ::first-line （第一行，仅用于块级元素） p::first-line 匹配 p 元素的第一行文本 ::before (在元素之前插入生成内容，并设置其样式) h2::before { content:”@”, color: black } 在每个 h2 元素前插入一个黑色的@ ::after （在元素之后插入生成内容，并设置其样式） body::after {content:’The End’} 在 body 元素最后插入”The End“ 弹性盒子（Flexbox） 布局Flexbox 布局是 CSS3 中新增的布局模块，它改进了在容器中元素的对齐、方向、顺序，即使元素的尺寸是动态的，甚至是未知的。flex 容器的只要特征就是可以修改其内子容器的高、宽度，以在不同屏幕大小使用最佳方式填充可利用的空间。 flex 布局由父容器（flex container）和它内包含的项目（flex items）组成。 flex container（父容器） 属性 (6 个) 属性 说明 属性值 flex-direction 定义 主轴（main axis）方向 row &#124; row-reverse &#124; column &#124; column-reverse flex-wrap 项目在一条轴线上排不下，如何换行？ nowrap &#124; wrap &#124; wrap-reverse(第一行在下方) flex-flow flex-direction 和 flex-wrap 简写形式 &lt;flex-direction&gt; &#124;&#124; &lt;flex-wrap&gt; justify-content 项目在主轴上的对齐方式 flex-start &#124; flex-end &#124; center &#124; space-between &#124; space-around &#124; space-evenly align-items 项目在交叉轴（cross axis）上如何对齐 flex-start &#124; flex-end &#124; center &#124; baseline &#124; stretch align-content 多根轴线的对齐方式，如果项目只有一根轴线，该属性无效 flex-start &#124; flex-end &#124; center &#124; space-between &#124; space-around 项目（flex items）的属性 （6 个） 属性 说明 属性值 order 定义项目的排列顺序，默认为 0，数值越小，越靠前 &lt;integer&gt; flex-grow 项目的放大比例，如果有剩余空间。默认为 0 &lt;integer&gt; flex-shrink 项目的缩小比例，如果空间不足。默认为 1 flex-basis 在分配多余空间之前，项目占据主轴的空间大小。默认为 auto &lt;length&gt; &#124; auto flex flex-grow, flex-shrink, flex-basis 的简写 默认值为 0 1 auto [&lt;flex-grow&gt; &lt;flex-shrink&gt; &#124;&#124; &lt;flex-basis&gt;] &#124; none &#124; auto align-self 设置单独项目的对齐方式，可与其它项目不同。覆盖 align-items 属性 auto &#124; flex-start &#124; flex-end &#124; center &#124;baseline &#124; stretch 浮动、定位浮动 所有元素都可以浮动，且浮动元素会脱离文档流，但浮动元素依然位于父元素之内。浮动元素周围的外边距不会合并 浮动元素会生成一个块级框，不论这个元素本身是什么。 浮动元素的包含块就是其最近的块级祖先元素。 浮动元素左/右外边界不能超过其包含块的左/右内边界，浮动元素不可彼此重叠 当行内框与浮动元素重叠时，其边框、背景、内容都会在浮动元素 之上 当块级框与浮动元素重叠时，其边框、背景在浮动元素之下显示，而内容在浮动元素之上显示 clear属性会清楚浮动，h3&#123;clear:left&#125;，确保 h3 的左边没有浮动元素。其工作原理: **会增加元素的上外边距，使之最后落在浮动元素的下面，这实际上 会 忽略清除元素原先设置的上外边距。 **，所有要确保一个清除元素的顶端和一个浮动元素的底端之间有一定的空间，可以为浮动元素本身设置一个下外边距。 清除浮动为什么要清除浮动？因为 子元素浮动引起父元素的内部高度为 0（高度塌陷）。清除浮动方法： 清除浮动方法 优势 劣势 设置父元素高度 极其简单 必须要知道父元素高度 在父元素中，追加一个空元素，设置 clear:both; 简单 添加无意义的空标签，破坏文档结构 设置父元素也浮动（因为 浮动元素会延伸，从而包含其所有的后代浮动元素） 简单，代码量少，没有结构和语义化问题 对后续元素有影响 为父元素设置 overflow 属性 hidden,或 auto （因为会触发BFC，从而实现清除） 简单，代码简洁 可能会无法显示要溢出的元素 【最优解】 使用伪类，生成空内容的方式 .clearfinx:&#123;content: &#39;&#39;; dislay: block; clear:both;&#125; 不破坏文档结构，无副作用 代码量多 元素的定位 （position） static （默认值）：元素在文档常规流中当前的布局位置，此时 top,right,z-index等属性无效。 relative（相对定位）：相对于自身在文档流中所处的位置进行定位，参照物为自身，且仍处于文档流中，原先占有的空间仍保留，常作为绝对定位的参照物 absolute（绝对定位）： 元素脱离文档流，不会为元素留空间，后面的元素会其原来的位置布局。其参照物是第一个属性不是 static 的祖先元素。绝对定位之后会产生块级框，通过top,left等属性进行定位 fixed（固定定位）： 元素脱离文档流，定位参照物为屏幕视口，元素的位置在屏幕滚动时 不会改变。 sticky （粘性定位）： 元素根据正常文档流进行定位，然后相对它的最近滚动祖先进行偏移。一个 sticky 元素会”固定“在离它最近的一个拥有”滚动机制“的祖先上（及祖先的 overflow 是 hidden,scroll,auto,overlay）。**简单说，祖先元素在滚动时，某个元素在 距其祖先元素的距离 达到 sticky 定位的要求时， 就会固定，不在滚动了 ** BFC(块格式化上下文)BFC（Block Formatting Context）,它是一个独立的渲染区域，是块级盒子（Block box）的布局过程发生的区域，它规定了内部的 Block Box 如何布局，并且于这个区域外部毫不相干。 盒子（Box）Box 是 CSS 布局的对象和基本单位，即一个页面是由多个盒子组成的。元素的类型和 display 属性，决定了盒子的类型。不同的盒子，会参与不同的 Formatting Context（格式化上下文） block-level box (块级盒子): display 属性值为 block,list-item,table的元素，会生成块级盒子，参与 block formatting context; inline-level box (行内盒子)： display 属性值为 inline,inline-block,inline-table的元素，会生成行内盒子，参与 inline formatting context; 格式化上下文 （Formatting Context）它是页面中的一块渲染区域，并且由一套渲染规则，决定了其内子元素如何定位、以及和其他元素的关系和相互作用。 最常见的 由 BFC（Block Formatting Context） 和 IFC （Inline Formatting Context） BFC 布局规则 内部的 块级盒子 会在垂直方向，一个接一个的排列 同一 BFC 内的 两个相邻 的 块级盒子 的 margin 会发生重叠，取最大值 每个盒子（块级或行内）的 左/右 外边届 与 其包含块 的 左/右 内边距 相接触，浮动元素也是如此。 BFC 区域 不会 与 浮动元素 重叠，即 浮动元素 外边距不 重叠 BFC 是一个独立容器，容器内的子元素不会影响到外面的元素，反之亦然 计算 BFC 的高度，浮动元素也参与计算 通过 设置overflow属性，创建了 BFC，并计算高度，浮动元素参与计算，达到清除浮动的效果。 创建 BFC 根元素 浮动元素 （元素的 float属性值不为 none） 绝对定位元素 （元素的 position 属性值 为 absolute或fixed） 行内块元素 (display : inline-block) overflow值不为visible的块元素 弹性元素 （display:flex元素 的 直接子元素）","categories":[{"name":"技术总结","slug":"技术总结","permalink":"https://better-jiang.github.io/categories/%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%93/"}],"tags":[{"name":"css","slug":"css","permalink":"https://better-jiang.github.io/tags/css/"},{"name":"面试","slug":"面试","permalink":"https://better-jiang.github.io/tags/%E9%9D%A2%E8%AF%95/"}]},{"title":"ES6常用知识点梳理","slug":"ES6常用知识点梳理","date":"2020-05-21T12:53:31.000Z","updated":"2023-02-03T12:14:22.421Z","comments":true,"path":"2020/05/21/ES6常用知识点梳理/","link":"","permalink":"https://better-jiang.github.io/2020/05/21/ES6%E5%B8%B8%E7%94%A8%E7%9F%A5%E8%AF%86%E7%82%B9%E6%A2%B3%E7%90%86/","excerpt":"","text":"let &amp; constlet let 声明的变量只在let命令所在的代码块内有效。 for 循环 let 声明的 i，当前 i 只在本轮循环有效 let **不存在变量声明***，变量一定要在声明后使用，否则报错 let不可以在相同作用域内重复声明同一个变量 const const用来声明常量，一旦声明，其值就不可改变。这意味着，const一旦声明常量，就必须立即初始化，不能以后赋值。只声明不赋值不报错 对于对象而已，常量存储的是一个地址，指向一个对象。地址不可变，但对象本身是可变的。 想将对象冻结，应该用const p = Object.freeze(obj) 解构赋值从对象和对象中提取值，来对变量进行赋值，称之为解构（Destructuring） 数组的解构赋值 只要模组数据结构具有 Iterator 接口（可遍历），就可以采用数组形式的解构赋值 如果解构不成功，变量的值就等于undefined 也可以 不完全解构 1234567891011121314let [, , c] = [1, 2, 4];c; // 4let [head, ...tail] = [1, 2, 3, 4];head; // 1tail; // [2,3,4]let [a, b] = [1];a; // 1b; // undefinedlet [a, [b], c] = [1, [2, 3], 4];b; // 2c; // 4 指定默认值 ES6 使用 ===判断一个位置是否有值。当一个数组成员=== undefined，默认值才生效，是null则不会生效。 如果默认值是一个表达式，则该表达式是惰性求值的，在用到时才会求值。 默认值可以引用解构赋值的其他已经声明的变量。 123456789let [x = 1] = []; // 默认值x; // 1let [x = 1, y = 2, z = 3] = [12, undefined, null]; // null 默认值不会生效y; // 2z; // nulllet [x = 1, y = x] = [];x; // 1y; // 1 对象的解构赋值 变量必须同属性同名，才能取到正确的值；没有同名属性，为 undefined 如果变量名与属性名不同，则必须是以下形式。实际上 对象解构赋值的内部机制，是先找到同名属性，然后再赋值给对应的变量，即（被赋值的是后者，而非前者） 1234567let &#123; a: b &#125; = &#123; a: &quot;aaa&quot;, b: &quot;bbbb&quot; &#125;;b; // &#x27;aaa&#x27;a; // error: a is not definedlet &#123; a, b &#125; = &#123; a: &quot;aaaa&quot;, b: &quot;bbbb&quot; &#125;; // &#123;a:a, b:b&#125; = &#123;a:&#x27;aaaa&#x27;, b:&#x27;bbbbb&#x27;&#125;a; // &#x27;aaaa&#x27;b; // &#x27;bbbb&#x27; 指定默认值 默认值生效的条件，对象的属性严格等于 undefined 如果解构失败，变量的值等于 undefined 123let &#123; x = 3, y = 4 &#125; = &#123; x: undefined &#125;;x; // 3y; // 4 字符串的解构赋值字符串的解构赋值，此时字符串被转换成一个类数组对象，有length属性 1234let [a, b, c] = &quot;abc&quot;;a; // alet &#123; length: len &#125; = &quot;abc&quot;;len; // 3 布尔值、数值的解构赋值解构赋值的规则： 只要等号右边不是对象，就将其转换为对象。布尔值，数值被转换为对应的包装对象 1234let &#123; toString: s &#125; = 123;s.name; // &#x27;toSting&#x27;let &#123; valueOf: v &#125; = true;v.name; // &#x27;valueOf&#x27; 函数参数的解构赋值 参数也可以解构赋值，通过解构得到各变量的值 12345// 函数参数 不是 一个数值，而是通过解构得到的变量 x, yfunction add([x, y]) &#123; return x + y;&#125;add([1, 2]); 函数参数的 默认值函数参数是对象， 2 种写法，不同结果 为 x 和 y 指定默认值 1234567function fn(&#123; x = 0, y = 0 &#125; = &#123;&#125;) &#123; return [x, y];&#125;fn(&#123; x: 3, y: 8 &#125;); // [3, 8]fn(&#123; x: 3 &#125;); // [3, 0]fn(&#123;&#125;); // [0,0]fn(); // [0, 0] 为 参数 指定 默认值,而非为变量 x、y。 1234567function fn(&#123; x, y &#125; = &#123; x: 0, y: 0 &#125;) &#123; return [x, y];&#125;console.log(fn(&#123; x: 3, y: 8 &#125;)); // [3, 8]console.log(fn(&#123; x: 3 &#125;)); // [3, undefined]console.log(fn(&#123;&#125;)); // [undefined,undefined]console.log(fn()); // [0, 0] 数组的扩展 Array.from(): 将 类数组对象（NodeList，arguments 对象）和可遍历对象（Set, Map, String）转换为数组。例外 扩展运算符(...)也可以将某些数据结构转换为数组 12345678910// NodeListlet links = document.querySelectorAll(&quot;a&quot;);let arrayLinks = Array.from(as);function fn() &#123; var args = [...arguments];&#125;// ES 5 方法let arr = [].slice.call(arguments); Array.from()还可接受第二各个参数，作用类似数组的 map 方法，用来对每个数组元素进行处理。 12345678Array.from([1, 2, 3], (x) =&gt; x + 1); // [2, 3, 4]// 取出DOM节点内容let spans = document.querySelectorAll(&quot;span&quot;);// es5Array.prototype.map.call(spans, (s) =&gt; s.textContent);// es6Array.form(spans, (s) =&gt; s.textContent); Array.of(),总是返回参数值组成的数组，没有参数，返回空数组 find(callback),findIndex(callback), 参数是一个回调函数。比indexOf方法的优势：都可以发现NaN 12[NaN].indexOf(NaN); // -1[1, 2, NaN].findIndex((s) =&gt; Object.is(s, NaN)); // 2 fill(value[, start[, end]]),使用给定值填充数组，数组中已有的元素会被抹去。 entires(),keys(),values()，都会返回一个遍历器对象，可用于for...of循环遍历 includes(valueToFind[, fromIndex]),返回一个布尔值，表示数组是否包含给定的值 函数的扩展 函数参数可设置默认值 非尾部的参数设置默认值，实际上这个参数是无法省略的。通常情况下，定义了默认值的参数应该是函数的为参数 函数的length属性是预期传入的参数个数，不包含指定了默认值的参数 rest参数，fn（a, b, ...rest）,用于获取函数的多余参数,其变量是一个数组。rest 参数之后不能再有其他参数，否则报错，函数的length属性不包括 rest 参数 扩展运算符(...),将一个数组转换为逗号分隔的参数序列。只要具有 Iterator 接口的对象，都可以使用 123Math.max(...[1, 2, 3]); // es6Math.max(1, 2, 3); // es5[...&quot;abcd&quot;]; // [&#x27;a&#x27;,&#x27;b&#x27;,&#x27;c&#x27;,&#x27;d&#x27;] // Generator 函数返回 一个遍历器对象let go = function*() {yield 1;yield 2;yield 3;}[…go()] // [1,2,3] 123456789101112131415161718192021##### 箭头函数- 箭头函数不会创建自己的 this，它只会从自己的**作用域链**的上一层继承 this- `arguments`在箭头函数内部是不存在的，它指向**外层函数的对应变量**。可使用`rest`参数代替- 由于箭头函数没有自己的 this，所以不可以当构造函数，也不能用`call()`,`apply()`,`bind()`方法取改变 this 的值```jsfunction foo(e) &#123;return (d) =&gt; &#123; return (c) =&gt; &#123; return (a, b) =&gt; &#123; console.log(&quot;id: &quot;, this.id); console.log(&quot;arguments: &quot;, arguments); &#125;; &#125;;&#125;;&#125;foo.call(&#123; id: 123 &#125;, &quot;e&quot;)(&quot;d&quot;)(&quot;c&quot;)(&quot;a&quot;, &quot;b&quot;);// id: 123// arguments: [&#x27;e&#x27;] 尾调用优化函数调用会在内存中形成一个”调用记录”，即调用帧（call frame），保存着调用位置和内部变量等信息。例如，在函数 A 中调用函数 B，则在 A 的调用帧上方，形成 B 的调用帧，等到函数 B 运行结束，将结果返回到 A，B 的调用帧才移除。如果函数 B 内还调用了函数 C，那就还有一个 C 的调用帧，在 B 上。依此类推，所以的调用帧就形成了一个调用栈（call stack） 尾调用由于是函数的最后一步操作，所以不在需要保留外层函数的调用帧，因为调用位置、内部变量等信息不会再用到了，所以可以直接将内层函数的调用帧取代外层函数 1234567let g = (m, n) =&gt; m + n;function f() &#123; let m = 1; let n = 2; return g(m, n);&#125;f(); 如果函数 g 不是尾调用，函数 f 就要保存内部的变量 m 和 n 的值，g 的调用位置等信息。但是由于调用 g 之后，函数 f 就结束了，所以执行到最后一步，完全可以删除 f()的调用帧，只保留 g(3)的调用帧。如下动图 尾递归函数调用自身称为递归。递归因为要同时保存成百上千个调用帧，非常消耗内存，且很容易发生栈溢出（stack overflow）。但是，如果尾调用自身（尾递归）的话，只需保存一个调用帧，则永远不会发生栈溢出错误 12345678function factorial(n) &#123; if (n === 1) &#123; return 1; &#125; else &#123; return n * factorial(n - 1); &#125;&#125;factorial(5); 上述阶乘函数，最多需要保存 n 个调用帧，O(n)。如果改为 尾递归的话，则需保存 一个调用帧,，O(1) 123456789function factorial2(n, total) &#123; &quot;use strict&quot;; if (n === 1) &#123; return total; &#125; else &#123; return factorial2(n - 1, n * total); &#125;&#125;factorial2(5, 1); 柯里化实现尾递归需要改写递归函数，就是要把所有用的的内部变量改写成函数的参数。但是这样做后，函数的作用就不太直观了，很难理解，计算 5 的阶乘，为什么要传参数 5 和 1。 柯里化是函数编程中一个概念，将多个参数的函数转换成单个参数的形式 1234567function currying(fn, n) &#123; return function (m) &#123; return fn.call(this, m, n); &#125;;&#125;let factorial3 = currying(factorial2, 1);factorial3(5); 对象的扩展 ES6 允许在对象中只写属性名，不写属性名，此时属性值等于属性名所代表的变量 12345let person = &#123; name: &quot;jiang&quot;, age, // 等同于 age:age hello() &#123;&#125;, // 等同于 hello: function() &#123;&#125;&#125;; 在用字面量定义对象时，可使用表达式作为对象的属性名、方法名 1234let person = &#123; [&quot;n&quot; + &quot;ame&quot;]: &quot;jiang&quot;, [&quot;h&quot; + &quot;ello&quot;]() &#123;&#125;, // 等同于 hello: function() &#123;&#125;&#125;; Object.is(value1, vaule2),比较两个值是否严格相等，除两点不同之外。 +0不等于-0 NaN等于自身 Object.assign(target, ...sources),将所有可枚举的属性的值 从一个或多个源对象 复制到目标对象。返回目标对象。 如果有同名属性，则后面的属性会覆盖前面的属性 只复制自身可枚举的属性，不可枚举的属性、继承的属性不会被复制 可用于处理数组，但会将其视为对象 12Object.assign([1, 2, 3, 4, 5], [7, 8]);// [7,8,3,4,5] 属性的描述对象Object.getOwnPropertyDescriptor(obj, prop)获取对象上一个自有属性的描述对象 1234567let obj = &#123; a: 123, b: 345,&#125;;let descriptor = Object.getOwnPropertyDescriptor(obj, &quot;a&quot;);console.log(descriptor);// &#123;value: 123, writable: true, enumerable: true, configurable: true&#125; 属性的遍历ES6 可遍历对象的属性的方法 for in 循环遍历对象的 自身的 和 继承的可枚举 属性 Object.keys(obj), 返回一个数组，包含 对象自身的可枚举属性 Object.getOwnPropertyNames(obj),返回一个数组，包含 对象自身所有属性（包括不可枚举的属性） Object.getOwnPrropertySymbols(obj),返回一个数组，包含 对象自身的所有 Symbol 属性 __proto__属性 &amp; Object.setPrototypeOf() &amp; Object.getPrototypeOf() &amp; Object.create() __proto__属性是浏览器内，用来读取和设置当前对象的 原型（prototype）对象。因为只要浏览器内部署该属性，其他环境不一定支持，可使用Object.create() (生成 原型对象),Object.getPrototypeOf() （读取 原型对象），Object.setPrototypeOf() (设置 原型对象)3 个方法替代。在实际上，__proto__调用的是object.prototype.__proto__ Object.create(prototype[, propertiesObject]),使用指定的原型对象 prototype 及其属性 propertiesObject 去创建一个新的对象。具体 3 个步骤：创建一个新对象，设置新对象的原型对象，为新对象扩展新属性。 1let obj = Object.create(Object.prototype); // 等同于 let obj = &#123;&#125; 创建要给空对象，空对象的原型是 Object.prototype (即 obj.__proto__ === Object.prototype) Object.getPrototypeOf(obj),返回指定对象的原型对象 （内部 [[Prototype]]属性的值） 1Object.prototype === Object.getPrototypeOf(&#123;&#125;); // true Object.setPrototypeOf(obj, prototype),设置指定对象的原型 为 另一个对象或 null. 1234let obj = &#123; a: 1 &#125;;console.log(Object.getPrototypeOf(obj) === Object.prototype); // trueObject.setPrototypeOf(obj, null);console.log(Object.getPrototypeOf(obj) === null); // true 字符串的扩展 includes(searchString[, fromIndex]),一个字符串是否包含另一个字符串，返回 Boolean。 startWith()，endWith(),判断一个字符串是否在另一个字符头部或尾部 repeat(count),返回一个重复count的 新字符串 padStart(len[, padString]),padStart(len[, padString]),字符串的补全功能。padString默认为 空格&quot; &quot; 12&quot;abcd&quot;, padEnd(5); // &#x27;abcd &#x27;&quot;abc&quot;.padStart(5, &quot;01234&quot;); // &#x27;01abc&#x27; Iterator &amp; for … of 循环遍历器(Iterator)是以中接口，为不同的数据结构提供统一从访问机制。任何数据结构，只要部署Iterator接口,就可以完成遍历操作（for..of）依次处理该数据结构的所有成员。 要想成为可迭代的对象，该对象（或其原型链中的任意对象）必须有实现Iterator接口的方法，通常使用常量Symbol.iterator访问该属性 内置可迭代对象String,Array,Map,Set以及 类数组的对象都是内置可迭代对象，因为它们的原型对象都有一个Symbol.iterator方法。 返回一个符合有 next()的对象 具体内容。 Set &amp; MapSet Set 类似于数组，但其成员的值是唯一的，无论是原始值或是对象引用。 Set 本身就是一个构造函数，可接受一个可迭代对象作为参数，可迭代对象中所有元素将不重复地被添加到新的 Set 实例中。 向 Set 添加值时，不会发生类型转换。Set 内部判断两个值是否相等，使用类似于全等运算符(===),NaN 之间视为相同的值。 Set 实例 - 操作方法 add(value): 末尾添加某个值，返回 Set delete(value): 移除 Set 中与参数相等的成员，返回一个布尔值。 has(value): 返回一个布尔值，表示参数是否为 Set 的成员 clear(): 移除 Set 中所有成员 Set 实例 - 遍历方法 keys(): 返回一个 键名 的迭代器 values(): 返回一个 键值 的迭代器 entries(): 返回一个 键值对 的迭代器 forEach(): 使用回调函数遍历每个成员，按照插入顺序 Set - 使用场景 去重 1234567891011121314151617181920212223242526var arr = [2, 4, 3, 3, 4, 2, 3, 254, 234, 4];// ES6 使用Set 去重function unique3(arr) &#123; return [...new Set(arr)];&#125;// ES5 过滤掉 下标不同 元素function unique(arr) &#123; return arr.filter((item, index, self) =&gt; &#123; return self.indexOf(item) == index; &#125;);&#125;// ES5 使用 reduce方法，遍历数组，只要不在新数组中的元素 才 添加function unique2(arr) &#123; return arr.reduce((pre, cur) =&gt; &#123; if (!pre.includes(cur)) &#123; pre.push(cur); &#125; return pre; &#125;, []);&#125;console.log(unique(arr));console.log(unique2(arr));console.log(unique3(arr)); 并集 1234function union(set1, set2) &#123; return new Set([...set1, ...set2]);&#125;console.log(union(new Set([1, 2, 3]), new Set([2, 3, 4, 5]))); // [1,2,3,4,5] 交集 1234function intersect(set1, set2) &#123; return new Set([...set1].filter((x) =&gt; set2.has(x)));&#125;console.log(intersect(new Set([1, 2, 3]), new Set([2, 3, 4, 5]))); // [2,3] 差集 1234function difference(set1, set2) &#123; return new Set([...set1].filter((x) =&gt; !set2.has(x)));&#125;console.log(difference(new Set([1, 2, 3]), new Set([2, 3, 4, 5]))); // [1] Map在 JavaScript 的对象本质上是键值对的集合（Hash 结构），但是只能 String、Symbol 类型作为键，所以使用起来有很大限制。 Map 作为构造函数，可接受要给数组或其他iterable对象。例如 new Map([[&#39;name&#39;,&#39;lzj&#39;],[&#39;age&#39;, 25]]) Map 的键实际上是跟内存地址绑定的，只要内存地址不一样，就视为两个键。键的比较是基于 sameValueZero算法, NaN与NaN相等 ES6 新增的 Map 结构，也类似于对象，是键值对的集合，但是键的类型没有限制，可以是任何类型的值，包括对象。 Map 和 Object 的比较 Map Object 键的类型 任意值，包括函数、对象或任何基本类型 String 或 Symbol 键的顺序 Map 中的 key 是有序的。因此，迭代时，以插入的顺序返回 无序的 Size Map 键值对个数可以通过size属性获取 需手动计算 迭代 Map 是 iterable（可迭代的），所以可直接被迭代 需手动获取它的键，然后迭代 性能 在 频繁 增、删键值对的场景下 表现更好 未作优化 Map 实例 - 操作方法 set(key, value): 设置 Map 对象中键的值，返回该 Map 对象。如果 key 已经有值，则键值被更新，否则生成新的键。 get(key): 读取 key 对应的键值，如果不存在，返回 undefined has(key): 返回一个布尔值，表示 Map 对象是否包含该键 Map 实例 - 遍历方法 entries(): 返回所有成员的迭代器，[key, vlaue]数组 keys(): 返回键名的迭代器 values(): 返回值的迭代器 forEach(): 使用回调函数遍历每个成员 Map 与 其他数据结构的转换 Map &amp; Object (所有键都是字符串的对象) 123456789101112131415161718function strMapToObject(strMap) &#123; let obj = Object.create(null); // 原型为null的 空对象 strMap.forEach((v, k) =&gt; &#123; obj[k] = v; &#125;); return obj;&#125;function objectToStrMap(obj) &#123; let strMap = new Map(); for (let k of Object.keys(obj)) &#123; strMap.set(k, obj[k]); &#125; return strMap;&#125;console.log(strMapToObject(myMap));console.log(objectToStrMap(&#123; name: &quot;jiang&quot;, age: 25 &#125;)); Map &amp; Array 12345678// 数组作为参数传入Map构造函数let myMap = new Map([ [&quot;name&quot;, &quot;lzj&quot;], [&quot;age&quot;, 25],]);// 使用扩展运算符let myArray = [...myMap]; Map（键都是字符串） &amp; JSON 1234567891011121314151617181920212223242526function strMapToObject(strMap) &#123; let obj = Object.create(null); // 原型为null的 空对象 strMap.forEach((v, k) =&gt; &#123; obj[k] = v; &#125;); return obj;&#125;function objectToStrMap(obj) &#123; let strMap = new Map(); for (let k of Object.keys(obj)) &#123; strMap.set(k, obj[k]); &#125; return strMap;&#125;// Map 转 JSON， Map 键都是字符串function strMapToJSON(strMap) &#123; return JSON.stringify(strMapToObject(strMap));&#125;// JSON 转 Mapfunction jsonToStrMap(jsonStr) &#123; return objectToStrMap(JSON.parse(jsonStr));&#125;console.log(jsonToStrMap(&#x27;&#123;&quot;name&quot;:&quot;lzj&quot;,&quot;age&quot;:25&#125;&#x27;)); PromisePromise，是一个对象。用来传递异步操作的消息。它代表了 某个未来才知道结果的事件，并为这个事件提供了统一的 API，可进一步处理该事件。 用法通过 Promise 构造函数生成 Promise 实例，实例生成后，可以用then方法指定 Resolved状态和Rejected状态的回调函数。 12345678910new Promise((resolve, reject) =&gt; &#123; setTimeout(resolve, 1000, &quot;done!&quot;);&#125;).then( (data) =&gt; &#123; console.log(&quot;Resolved&gt;&gt;&quot;, data); &#125;, (error) =&gt; &#123; console.log(&quot;Rejected&gt;&gt;&quot;, error); &#125;); 如果调用 resolve 函数和 reject 函数时带有参数，那么这些参数就会被传递给回调函数。 reject 函数的参数通常 是 Error 对象的实例，表示抛出错误。 resolve 函数的参数除了正常想传递的值外，还可以是另一个 Promise 实例 12345678910111213141516let p1 = new Promise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; reject(new Error(&quot;fail&quot;)); &#125;, 3000);&#125;);let p2 = new Promise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; resolve(p1); &#125;, 1000);&#125;);p2.then( (resolve) =&gt; console.log(resolve), (error) =&gt; console.log(error));// 3S 后// Error: fail p1 是一个 Promise，3s 后状态改为 Rejected。p2 的状态由 p1 决定，1s 后,p2 调用resolve(p1)，此时 p1 的状态还没发生改变，因此 p2 状态也不会变，又过了 2s，p1 变为 Rejectd，p2 也跟着变为 Rejected Promise.all(iterable)Promise.all 方法将多个 Promise 实例包装成一个 Promise 实例。例如let p = Promise.all[p1,p2,p3]。 p 的状态由 p1, p2, p3 决定，2 中情况： 只有 p1, p2, p3 的状态都变成 Resolved， p 的状态才变成 Resolved，此时 p1,p2,p3 的返回值组成一个数组，传递给 p 的回调函数。 只要 p1,p2,p3 中任意一个的状态变成 Rejected, p 的状态就变成 Rejected，此时第一个被 Rejected 的实例的返回值会传递给 p 的回调函数。 Promise.race(iterable)Promise.race 方法同样是将多个 Promise 实例包装成一个新的 Promise 实例。例如 let p = Promise.race([p1,p2,p3]),p1,p2,p3 之间是竞争关系,z 只要有一个实例的状态率先发生改变，p 的状态就跟着改变。那个率先改变的 Promise 实例的返回值，就传递给 p 的回调函数。 ClassES6 中的 Class 可以看作是一个语法糖，它只 ES5 的构造函数的一层包装，新的 class 写法只是让对象原型的写法更加清晰，更像面向对象的语法罢了。 “类”的数据类型就是函数，”类”本身就指向构造函数 “类”的所有方法都定义在“类”的 prototype 属性上，同 ES5 构造函数的 prototype 属性一致。 在“类”的实例上调用方法，其实就是调用原型上的方法 “类”内定义的所有方法都是不可枚举的，此点同 ES5 不一致。 12345678910111213141516class B &#123; constructor(x, y) &#123; this.x = x; this.y = y; &#125; toString() &#123; return `$&#123;this.x&#125;, $&#123;this.y&#125;`; &#125;&#125;let b = new B();typeof B; // &quot;function&quot;B.prototype.constructor === B; // trueb.constructor === B.prototype.constructor; // trueObject.keys(B.prototype); // []Object.getOwnPropertyNames(B.prototype)[(&quot;constructor&quot;, &quot;toString&quot;)]; 一个类必须有 constructor 方法，如果没有显示声明，则默认添加一个空的 constructor 方法。constructor 方法默认返回实例对象（即 this），也可以指定返回另外一个对象 类不存在变量提升 类内部默认就是严格模式 Class 的 继承Class 之间通过extends关键字实现继承。 子类必须在 constructor 方法中调用super方法,否则新建实例时报错。只是因为:子类没有自己家的 this 的对象，而是继承了父类的 this 对象，然后再对其修改 只要调用 super 方法才能返回父类的实例（this），之后子类才可以使用 this，所有必须要调用 super 方法，且最后放于子类构造函数首行，之后就可以使用 this 子类中 super关键字代表 父类实例 类的 prototype 属性 和 __proto__属性ES5 多数浏览器中，每个对象都有__proto__属性，指向对应的构造函数的 prototype 属性。Class 作为构造函数的语法糖，同时具有__proto__和prototype属性，因此同时存在两条继承链 子类的__proto__属性表示构造函数的继承，总指向父类 子类prototype属性的__proto__属性表示方法的继承，总指向父类的prototype属性. 这是因为类的继承模式如下： 1234567class A &#123;&#125;class B extends A &#123;&#125;// 实现模式Object.setPrototypeOf(B.prototype, A.prototype); // 等同于 B.prototype.__proto__ === A.prototypeObject.setPrototypeOf(B, A); // 等同于 B.__proto__B.__proto__ === A; // trueB.prototype.__proto__ === A.prototype; // true","categories":[{"name":"技术总结","slug":"技术总结","permalink":"https://better-jiang.github.io/categories/%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%93/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://better-jiang.github.io/tags/javascript/"},{"name":"面试","slug":"面试","permalink":"https://better-jiang.github.io/tags/%E9%9D%A2%E8%AF%95/"}]},{"title":"计划与止损","slug":"计划与止损","date":"2020-05-19T14:48:33.000Z","updated":"2023-02-03T12:14:22.421Z","comments":true,"path":"2020/05/19/计划与止损/","link":"","permalink":"https://better-jiang.github.io/2020/05/19/%E8%AE%A1%E5%88%92%E4%B8%8E%E6%AD%A2%E6%8D%9F/","excerpt":"","text":"本计划昨晚就该写此短文的，可一来由于犯困，想去早点上床睡觉，毕竟，有困意对我来说 似乎意义重点，如果借此能好好睡一觉，是难得好事。二来心中早有不写打算，它 费神费力，也 较费时间，要花费2个小时，写出来的东西，无条理，没文采，自己其实是瞧不上的。三是 没人监督，更无眼前好处，选择不写实属正常之举，去写似乎是反人性的，鬼知道它会带来什么溢出。依次缘由，也就没去完成该写作计划，并且心中无愧，一切正常。 但是，现在回想，昨天的决定并非可憎可恶，但却白白浪费掉了22:40之后近1个小时的时间，它是可以去写该文的，而非在厕所用手机刷知乎、虎嗅和新闻。更可气的，厕所玩完手机之后，宝贵的困意没了，未能早早入睡，依然拖至12点以后。早知如此，还不如按计划，去完成写作呢？ 如果没有真实且足够多的利好，就老老实实按计划行事吧有计划，却因想象中的利好，临时变卦，结果事与愿违，反倒不如老实，死板的按计划行事。人善变，且容易受影响，相反能恪守计划，一条一条的去按计划行事反而十分按做。这不就证明，事前做好计划，事中能雷打不动的按计划去做，事后在来反思总结得失的方法论，对我而言，是有用有益的。它是爱幻想，善变，有选择困难，容易陷入纠结，且不够沉稳内敛，不能脚踏实地的我的人生解药。**做好计划，并一步步完成计划就好了，不用幻想，也无需改变，更不需去纠结、选择了，从此我的人生虽说没有出乎意料、波澜壮阔，但收获轻松安稳，依旧可爱 **。因为，只要按计划一步一步，就能走终点，且此种心知肚明，确信之感，极其美妙。对我而言，人生中，除了确定会死外，任何事情，都是无把握的，那种不确定性并非我要，常常令我抓狂。 有止损之意，就果断止损做了错事，千万不要就此一错再错，止损不难，且是有用。例如，下载LOL并开了局 大乱斗，饮料、辣条已买，且大吃起来，正在熬夜看片，时间来到3点。已经做了错事，当时并非心安理得，时常会冒出停下的 想法，但也有另一种想法，大乱斗开都开了，不玩可惜，饮料辣条买都买了，也吃了部分，不吃完可惜，都已经熬夜至3点，就算现在去睡，也于事无补，机会难得，狠心熬至天明。对此，我还有一套歪理，只有损失过大，打击过深，自我反思才越深刻，越痛苦，越难忘，日后从而才越有动力去蜕变，并在松懈时，能想起损失和痛苦，鞭策自我。可日后的种种证明。痛苦、喜悦、挫败、失落、惊奇之感、都很容易遗忘。过去的就是过去了，已是定局。人就是在为未来活着，因为那里一切未知，局势未定，充满变数，人们有希望，有幻想，并且有机会去实现 其实止损没啥大不了，做错事也并非洪水猛兽，该了就好，不用背上过多的心理负担。游戏玩了就玩了呗，现在关掉很容易；饮料辣条没吃完，现在扔了就行，反正不值钱；3点睡觉，8点醒，依旧能睡5个小时，无碍于二天的工作、学习。 人非圣贤，孰能无过，有则改之。这不，即使今天写此文，也不晚呢，除了自己，没人知道，对于其他人，它就是昨晚写的。原来很多事，我都有机会和能力挽回的。","categories":[{"name":"随笔感悟","slug":"随笔感悟","permalink":"https://better-jiang.github.io/categories/%E9%9A%8F%E7%AC%94%E6%84%9F%E6%82%9F/"}],"tags":[]},{"title":" Vuex知识点梳理","slug":"Vuex知识点梳理","date":"2020-05-17T22:35:29.000Z","updated":"2023-02-03T12:14:22.421Z","comments":true,"path":"2020/05/18/Vuex知识点梳理/","link":"","permalink":"https://better-jiang.github.io/2020/05/18/Vuex%E7%9F%A5%E8%AF%86%E7%82%B9%E6%A2%B3%E7%90%86/","excerpt":"","text":"Vuex 是专门为 vue.js 应用程序开发的状态管理模式，它采用集中式存储管理应用的所有组件的状态，并以相应的规则保证状态以一种可预测的方式发生变化。 基本概念每一个 Vuex 应用的核心就是store（仓库），它是一个容器，包含着应用中大部分的 state（状态）。其有 2 点 不同于单纯的全局对象： store 中的 state 响应式的，当 Vue 组件从 store 中读取 state （状态）的时候，若 store 中 state（状态） 发生变化，相应的组件也会得到更新 不能直接改变 store 中的 state（状态）。唯一途径就是*显示地 commit （提交） mutation 12345678910111213import Vue from &quot;vue&quot;;import Vuex from &quot;vuex&quot;;const store = new Vuex.Store(&#123; state: &#123; count: 0, &#125;, mutations: &#123; increment(state) &#123; state.count++; &#125;, &#125;,&#125;); StateVuex 使用单一状态树，用一个对象包含全部的应用层级状态。每个应用仅包含一个 store 实例。 在 Vue 组件中获取 Vuex 状态由于 Vuex 的状态存储是响应式，从 store 实例中读取状态最简单方法：在就算属性中返回某个状态 Vuex 通过store选项，可将 store 实例 从根组件”注入”到每一个子组件中。之后子组件就能通过this.$store访问到 store 实例。 123456789101112131415161718192021222324import Vue from &quot;vue&quot;;import Vuex from &quot;vuex&quot;;Vue.use(Vuex);const sotre = new Vuex.Store(&#123; modules: &#123; cart, product, &#125;, // data state: &#123;&#125;, // computed properties getters: &#123;&#125;, actions, // update mutations: &#123;&#125;,&#125;);new Vue(&#123; router, store, render: (h) =&gt; h(App),&#125;).$mount(&quot;#app&quot;); mapState 辅助函数当一个组件需要获取多个状态时，将这些状态都声明为计算属性会重复冗余。mapState辅助函数可帮助创建计算属性,并返回 store 中的状态。 123456789101112131415161718// 在单独构建的版本中辅助函数为 Vuex.mapStateimport &#123; mapState &#125; from &quot;vuex&quot;;export default &#123; // ... computed: mapState(&#123; // 箭头函数可使代码更简练 count: (state) =&gt; state.count, // 传字符串参数 &#x27;count&#x27; 等同于 `state =&gt; state.count` countAlias: &quot;count&quot;, // 为了能够使用 `this` 获取局部状态，必须使用常规函数 countPlusLocalState(state) &#123; return state.count + this.localCount; &#125;, &#125;),&#125;; GetterVuex 允许在 store 中 定义 “getter”,它可理解为 store 的计算属性。getter的返回值会根据它的依赖 被缓存起来，且只用当它的依赖发生了改变才会被重新计算。 在 store 上注册 getter，getter 方法 接受以下参数： state , 如果在模块中定义则为模块的局部状态 getters, 等同于 store.getters rootState, 全局 state 状态，即 store.state rootGetters，全局getter, 即 所有 getters 访问 getter 注册的 getter,会暴露 为store.getters对象，可 通过属性形式 访问 12345computed: &#123; doneTodosCount () &#123; return this.$store.getters.doneTodosCount &#125;&#125; 让 getter 返回一个函数，来 实现给 getter 传参，则可通过方法访问，且每次都会取进行调用，而不会缓存结果 123456789getters: &#123; // ... getTodoById: (state) =&gt; (id) =&gt; &#123; return state.todos.find((todo) =&gt; todo.id === id); &#125;;&#125;// 组件内 访问this.$store.getters.getTodoById(2); // -&gt; &#123; id: 2, text: &#x27;...&#x27;, done: false &#125; mapGetters 辅助函数该mapGetters辅助函数将 store 中的 getter 映射到局部计算属性 1234567891011121314151617import &#123; mapGetters &#125; from &quot;vuex&quot;;export default &#123; // ... computed: &#123; // 使用对象展开运算符将 getter 混入 computed 对象中 ...mapGetters([ &quot;doneTodosCount&quot;, &quot;anotherGetter&quot;, // ... ]), ...mapGetters(&#123; // 把 `this.doneCount` 映射为 `this.$store.getters.doneTodosCount` doneCount: &quot;doneTodosCount&quot;, // 重新命名 &#125;), &#125;,&#125;; Mutation更改 Vuex 的 store 中的状态的唯一方法就是提交 mutation。 mutation 非常类似于事件： 事件类型 （type）+ 处理函数（handler）。这个处理函数就是实际进行状态 更改的地方 。 mutation 必须时同步函数，因为要追踪 状态的改变，每一条 mutation 都会被记录，如果 mutation 是异步函数，devtools不知道什么时候回调函数被调用的。 注册 Mutation在 store 上注册 mutation， 处理函数 总是接受 2 个参数 state,如果 定义在模块中，则为模块的局部状态 payload,提交的载荷 12345678910const store = new Vuex.Store(&#123; state: &#123; count: 1, &#125;, mutations: &#123; increment(state, payload) &#123; state.count += payload.amount; &#125;, &#125;,&#125;); 组件内提交 Mutation 载荷方式：this.$store.commit(&#39;increment&#39;,&#123;amount: 10&#125;) 对象方式： this.$store.commit(&#123;type:&#39;increment&#39;, amount: 10&#125;) Action当需要处理异步操作，需要在 Action。它类似 与 Mutation，不同在于： Action 提交 的是 mutation, 而不是直接改变状态 Action 可以包含任意 异步操作 注册 Action在 store 上 注册 action，处理函数接受 2 个参数， context,一个与 store 实例具有相同方法和属性的对象，其包含以下属性： state, 等同于 store.state, 若在 模块中 则为局部状态 rootState, 全局的 state commit, 等同于 store.commit dispatch, 等同于 store.dispatch getters, 等同于 store.getters rootGetters, 全局的 getter payload,载荷 1234567891011121314151617const store = new Vuex.Store(&#123; state: &#123; count: 0, &#125;, mutations: &#123; increment(state) &#123; state.count++; &#125;, &#125;, actions: &#123; incrementAsync(&#123; commit &#125;) &#123; setTimeout(() =&gt; &#123; commit(&quot;increment&quot;); &#125;, 1000); &#125;, &#125;,&#125;); 组件内分发 Action 载荷方式：this.$store.dispatch(&#39;incrementAsync&#39;,&#123;amount: 10&#125;) 对象方式： this.$store.dispatch(&#123;type:&#39;incrementAsync&#39;, amount: 10&#125;) mapActions辅助函数mapActions 辅助函数将组件的 methods 映射为 store.dispatch 调用 12345678910111213141516import &#123; mapActions &#125; from &quot;vuex&quot;;export default &#123; // ... methods: &#123; ...mapActions([ &quot;increment&quot;, // 将 `this.increment()` 映射为 `this.$store.dispatch(&#x27;increment&#x27;)` // `mapActions` 也支持载荷： &quot;incrementBy&quot;, // 将 `this.incrementBy(amount)` 映射为 `this.$store.dispatch(&#x27;incrementBy&#x27;, amount)` ]), ...mapActions(&#123; add: &quot;increment&quot;, // 将 `this.add()` 映射为 `this.$store.dispatch(&#x27;increment&#x27;)` &#125;), &#125;,&#125;; 组合 ActionAction 通常是异步的，如何知道 action 什么时候结束？ 因为store.dispatch是可以处理被触发的 action 的处理函数 返回 的 Promise,并且store.dispatch仍旧返回 Promise。那么利用此，就可以组合多个 action，处理复杂的异步流程。 需要注意 一个store.dispatch在不同模块中可以触发多个 action 函数。只用当所有触发函数完成后，返回的 Promise 才会执行 注册 action，处理函数 返回 Promise 12345678910actions: &#123; actionA(&#123;commit&#125;) &#123; return new Promise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; commit(&#x27;someMutation&#x27;); resolve(); &#125;, 1000) &#125;) &#125;&#125; 在分发 action 时，就可处理 返回的 Promise 12345678store.dispatch(&quot;actionA&quot;).then( () =&gt; &#123; // ... resolved &#125;, () =&gt; &#123; // ... rejected &#125;); 在另一个 action 中也可以 12345678actions: &#123; // ... actionB (&#123; dispatch, commit &#125;) &#123; return dispatch(&#x27;actionA&#x27;).then(() =&gt; &#123; commit(&#x27;someOtherMutation&#x27;) &#125;) &#125;&#125; 使用 async/await语法，轻松组合 action 1234567891011// 假设 getData() 和 getOtherData() 返回的是 Promiseactions: &#123; async actionA (&#123; commit &#125;) &#123; commit(&#x27;gotData&#x27;, await getData()) &#125;, async actionB (&#123; dispatch, commit &#125;) &#123; await dispatch(&#x27;actionA&#x27;) // 等待 actionA 完成 commit(&#x27;gotOtherData&#x27;, await getOtherData()) &#125;&#125; Module由于使用单一的状态树，应用的 store 对象可能变得十分臃肿。为解决该问题，Vuex 可以将 store 分割成 小的模块（module）。 每个模块都拥有自己的 state、getters、mutation、action、嵌套的子模块。 命名空间默认情况下，模块内部的 action 、mutation、getter 都是注册在全局命名空间的，这使得 多个 模块能 对同一 mutation 、 action作出响应。 通过添加 namespaced:true，使其成名 带命名空间的模块。当有命名空间的模块被注册后，它所有 getter、action、mutation 都会自动根据模块注册的路径 调整命名。 12345678910111213141516171819202122232425262728293031323334353637383940const store = new Vuex.Store(&#123; modules: &#123; account: &#123; namespaced: true, // 模块内容（module assets） state: () =&gt; (&#123; ... &#125;), // 模块内的状态已经是嵌套的了，使用 `namespaced` 属性不会对其产生影响 getters: &#123; isAdmin () &#123; ... &#125; // -&gt; getters[&#x27;account/isAdmin&#x27;] &#125;, actions: &#123; login () &#123; ... &#125; // -&gt; dispatch(&#x27;account/login&#x27;) &#125;, mutations: &#123; login () &#123; ... &#125; // -&gt; commit(&#x27;account/login&#x27;) &#125;, // 嵌套模块 modules: &#123; // 继承父模块的命名空间 myPage: &#123; state: () =&gt; (&#123; ... &#125;), getters: &#123; profile () &#123; ... &#125; // -&gt; getters[&#x27;account/profile&#x27;] &#125; &#125;, // 进一步嵌套命名空间 posts: &#123; namespaced: true, state: () =&gt; (&#123; ... &#125;), getters: &#123; popular () &#123; ... &#125; // -&gt; getters[&#x27;account/posts/popular&#x27;] &#125; &#125; &#125; &#125; &#125;&#125;) 在带命名空间的模块内访问全局内容 想 使用全局 state、getter, rootState和rootGetters作为第三、第四个参数出入 getter 的处理函数，也会在 context对象的属性中 想 在全局命名空间分发 action、提交 mutation，将&#123;root: true&#125;作为第三个参数，传入 dispatch,commit即可 12345678910111213141516171819202122232425262728293031modules: &#123; foo: &#123; namespaced: true, getters: &#123; // 在这个模块的 getter 中，`getters` 被局部化了 // 你可以使用 getter 的第四个参数来调用 `rootGetters` someGetter (state, getters, rootState, rootGetters) &#123; getters.someOtherGetter // -&gt; &#x27;foo/someOtherGetter&#x27; rootGetters.someOtherGetter // -&gt; &#x27;someOtherGetter&#x27; &#125;, someOtherGetter: state =&gt; &#123; ... &#125; &#125;, actions: &#123; // 在这个模块中， dispatch 和 commit 也被局部化了 // 他们可以接受 `root` 属性以访问根 dispatch 或 commit someAction (&#123; dispatch, commit, getters, rootGetters &#125;) &#123; getters.someGetter // -&gt; &#x27;foo/someGetter&#x27; rootGetters.someGetter // -&gt; &#x27;someGetter&#x27; dispatch(&#x27;someOtherAction&#x27;) // -&gt; &#x27;foo/someOtherAction&#x27; dispatch(&#x27;someOtherAction&#x27;, null, &#123; root: true &#125;) // -&gt; &#x27;someOtherAction&#x27; commit(&#x27;someMutation&#x27;) // -&gt; &#x27;foo/someMutation&#x27; commit(&#x27;someMutation&#x27;, null, &#123; root: true &#125;) // -&gt; &#x27;someMutation&#x27; &#125;, someOtherAction (ctx, payload) &#123; ... &#125; &#125; &#125;&#125; 在带命名空间的 模块注册全局 action添加 root: true，并将这个 action 的定义放在函数 handler 中 12345678910111213141516171819&#123; actions: &#123; someOtherAction (&#123;dispatch&#125;) &#123; dispatch(&#x27;someAction&#x27;) &#125; &#125;, modules: &#123; foo: &#123; namespaced: true, actions: &#123; someAction: &#123; root: true, handler (namespacedContext, payload) &#123; ... &#125; // -&gt; &#x27;someAction&#x27; &#125; &#125; &#125; &#125;&#125; 带命名空间的 辅助函数 123456789101112computed: &#123; ...mapState(&#123; a: state =&gt; state.some.nested.module.a, b: state =&gt; state.some.nested.module.b &#125;)&#125;,methods: &#123; ...mapActions([ &#x27;some/nested/module/foo&#x27;, // -&gt; this[&#x27;some/nested/module/foo&#x27;]() &#x27;some/nested/module/bar&#x27; // -&gt; this[&#x27;some/nested/module/bar&#x27;]() ])&#125; 对于上种情况，可将模块的命名 空间名称字符串 作为第一个参数传递给上述函数 123456789101112computed: &#123; ...mapState(&#x27;some/nested/module&#x27;, &#123; a: state =&gt; state.a, b: state =&gt; state.b &#125;)&#125;,methods: &#123; ...mapActions(&#x27;some/nested/module&#x27;, [ &#x27;foo&#x27;, // -&gt; this.foo() &#x27;bar&#x27; // -&gt; this.bar() ])&#125; 表单处理在严格模式下，状态的变更不是由 mutation 处理函数引起的，将会抛出错误。因此，在 state 上使用v-model会比较棘手，例如 1&lt;input v-model=&quot;obj.message&quot; /&gt; 当用户输入时，v-model会试图直接修改ob.message,而非提交 mutation. 有 2 种解决方法 不使用v-model指令,给&lt;input&gt;中绑定 value，然后监听input或change事件，事件回调中提交 mutation. 123456789101112&lt;input :value=&quot;message&quot; @input=&quot;updateMessage&quot;&gt;computed: &#123; ...mapState(&#123; message: state =&gt; state.obj.message &#125;)&#125;,methods: &#123; updateMessage (e) &#123; this.$store.commit(&#x27;updateMessage&#x27;, e.target.value) &#125;&#125; 使用带有 setter的 双向绑定的计算属性， 12345678910111213&lt;input v-model=&quot;message&quot;&gt;// ....computed: &#123; message: &#123; get () &#123; return this.$store.state.obj.message &#125;, set () &#123; this.$store.commit(&#x27;updateMessage&#x27;, value) &#125; &#125;&#125;","categories":[{"name":"技术总结","slug":"技术总结","permalink":"https://better-jiang.github.io/categories/%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%93/"}],"tags":[{"name":"vue","slug":"vue","permalink":"https://better-jiang.github.io/tags/vue/"},{"name":"面试","slug":"面试","permalink":"https://better-jiang.github.io/tags/%E9%9D%A2%E8%AF%95/"}]},{"title":"vue-router梳理","slug":"vue-router梳理","date":"2020-05-17T06:16:49.000Z","updated":"2023-02-03T12:14:22.421Z","comments":true,"path":"2020/05/17/vue-router梳理/","link":"","permalink":"https://better-jiang.github.io/2020/05/17/vue-router%E6%A2%B3%E7%90%86/","excerpt":"","text":"用 Vue + Vue Router 创建单页面应用是非常简单的，其原理就是 将组件映射到路由，然后使用&lt;router-view&gt;告诉 Vue Router 在哪里渲染它们。具体 定义组件 定义路由 创建路由实例 将路由事件挂载到 vue 根实例 123456789101112131415161718192021222324252627// 0. 如果使用模块化机制编程，导入Vue和VueRouter，要调用 Vue.use(VueRouter)// 1. 定义 (路由) 组件。// 可以从其他文件 import 进来const Foo = &#123; template: &quot;&lt;div&gt;foo&lt;/div&gt;&quot; &#125;;const Bar = &#123; template: &quot;&lt;div&gt;bar&lt;/div&gt;&quot; &#125;;// 2. 定义路由// 每个路由应该映射一个组件。 其中&quot;component&quot; 可以是// 通过 Vue.extend() 创建的组件构造器，// 或者，只是一个组件配置对象。const routes = [ &#123; path: &quot;/foo&quot;, component: Foo &#125;, &#123; path: &quot;/bar&quot;, component: Bar &#125;,];// 3. 创建 router 实例，然后传 `routes` 配置const router = new VueRouter(&#123; routes, // (缩写) 相当于 routes: routes&#125;);// 4. 创建和挂载根实例。// 记得要通过 router 配置参数注入路由，// 从而让整个应用都有路由功能const app = new Vue(&#123; router,&#125;).$mount(&quot;#app&quot;);// 现在，应用已经启动了！ 通过注入路由器，可在任何组件内通过this.$router访问路由器，通过this.$route访问当前路由 动态路由匹配把某种模式匹配到所有路由，全部映射到同个组件。在路由路径中使用动态路径参数，以冒号:标记。当匹配 到一个路由时，参数值会被 设置到$route.params，多段的路径参数，对应的值也会被设置到$route.params。例如： 模式 匹配路径 $route.params /user/:username /user/jiang {username: “jiang”} /user/:username/post/:post_id /user/jiang/post/123 {username:”jiang”, post_id:”123”} 响应路由参数的变化当使用路由参数时，参数的变化，例如/user/foo导航到/user/jjiang，不会引起 user 组件的重新渲染，它会复用原来的组件实例，故页面不会对路由变化做出响应，没有任何变化。这样意味着：组件的生命周期钩子函数不会再被调用 2 个解决方法 简单的 watch$route对象 12345watch: &#123; &#x27;$route&#x27;: function(to, from) &#123; // &#125;&#125; 使用 组件内的 beforeRouteUpdate导航守卫，在当前路由改变，且改组件被复用时调用 123beforeRouteUpdate(to,from,next) &#123; //&#125; 捕获 所有路由 / 404 路由使用通配符（*）,可匹配任意路径。 当使用通配符路由时，要确保路由的顺序，应该将其放在最后。 当使用一个通配符时，$route.params内会自动添加一个名名为pathMatch参数 模式 匹配路径 $route.params /user-* /user-admin {pathMatch: “admin”} * /non-existing {pathMatch: “non-existing”} 匹配优先级同一个路径可匹配多个路由时，匹配的优先级按照路由的定义顺序，先定义的优先级高 嵌套路由一个被渲染的组件可以嵌套&lt;router-view&gt;,它是该组件匹配路由的嵌套路由的出口。要在嵌套的出口中渲染组件，使用children配置 12345678/user/foo/profile /user/foo/posts+------------------+ +-----------------+| User | | User || +--------------+ | | +-------------+ || | Profile | | +------------&amp;gt; | | Posts | || | | | | | | || +--------------+ | | +-------------+ |+------------------+ +-----------------+ 使用嵌套路由，表达上述关系 1234567891011121314151617181920let routes = [ &#123; path: &quot;/user/:id&quot;, component: User, children: [ &#123; // 当 /user/:id/profile 匹配成功， // UserProfile 会被渲染在 User 的 &lt;router-view&gt; 中 path: &quot;profile&quot;, component: UserProfile, &#125;, &#123; // 当 /user/:id/posts 匹配成功 // UserPosts 会被渲染在 User 的 &lt;router-view&gt; 中 path: &quot;posts&quot;, component: UserPosts, &#125;, ], &#125;,]; 基于上面配置，当访问/user/foo时，User的出口不会渲染任何东西，因为没有匹配到合适的子路由，如果需要渲染什么，需要提供一个空的子路由 12345678910111213141516171819202122let routes = [ &#123; path: &quot;/user/:id&quot;, component: User, children: [ // 当 /user/:id 匹配成功， // UserHome 会被渲染在 User 的 &lt;router-view&gt; 中 &#123; path: &quot;&quot;, component: UserHome, &#125;, &#123; path: &quot;profile&quot;, component: UserProfile, &#125;, &#123; path: &quot;posts&quot;, component: UserPosts, &#125;, ], &#125;,]; 命名路由通过一个名称来标识一个路由在使用时会更方便些，在创建 Router 实例的时候，在routes配置中给路由设置名称name 123456789101112131415const router = new VueRouter(&#123; routes: [ &#123; path: &#x27;/user/:userId&#x27;, name: &#x27;user&#x27;, component: User &#125; ]&#125;)&lt;router-link :to=&quot;&#123; name: &#x27;user&#x27;, params: &#123; userId: 123 &#125;&#125;&quot;&gt;User&lt;/router-link&gt;router.push(&#123; name: &#x27;user&#x27;, params: &#123; userId: 123 &#125;&#125;) 命名视图想要同时/同级的展示多个视图，而不是嵌套展示，则需要命名视图，即在一个页面/组件中拥有多个单独命名的视图，而不是只用一个单独的出口。 一个视图需要一个组件渲染，因此，对于同个路由，多个视图就需要多个组件，使用components配置 1234567891011121314151617&lt;router-view class=&quot;view one&quot;&gt;&lt;/router-view&gt;&lt;router-view class=&quot;view two&quot; name=&quot;a&quot;&gt;&lt;/router-view&gt;&lt;router-view class=&quot;view three&quot; name=&quot;b&quot;&gt;&lt;/router-view&gt;const router = new VueRouter(&#123; routes: [ &#123; path: &#x27;/&#x27;, components: &#123; default: Foo, a: Bar, b: Baz &#125; &#125; ]&#125;) 重定向和别名12345678910routes: [ &#123; path: &quot;/a&quot;, redirect: &quot;/b&quot;, &#125;, &#123; path: &quot;/c&quot;, alias: &quot;/d&quot;, &#125;,]; 重定向：当用户访问/a，URL 会被替换成/b，然后匹配路由为/b,且为/a路由添加beforeEach守卫并 不会有任何效果 别名 ：当用户访问/d时，URL 会保持/d,但是路由匹配则为/c,就像用户访问/c 路由组件传参因为在组件中使用$route，会使组件同其对应路由形成高度耦合，从而使组件只能在特定的 URL 上使用。使用props配置，可以将组件与路由解耦。 12345678910111213141516const User = &#123; props: [&quot;id&quot;], template: &quot;&lt;div&gt;User &#123;&#123; id &#125;&#125;&lt;/div&gt;&quot;,&#125;;const router = new VueRouter(&#123; routes: [ &#123; path: &quot;/user/:id&quot;, component: User, props: true &#125;, // 对于包含命名视图的路由，你必须分别为每个命名视图添加 `props` 选项： &#123; path: &quot;/user/:id&quot;, components: &#123; default: User, sidebar: Sidebar &#125;, props: &#123; default: true, sidebar: false &#125;, &#125;, ],&#125;); 函数模式，创建一个函数返回props，可以将参数转化成其他类型，可将静态值与路由的值结合 123456789const router = new VueRouter(&#123; routes: [ &#123; path: &quot;/search&quot;, component: SearchUser, props: (route) =&gt; (&#123; query: route.query.q &#125;), &#125;, ],&#125;); URL/search?q=vue，会将&#123;query:&#39;vue&#39;&#125;作为属性传递给SearchUser组件 编程式的导航除了&lt;router-link&gt;创建 a 标签来定义导航链接，还可以借助$router的实例方法，通过编写代码来实现 $router.push(location,onComplete?, onAbort?),向 history 栈中添加一个新的记录 $router.replace(location,nComplete?, onAbort?),替换掉当前的 history 记录 $router.go(n),在 history 记录中向前，或后退多少步 以上的方法是效仿window.history API 的，window.history.pushState,window.history.replaceState,window.history.go H5 History 模式vue-router默认 hash 模式，使用 URL 的 hash 来模拟一个完整的 URL，所以当 URL 改变时，页面不会重新加载 history 模式 是利用history.pushStateAPI 来完成 URL 跳转，而无须重新加载页面。**但需要后台配置支持，因为应用是单页面的，如果后台没有给正确的配置，当用户在浏览器直接访问http://oursite.com/user/id,就会返回 404 .所以服务器需要增加一个覆盖所有情况的候选资源。在 URL 匹配不到任何静态资源，返回同一个index.html页面 ； 同时 在 Vue 的 路由配置中，添加覆盖所有的路由情况，并给返回 404 页面 ** 导航守卫”导航“表示路由正发生改变，导航守卫，通过跳转、取消的方式守卫导航。 参数或查询的改变不会触发进入/离开的导航守卫，2 种解决方法 通过 watch $route对象来应对改变化 使用组件内的导航守卫 beforeRouteUpdate 守卫方法接受的参数守卫方法可接受三个参数” to， 即将要进入的目标 路由对象 from，当前导航要离开 的路由 对象 next， 一个函数，一定要调用该函数来 resolve 该钩子，执行效果由next函数的调用参数决定 next()，进行下一个守卫钩子。如果全部的钩子执行完，则导航的状态就是 confirmed（确认的） next(false)，中断当前的导航，URL 地址重置到from路由对应的地址 next(location)， 跳转到一个不同的地址。当前导航中断，然后进入一个新的导航 要确保调用next函数，否则钩子不会被 resolved 全局的守卫 beforeEach（to, from, next）：全局前置 守卫，是异步解析执行，此时导航在所有守卫resolved完之前一直处于 pending （等待中）。 beforeResolve(to, from ,next)：全局解析守卫，在导航被 confirmed（确认）之前，同时在所有组件内守卫，异步路由组件被解析之后，解析守卫才被调用 afterEach(to, from)：全局后置守卫，导航被 confirmed(确认) 之后，该守卫才调用 12345678910const router = new VueRouter(&#123; ... &#125;)router.beforeEach((to,from,next) =&gt; &#123; // ...&#125;)router.beforeResolve((to,from,next) =&gt; &#123; // ...&#125;)router.afterEach((to,from) =&gt; &#123; // ...&#125;) 路由独享的守卫 beferEnter：在单个路由上定义，匹配该路由时被调用 组件内守卫 beforeRouteEnter(to, from, next)：在导航确认前被调用，因此新组件还没被创建，守卫**不能访问this**，但可以通过传一个回调给next来访问组件实例。在导航被确认的时候，执行回调，并把组件实例作为回调函数的参数 123456beforeRouteEnter(to,from, next) &#123; // .... next(vm =&gt; &#123; // 通过`vm`可访问该组件实例 &#125;)&#125; beforeRouteUpdate(to, from, next)： 在当前路由改变，且该组件被复用时调用，可以访问组件内的this beforeRouteLeave(to, from, next)：导航离开该组件的对应路由时调用 导航解析流程 导航被 触发 在失活的组件调用离开守卫beforeRouteLeave 调用全局的 beforeEach 如果重用组件，在重用组件里调用beforeRouteUpdate 在路由配置里调用beforeEnter 解析异步路由组件 在被激活的组件里调用beforeRouteEnter 调用全局的beforeResolve 导航被确认 调用全局的afterEnach 触发 DOM 更新 用创建好的组件实例调用beforeRouteEnter守卫中传给next的回调函数 路由 元 信息定义路由时配置meta字段，通过$route.meta来访问它 $route.matched，一个路由 匹配到的所有路由记录（routes配置中的每个路由对象称之为 路由记录）的数组 12345678910111213141516router.beforeEach((to, from, next) =&gt; &#123; if (to.matched.some((record) =&gt; record.meta.requiresAuth)) &#123; // this route requires auth, check if logged in // if not, redirect to login page. if (!auth.loggedIn()) &#123; next(&#123; path: &quot;/login&quot;, query: &#123; redirect: to.fullPath &#125;, &#125;); &#125; else &#123; next(); &#125; &#125; else &#123; next(); // 确保一定要调用 next() &#125;&#125;); 过渡效果因为&lt;router-view&gt;是基本的动态组件，所以可以用&lt;transition&gt;组件包裹它，并添加过渡效果 123&lt;transition&gt; &lt;router-view&gt;&lt;/router-view&gt;&lt;/transition&gt; 单个路由的过渡在各路由组件内使用&lt;transition&gt;并设置不同的name,可让每个路由组件都有各自的过渡效果 123456789101112131415const Foo = &#123; template: ` &lt;transition name=&quot;slide&quot;&gt; &lt;div class=&quot;foo&quot;&gt;...&lt;/div&gt; &lt;/transition&gt; `,&#125;;const Bar = &#123; template: ` &lt;transition name=&quot;fade&quot;&gt; &lt;div class=&quot;bar&quot;&gt;...&lt;/div&gt; &lt;/transition&gt; `,&#125;; 动态设置过渡基于当前路由与目标路由的变化关系，动态设置过渡效果 1234567891011121314&lt;transition :name=&quot;transitionName&quot;&gt; &lt;router-view&gt;&lt;/router-view&gt;&lt;/transition&gt;&lt;script&gt;// ... watch: &#123; &#x27;$route&#x27;(to,from) &#123; const toDepth = to.path.split(&#x27;/&#x27;).length const fromDepth = from.path.split(&#x27;/&#x27;).length this.transitionName = toDepth &lt; fromDepth ? &#x27;slide-right&#x27; : &#x27;slide-left&#x27; &#125; &#125;&lt;/script&gt; 数据获取进入路由后，需要从服务器获取数据，有 2 种选择 导航完之后获取：先完成导航,会进入新页面并马上渲染组件，然后在组件生命周期钩子函数created获取数据，期间展示 loading 状态 123456789101112131415161718192021222324252627282930313233export default &#123; data() &#123; return &#123; loading: false, post: null, error: null, &#125;; &#125;, created() &#123; // 组件创建完后获取数据， // 此时 data 已经被 observed 了 this.fetchData(); &#125;, watch: &#123; // 如果路由有变化，会再次执行该方法 $route: &quot;fetchData&quot;, &#125;, methods: &#123; fetchData() &#123; this.error = this.post = null; this.loading = true; // replace getPost with your data fetching util / API wrapper getPost(this.$route.params.id, (err, post) =&gt; &#123; this.loading = false; if (err) &#123; this.error = err.toString(); &#125; else &#123; this.post = post; &#125; &#125;); &#125;, &#125;,&#125;; 导航完成之前获取：在导航转入新的路由前获取数据,在组件的beforeRouteEnter或复用组件的beforeRouteUpdate守卫中获取数据，当获取数据成功后调用next函数。在为后面视图获取数据时，用户停留在当前界面，建议显示进度条，或其他提示。 12345678910111213141516171819202122232425262728293031export default &#123; data() &#123; return &#123; post: null, error: null, &#125;; &#125;, beforeRouteEnter(to, from, next) &#123; getPost(to.params.id, (err, post) =&gt; &#123; next((vm) =&gt; vm.setData(err, post)); &#125;); &#125;, // 路由改变前，组件就已经渲染完了 // 逻辑稍稍不同 beforeRouteUpdate(to, from, next) &#123; this.post = null; getPost(to.params.id, (err, post) =&gt; &#123; this.setData(err, post); next(); &#125;); &#125;, methods: &#123; setData(err, post) &#123; if (err) &#123; this.error = err.toString(); &#125; else &#123; this.post = post; &#125; &#125;, &#125;,&#125;; 路由懒加载将不同路由对应的组件分割成不同的代码块，并在被访问的时候才加载对应的组件。结合 Vue 的异步组件和 Webpack 的代码分割功能，可轻松实现路由组件的懒加载。 用命名 chunk，可把某个路由下的所有组件都打包在同一个异步块（chunk）中。 12345678910111213const router = new VueRouter(&#123; routes: [ &#123; path: &quot;/foo&quot;, component: Foo, &#125;, &#123; path: &quot;/about&quot;, component: () =&gt; import(/* webpackChunkName: &quot;about&quot; */ &quot;../views/About.vue&quot;), &#125;, ],&#125;);","categories":[{"name":"技术总结","slug":"技术总结","permalink":"https://better-jiang.github.io/categories/%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%93/"}],"tags":[{"name":"vue","slug":"vue","permalink":"https://better-jiang.github.io/tags/vue/"},{"name":"面试","slug":"面试","permalink":"https://better-jiang.github.io/tags/%E9%9D%A2%E8%AF%95/"}]},{"title":"失业期杂感","slug":"失业期杂感","date":"2020-05-16T02:45:15.000Z","updated":"2023-02-03T12:14:22.421Z","comments":true,"path":"2020/05/16/失业期杂感/","link":"","permalink":"https://better-jiang.github.io/2020/05/16/%E5%A4%B1%E4%B8%9A%E6%9C%9F%E6%9D%82%E6%84%9F/","excerpt":"","text":"至今失业已有4个月，内心是惶恐不安，但外在的表现却是无所谓，不冷不热，似乎在等待一个时机，自己幡然醒悟，力挽狂澜般找到工作，入职心仪的大厂。所有，两者很矛盾，内心的焦虑，致使自我怀疑、否定、内疚，夜晚睡不着，白天无精打采；时不时冒出的美好幻想，却能令自己深信，在等等也无妨，或许撞上大运，逆风翻盘，那时再好好努力，认真经营自我，将大概率实现美好愿望。就这样，反复与两者间横跳，渐渐的，自己如秋后的树叶，没了生机，一边任由风吹落，一边幻想并计划着，在来年的春天里重获新生，成为百花之间的绿叶。 时间太快，快到令我常常忘记日期，今天是周几？因为时常熬夜，睡觉不规律，不知何时睡？也不知睡了多久？每每醒来后都不知是昼是夜？是上午，还是下午？此种感觉极其恐惧，就像失去了自小陪伴我的一种本能。（睡觉醒来之后，能大致知道自己睡了多久？现在大约是几点钟？）有时会在半夜3点，2点醒来，想再入睡则困难极了，起来吧，也不知到做什么？大多数都会看视频，包括小片，然后强熬到天亮，去吃顿早餐后才慢慢困意来袭，借机再睡。于是，白天睡觉，晚上看视频，游戏，好几天如此下来，也就不知道日期了。 用无聊去打法时间，得到的当然还是无聊本身。自我本身不算爱看视频之人，不追剧，不刷短视频，偶尔看看热门电影，纪录片也谈不上喜欢，小片仅在需要时瞧瞧。之前我认为看视频就是见无聊之事，它远比上看杂志，小说，或者刷知乎有趣，更比不了同朋友聊天、自我胡思乱想。可为什么我会选择通过看视频来打发时间呢？现在想想，可能的原因有如下几点： 笔记本电脑、耳机 就在床头，方便使用。 历次看小片后，得到一个经验：晚上的网速比白天好，夜深人静，沉浸其中，效果好。所以在晚上看视频，是种高效率的选择，同时也带有一种占小便宜的心理。 视频相比看书，有声音，能打消因黑暗和寂静带来的空虚感、恐惧感。 夜晚看视频 眼睛更容易干涩疲累，再加上看小片，能快速的令人感到疲劳，从而转化成困意，有利于再次入睡。 综上所述，先阶段我陷入了恶性的死循环：熬夜、睡眠不规律 —&gt; 白天补觉，无精打采，无所事事 —&gt; 面试准备不足，没信心，焦虑失落 —&gt; 失眠，熬夜。为此，我刷知乎，刷B站，搜寻大佬事迹，看看能不能从中寻找到一些蛛丝马迹。现在我还不敢讲找到了，但启发了我。 首先，我这中状态很常见，没什么大不了的。归根结底，就是人处于低谷罢了，往上走是肯定之事，时间长短不定。另外，睡眠问题和看视频，属是正常不过，不用过渡在意。关于睡眠，晚上睡不着，没啥大不了的，就当是白天，起来做事情即可，大不了白天偷会懒，找机会补一觉；就算白天精神不佳，只要专注，做事情也不差的。另外，白天适当的运动，有助于睡眠的。 做计划，列清单，提前就给自己找好要做之事，再遇到无聊要打发，想都不要想，直接找清单里的事做就完了。当一件件被做完，自然能收获成就感、自信心，愉悦感，这美妙感觉就是一种正反馈。刺激你去做更多的事情。久而久之，形成正向有益的循环，似乎能永动了，只要身处该循环中，就自然而然的会去做事情。等习惯养成，也就不需要花心思精力去维持，到那时，想停都难。 另外，我还要得到一个启发，做事情就是为了得到计划的结果，如果某事不是，或已经超出计划，那么在该计划时期内就无需去做。人的时间，精力有限，无计划无目的 的行事，就是一种浪费，千万不要迷失在知识的海洋里，只取我们当下所需。例如，考证考级，最好的结果就是低分飘过，多一分无用，少一分不可。面试准备易如此，目标就能应付面试官，成功入职即可，所以在准备时，重点在基础，工作中所需的知识点，其他深、难点可先行略过。","categories":[{"name":"随笔感悟","slug":"随笔感悟","permalink":"https://better-jiang.github.io/categories/%E9%9A%8F%E7%AC%94%E6%84%9F%E6%82%9F/"}],"tags":[]},{"title":"vue知识点梳理","slug":"vue知识点梳理","date":"2020-05-14T13:08:43.000Z","updated":"2023-02-03T12:14:22.421Z","comments":true,"path":"2020/05/14/vue知识点梳理/","link":"","permalink":"https://better-jiang.github.io/2020/05/14/vue%E7%9F%A5%E8%AF%86%E7%82%B9%E6%A2%B3%E7%90%86/","excerpt":"","text":"vue 原理vue是一MVVM渐进式框架，在vue框架中数据会自动驱动视图。 MVVM设计模式 View：视图，即DOM，UI组件，负责将数据转换成UI展示 Model：模型，是vue组件里的data，或者vuex里数据 ViewModel：视图模型，负责监听数据变化，控制视图行为，处理用户交互。 View和Model之间无直接联系，而是通过ViewModel进行交互，ViewModel通过双向数据绑定把View和Model连接起来，ViewModel通常要实现一个observer观察者，当数据发生变化，ViewModel能够监听到数据的这种变化，然后通知到对应的视图做自动更新，而当用户操作视图，ViewModel也能监听到视图的变化，然后通知数据做改动，因此，开发者只需关注业务逻辑，不需手动操作DOM，也不需关注数据状态的同步问题，vue是响应式的 响应式Vue的响应式原理：通过Object.defineProperty中访问器属性中get和set方法。data中声明的属性都被添加了访问器属性，当读取data中数据时调用get方法，当修改data中数据时，自动调用set方法，在检测到数据变化，会通知观察者（Watcher）,观察者（Watcher）会触发 重新渲染当前组件，生成新的虚拟DOM树，Vue遍历并对比新旧虚拟DOM树不同，并记录下来，最后，重新渲染视图，将局部修改到真实DOM树上。 每个组件实例都对应一个watcher实例，它会在组件渲染的过程中把“接触”过的数据property记录为依赖（getter函数通知watcher对象将其声明为依赖），之后当依赖项的setter触发时，会通知watcher，从而使它关联的组件重新渲染。 Vue 在 3.x 版本之后改用 Proxy 进行实现 变化检测问题 对于对象，vue无法检测到对象属性的添加或移除。由于vue会在初始化实例时对property执行 getter/setter转化，所有 property 必须在 data对象上存在 才能让vue将它转换为响应式的。 使用 Vue.set(object, propertyName, value)方法向对象添加响应式的property 使用Object.assign()或_.extend()这样混合进到对象的新property不会触发更新。应该使用原对象与要混合进去的对象的property一起创建一个新对象，并替换原对象 12this.someObj = Object.assign(&#123;&#125;, this.someObj, &#123;a: 1, b: 22&#125;)// 替代， Object.assign(this.someObj, &#123;a: 1, b: 22&#125;) 对于数组，以下2种数组变动，vue无法检测 利用索引直接设置数组项时，例如：vm.items[index] = newValue。解决方法： 1234// Vue.set()Vue.set(vm.items, index, newValue) // 数组 中 变异方法 Array.prototype.splice()vm.items.splice(index, 1, newValue) 直接修改数组的length时，例如：vm.items.length = newLength。解决方法： 12// 删除 新 长度 以后的数组项vm.items.splice(newLength) 声明响应式property由于Vue不允许动态添加 根级响应式property,所以必须在初始化实例前 声明所有根级响应式property，哪怕是一个空值。好处： 可维护性上，因data对象就像是组件状态的结构，所以提前声明好，可以让组件代码在未来修改或阅读时更易于理解 异步更新 队列 Vue 在更新DOM时是异步执行的。只要侦听到数据变化，Vue将开启一个队列，并缓冲在 同一事件循环中发生 的所有数据变更。如果一个watcher被多次触发，只会被推入到队列中一次。在缓冲时去掉 重复数据，避免了不必要的计算和DOM操作。 简而言之，就是在一个事件循环期间 发生的 所有数据改变 都会在 下一个事件循环的Tick中来触发 视图更新。关于事件循环 可参考博客： EventLoop梳理 Vue在内部对异步队列尝试使用原生的Promise.then,MutationObserver和setImmediate.如果环境不支持，则会采用setTimeout(fn, 0)代替 响应数据 发生变更后，该组件不会立即重新渲染，而会在下一次事件循环”tick”中更新。如果想基于更新后的DOM状态做点什么，需要在数据变化后使用Vue.nextTick(callback),回调函数将在DOM更新完成后被调用，回调函数中的this将自动绑定到调用它的 Vue 实例上 123456789101112131415161718&lt;div id=&quot;example&quot;&gt;&#123;&#123;message&#125;&#125;&lt;/div&gt;&lt;script&gt;var vm = new Vue(&#123; el: &#x27;#example&#x27;, data: &#123; message: &#x27;123&#x27; &#125;&#125;)vm.message = &#x27;new message&#x27; // 更改数据vm.$el.textContent === &#x27;new message&#x27; // falseVue.nextTick(function () &#123; vm.$el.textContent === &#x27;new message&#x27; // true&#125;)&lt;/script&gt; 因为 $nextTick()返回一个Promise对象，所以可以使用 async/await语法 12345678methods: &#123; updateMessage: async function () &#123; this.message = &#x27;已更新&#x27; console.log(this.$el.textContent) // =&gt; &#x27;未更新&#x27; await this.$nextTick() console.log(this.$el.textContent) // =&gt; &#x27;已更新&#x27; &#125;&#125; Vue 生命周期 Vue在整个生命周期中会有8个钩子函数供我们在不同时刻进行操作。注意，最后不要在生命周期钩子函数内使用箭头函数，因为箭头函数并没有this,this会作为变量一直向上级词法作用域查找，直至找到为止。在普通函数内部，this就是该Vue 实例 Creation (Initialization)创建钩子 在Vue实例开始初始化过程中运行，它允许我们在 将Vue实例添加到 DOM之前执行操作。同其他钩子不同，创建钩子也是在服务器呈现期间运行的,在此期间，不能访问DOM或this.$el beforeCreate： data未被激活，events还没被设置 created：vue实例已经初始化完成，data,computed,watch,methods,events,已激活。常用于，通过网络请求，为组件获取一些必要数据 Mounting （DOM Insertion ）将vue实例挂载到 指定元素时运行（即组件第一次渲染呈现之前、之后运行）。常用于在组件初始呈现之前或之后立即访问或修改组件中的DOM beforeMount： vue实例挂载到DOM之前以及模板或render函数已经编译好之后，此时，不能操作DOM，this.$el仍不可用，页面还是旧的。 mounted：vue实例已被挂载，可以访问组件、模板和DOM，常用于操作DOM和集成非Vue库 Updating （Diff &amp; Re-render）每当组件使用的响应数据发生更改，或其他原因导致其重新渲染时，就会调用更新钩子函数。 可使用： 想要知道组件何时重新渲染（re-redner），可能用于调试或分析 不可使用：想知道组件内的data数据时何时更改的，建议用computed或watch 替代 beforeUpdate： 组件中data数据更改之后，修补和重新渲染DOM（patched and re-redner）之前运行。此时 data数据是最新的，但页面中尚未和最新数据同步 updated： vue实例中数据更改和DOM也重新渲染呈现 之后运行。如果需要在属性更改后访问DOM，这里是最安全的 Destruction （Teardown）销毁钩子允许在组件被消耗是执行操作，例如清理或分析发送。当组件被拆下并从DOM中移除是时，它们会触发。 beforeDestroy： 在销毁实例之前触发，此阶段，该实例和其所有功能仍然可用，常用于执行资源管理，删除变量，清理事件、取消订阅等。 destroyed： 实例别销毁，此阶段，所有的子vue实例也已经被销毁，事件监听器，所有指令都被解除绑定。调用vm.$destroy()会触发 render 函数每一个vue组件都会实现一个render函数，大多数情况下，该函数由vue编译器创建。当在组件上指定一个模板（template），该模板的内容将被vue编译器处理，并返回一个redner函数。render函数实际上会返回一个虚拟DOM节点，并由vue在浏览器DOM中呈现。再结合vue响应系统，vue能够智能的计算处最少需要重新渲染多少组件，并把 DOM操作次数减到最少。 每当组件的响应性属性更像时，都会再次调用redner函数 虚拟DOMVue通过渲染函数返回的虚拟DOM节点（在vue中通常成为VNode,包含vue所需的所有信息）建立起一个虚拟DOM，并用其来追踪自己要如何改变真实DOM。当vue要更新真实DOM时，vue会将更新后的虚拟DOM与之前的DOM进行比较，并仅使用修改的部分来更新真实DOM，这意味较少的元素被修改，从而提高性能。 createElement在Vue生态中通常使用h作为createElement的别名 1234567891011121314Vue.component(&#x27;anchored-heading&#x27;, &#123; render: function (createElement) &#123; return createElement( &#x27;h&#x27; + this.level, // 标签名称 this.$slots.default // 子节点数组 ) &#125;, props: &#123; level: &#123; type: Number, required: true &#125; &#125;&#125;) createElement，更准确的名字可能是createNodeDescription,因为它返回VNode，就是节点的描述信息。createElement接受3个参数 HTML标签名，组件的选项对象，或 resolve 了 二者中 任一种的 一个的 async函数 &#123;String | Object | Function&#125; 1234567// 组件的选择对象 import App from &quot;./App.vue&quot;new Vue(&#123; router, store, render: h =&gt; h(App)&#125;).$mount(&quot;#app&quot;); 一个与模板中 attribute 对应 的 数据对象 &#123;Object&#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152 &#123; // v-bind:class class: &#123; foo: true, bar: false &#125;, // v-bind:style style: &#123; fontSize: &quot;20px&quot; &#125;, // 普通 HTML attribute attrs: &#123; id: &quot;app&quot; &#125;, // 组件 prop props: &#123; myProp: &quot;bar&quot; &#125;, // DOM property domProps: &#123; innerHTML: &quot;bar&quot; &#125;, // 事件监听器，vue内事件 on: &#123; click: function() &#123;&#125; &#125;, // 监听js原生事件，`vm.$emit()`不会触发 nativeOn: &#123; click: function() &#123;&#125; &#125;, // 自定义 组件 // `v-myDirective:arg.bar=&quot;1+1&quot;` directives: [ &#123; name: &quot;myDirective&quot;, // 指令名 value: &quot;2&quot;, // 指令绑定的值 expression: &quot; 1+ 1&quot;, // 指令表达式 arg: &quot;foo&quot;, // 传给指令的参数 modifiers: &#123; // 修改符 bar: true &#125; &#125; ], // 作用域插槽 // &#123;name: props =&gt; Vnode | Array&lt;VNode&gt;&#125; scopedSlots: &#123; default: props =&gt; createElement(&quot;span&quot;, props.text) &#125;, slot: &quot;name-of-slot&quot;, key: &quot;myKey&quot;, ref: &quot;myRef&quot;&#125; 子级虚拟节点 列表（VNodes），也是由createElement()构建而成，使用字符串直接生成”文本虚拟节点” &#123;Array | String &#125; 模板功能的替代v-if 和 v-for1234&lt;ul v-if=&quot;items.length&quot;&gt; &lt;li v-for=&quot;item in items&quot;&gt;&#123;&#123; item.name &#125;&#125;&lt;/li&gt;&lt;/ul&gt;&lt;p v-else&gt;No items found.&lt;/p&gt; 1234567891011props: [&#x27;items&#x27;],render: h =&gt; &#123; const self = this; if(self.items.length) &#123; return h(&#x27;ul&#x27;, self.items.map(item =&gt; &#123; return h(&#x27;li&#x27;, item.name) &#125;)) &#125;else &#123; return h(&#x27;p&#x27;, &#x27;No items found.&#x27;) &#125;&#125; v-model1&lt;input v-model=&quot;bar&quot; /&gt; 1234567891011121314props: [&#x27;value&#x27;], render: h =&gt; &#123; const self = this; return h(&#x27;input&#x27;, &#123; domProps: &#123; value: self.value &#125;, on: &#123; input: event =&gt; &#123; self.$emit(&#x27;input&#x27;, event.target.value) &#125; &#125; &#125;) &#125; 事件&amp;按键 修饰符.passive、capture、once这些事件修饰符，vue提供了对应的前缀可用于on 修饰符 前缀 .passive (滚动事件默认行为（滚动行为），立即触发，而非等待‘onScroll 完成) &amp; .capture ! .once ~ .capture.once 或 .once.capture ~! 12345on: &#123; &#x27;!click&#x27;: this.doThisInCapturingMode, &#x27;~keyup&#x27;: this.doThisOnce, &#x27;~!mouseover&#x27;: this.doThisOnceInCapturingMode &#125; 其他修饰符，不需前缀，可在事件处理函数中找到等价的操作 修饰符 处理函数中等价操作 .stop event.stopPropagation() .prevent event.preventDefault() .self if (event.target !== event.curentTarget) return 按键：.enter,.12 if (event.keyCode !== 12) return 修饰键：.ctrl、.alt、.shift、meta if (!event.ctrlKey) return // altKey shiftKey metaKey 插槽 通过this.$slots访问静态 插槽，&#123;[name: string]: ?Array&lt;VNode&gt;&#125;,每个插槽都是一个VNode数组。每个具名插槽有其相对应的property，例如， v-slot:foo中的内容，在this.$slots.foo中， this.$slots.defalut内容为 所有没有名字插槽中的节点 12345678910&lt;blog-post&gt;&lt;template v-slot:header&gt; &lt;h1&gt;Header&lt;/h1&gt; &lt;/template&gt; &lt;p&gt;content 1&lt;/p&gt; &lt;template v-slot:footer&gt; &lt;h2&gt;Footer&lt;/h2&gt; &lt;/template&gt; &lt;p&gt;content 2&lt;/p&gt; &lt;/blog-post&gt; 123456789101112Vue.component(&#x27;blog-post&#x27;, &#123; redner: h =&gt; &#123; let header = this.$slots.header let footer = this.$slots.footer let body = this.$slots.default return h(&#x27;div&#x27;, [ h(&#x27;header&#x27;, header), h(&#x27;main&#x27;, body), h(&#x27;footer&#x27;, footer) ]) &#125;&#125;) 通过this.$scopedSlots访问作用域插槽，&#123;[name:string]: props =&gt; Array&lt;VNode&gt; | undefined&#125;,每个作用域插槽都是一个返回若干 VNode 的函数 12345678910props: [&#x27;message&#x27;], render: h =&gt; &#123; cosnt slef = this // `&lt;div&gt;&lt;slot :text=&quot;message&quot;&gt;&lt;/slot&gt;&lt;/div&gt;` return h(&#x27;div&#x27;, [ slef.$scopedSlots.defalut(&#123; text: this.message &#125;) ]) &#125; 从2.6.0开始，所有$slots都会作为函数暴露$scopedSlots中 。所有在使用render函数，不论当前插槽是否带有作用域，都始终通过$scopedSlots访问它们 Slot 插槽在2.6.0后，具名插槽和作用域插槽使用统一语法: v-slot指令，它取代了slot和slot-scope的attribute 父级模板里的所有内容都在父级作用域中编译，同理，子模版亦是如此。 具名插槽当需要向组件添加多个插槽时，则插槽需要有名称，可使用&lt;slot&gt;元素的一个特殊的attribute: name来定义。一个不带name的&lt;slot&gt;，name默认为default 12345678&lt;div class=&quot;container&quot;&gt; &lt;header&gt; &lt;slot name=&quot;header&quot;&gt;&lt;/slot&gt; &lt;/header&gt; &lt;main&gt; &lt;slot&gt;&lt;/slot&gt; &lt;/main&gt;&lt;/div&gt; 在向具名插槽提供内容时，可在一个&lt;template&gt;元素上使用v-slot指令，用以v-slot参数的形式 指定插槽名称 12345678&lt;base-layout&gt; &lt;template v-slot:header&gt; &lt;h1&gt; page title&lt;/h1&gt; &lt;/template&gt; &lt;template v-slot:defalut&gt; &lt;p&gt;the main content&lt;/p&gt; &lt;/template&gt;&lt;/base-layout&gt; 作用域插槽作用域插槽，可让插槽内容访问子组件中的数据。 12345&lt;span&gt; &lt;slot v-bind:user=&quot;user&quot;&gt; &#123;&#123;user.lastName&#125;&#125; &lt;/slot&gt;&lt;/span&gt; 想替换备用的内容，用 firstName 而不是 lastName 。**因只有在&lt;current-user&gt;组件内部才可以访问到user,为了让user在父级的插槽内容中可用 ，需要将user作为&lt;slot&gt;元素的一个 attrubute 绑定 ** 绑定在&lt;slot&gt;元素上的 attrubute 称为 插槽prop，这样就可以暴露给 插槽内容 。 现在 在父级作用域中，可以使用带值的v-slot来定义插槽prop 对象 的名字，从而接收 插槽prop内容。 12345&lt;current-user&gt; &lt;template v-slot:default=&quot;slotProps&quot;&gt; &#123;&#123; slotProps.user.firstName &#125;&#125; &lt;/template&gt;&lt;/current-user&gt; 在上例中，将包含所有插槽prop的对象命名为slotProps 风格指南必要的 （可规避错误） 组件名应该始终时多个单词，根组件App及Vue内置组件除外。避免跟现有、或未来的HTML元素相冲突，因为所有的HTML元素名称都是单个单词 组件的data必须是一个函数。如果是对象，它会在组件的所有实例之间共享。为了避免如此，每个实例必须生成一个独立的数据对象，在函数返回对象即可。 prop定义应该尽量详细。细致的prop定义可很容易看懂组件的用法，在开发环境中，不符合的prop，vue会告警。 123456789101112Vue.component(&#x27;my-component&#x27;, &#123;props: &#123; propA: &#123; type: Number, defalut: 100, required: true, validator: function(value) &#123; return value &lt; 1000 &#125; &#125;&#125;&#125;) 必须用key配合v-for， 且不要用idnex作为key. key的类型number | string。 key主要用在Vue的虚拟DOM算法，在新、旧 虚拟DOM对比时 辨别 Vnodes，从而高效的更新虚拟DOM 不使用key，Vue会使用一种最大限度减少动态元素，并尽可能的尝试就地修改/复用相同类型元素的算法。 使用key, Vue会基于key的变化重新排列元素顺序，并且移除 key 不存在的元素 避免在同一个元素上使用v-if，v-for。 因为v-for比v-if具有更高的优先级，所有在每次重新渲染的时候回遍历整个列表。另外 在 渲染层的 添加了逻辑，可维护性不强。 为了 过滤一个列表中的项目，应该使用计算属性,让其返回过滤后的列表 12345678910111213141516171819202122232425// bad&lt;ul&gt; &lt;li v-for=&quot;user in users&quot; v-if=&quot;user.isActive&quot; :key=&quot;user.id&quot; &gt; &#123;&#123; user.name &#125;&#125; &lt;/li&gt;&lt;/ul&gt;// good&lt;ul&gt; &lt;li v-for=&quot;user in activeUsers&quot; :key=&quot;user.id&quot;&gt; &#123;&#123;user.name&#125;&#125; &lt;/li&gt;&lt;/ul&gt;&lt;script&gt; computed: &#123; activeUsers: function () &#123; return this.users.filter(user =&gt; user.isActive) &#125;&#125;&lt;/script&gt; 为了避免渲染本应该被隐藏的列表，将v-if移至容器元素，这样只需检查一次，而不会对列表中的每项都检查 1234567891011121314151617181920// bad&lt;ul&gt; &lt;li v-for=&quot;user in users&quot; v-if=&quot;shouldShowUsers&quot; :key=&quot;user.id&quot; &gt; &#123;&#123; user.name &#125;&#125; &lt;/li&gt;&lt;/ul&gt;// good&lt;ul v-if=&quot;shouldShowUsers&quot;&gt; &lt;li v-for=&quot;user in users&quot; :key=&quot;user.id&quot; &gt; &#123;&#123; user.name &#125;&#125; &lt;/li&gt;&lt;/ul&gt; 为 组件 css d样式 设置 作用域 scoped，避免冲突。 除 顶级App组件，布局组件中css样式可以时全局的，其它的组件 都应该是 有作用域的。 覆写子组件的样式，可使用 &gt;&gt;&gt;操作符, 对于less或sass等预编译css，可使用/deep/ 私有property名，在使用模块作用域时要保持不允许外部访问的函数的 私有性。可在不考虑作为对外公共API的自定义私有property 使用$_前缀，并附带一个命名空间以避免同其他作者冲突。 12345678910111213// badvar myMixin = &#123; methods: &#123; update: function() &#123;&#125; &#125;&#125;// goodvar myMixin = &#123; methods: &#123; $_myMixin_update: function() &#123;&#125; &#125;&#125; 强烈推荐 (可增强可读性) 将每个组件都单独分出文件，这样在需要编辑或查找一个组件时，更快速找到。 单文件组件的文件名应该 始终 是 单词大小开头( 对自动补全友好 )，或 短横线连接（对大小写不敏感的文件系统 ） 应用特定样和约定的基础组件（即，展示类的，无逻辑，无状态的组件）名称应该全部以一个特定的前缀开头，比如Base,App 基础组件的名称*通常包含所包裹元素的名称**，比如 BaseButton,BaseTable。 12345// goodcomponents/|- BaseButton.vue|- BaseTable.vue|- BaseIcon.vue 只应该有单个活跃的实例的组件(单例组件)应该以The前缀命名，以表示其唯一性。 单例组件不意味着该组件只用于一个单页应用中，而是每个页面只使用一次。这些组件永远不接受prop 和父组件紧密耦合的子组件应该以父组件名作为前缀命名 123456789101112// badcomponents/|- TodoList.vue|- TodoItem.vue|- TodoButton.vue// goodcomponents/|- TodoList.vue|- TodoListItem.vue|- TodoLListItemButton.vue 组件名中的单词顺序，以高级别的（通常是一般化的描述）单词开头，以描述性的修饰符结尾 123456789// badcomponents/|- ClearSearchButton.vue|- RunSearchButton.vue//goodcomponents/|- SearchButtonClear.vue|- SerchButtonRun.vue 自闭合组件，在单文件组件、字符串模板、JSX中没有内容的组件应该是自闭合的； 但在DOM模板中永远不要，因为HTML不支持自闭合的自定义元素，只用官方的”空”元素(&lt;br/&gt; &lt;hr/&gt; &lt;input/&gt;)可以。 自闭合组件表示它们不仅没有内容，而是刻意没有内容 1234567891011// bad&lt;!-- 在 单文件组件、字符串模板、JSX中 --&gt;&lt;MyComponent&gt;&lt;/MyComponent&gt;&lt;!-- 在 DOM 模板--&gt;&lt;my-component&gt; // good &lt;!-- 在 单文件组件、字符串模板、JSX中 --&gt; &lt;MyComponent/&gt;&lt;!-- 在 DOM 模板--&gt; &lt;my-component&gt;&lt;/my-component&gt; 模板中的组件名大小写，对大多数项目，在单文件组件和字符串模板中组件名总是PascalCase,在DOM模板中总是kebab-case的。 另外，在所有的地方都使用kebab-case 亦可 在JS/JSX中的组件名应该始终是PascalCase的。对于只通过Vue.component定义的全局组件，推荐使用kebab-case 12345678910// goodVue.component(&#x27;my-component&#x27;, &#123;// ...&#125;)import MyComponent from &#x27;./MyComponent,vue&#x27;export default &#123; name: &#x27;MyComponent&#x27;&#125; prop名大小写，在声明是，使用camelCase，在模板或JSX中使用kebab-case 123456// goodprops: &#123;greetingText: String&#125;&lt;WelcomeMessage greeting-text=&quot;hi&quot;&gt; 组件模板应该只包含简单的表达式，复杂的表达式应该重构为计算属性 或 方法 应该把复杂的计算属性分割为尽可能多的简单计算属性 1234567891011121314151617181920212223// badcomputed: &#123; price: function () &#123; var basePrice = this.manufactureCost / (1 - this.profitMargin) return ( basePrice - basePrice * (this.discountPercent || 0) ) &#125;&#125;// goodcomputed: &#123; basePrice: function() &#123; return this.manufactureCost / (1 - this.profitMargin) &#125;, discount: function() &#123; return this.basePrice * (this.discountPercent || 0) &#125;, finalPrice: function() &#123; return this.basePrice - this.discount &#125;&#125; Vue 组件组件注册组建名组建名就是Vue.component的第一个参数，当直接在DOM中使用一个组件时，推荐使用W3C规范中的自定义组件名，使用kebab-case,在引用该组件时也必须使用kebab-case 1Vue.component(&#x27;my-component&#x27;, &#123;&#125;) 全局注册通过Vue.component来创建的组件是全局注册的，该组件可用在任何新创建的Vue根（new Vue）实例的模板中。全局组成的行为必须在根Vue实例创建之前发生 被频繁使用的基础 组件可配置webpack,实现自动化的全局注册。使用require.context来全局注册这些通用的基础组件。以下是在应用入口文件（src/main.js）中全局 注册/导入基础组件 12345678910111213141516171819202122232425262728293031import Vue from &#x27;vue&#x27;;import &#123; upperFirst, camelCase &#125; from &quot;lodash&quot;;const requireComponent = require.context( &#x27;./components&#x27;, // 组件目录的相对路径 false, // 是否查询其子目录 /Base[A-Z]\\w+\\.(vue|js)$/ // 匹配 基础组件文件名 `Base$&#123;...&#125;.vue`或`Base$&#123;...&#125;.js`);requireComponent.keys().forEach(fileName =&gt; &#123; console.log(&quot;requireComponent fileName &gt;&gt;&gt;&quot;, fileName); // 组件配置 const componentConfig = requireComponent(fileName); // 组件名 PascalCae const componentName = upperFirst( camelCase( fileName .split(&quot;/&quot;) .pop() .replace(/\\.\\w+$/, &quot;&quot;) ) ); // 全局注册， Vue.component( componentName, // 如果该组件选项是通过`export default`导出，则优先使用`.default1default` // 否则 回退 使用模块的根 componentConfig.default || componentConfig );&#125;); 局部注册在 components选项中定义想要使用的组件 12345678910var ComponentA = &#123;&#125;var ComponentB = &#123;&#125;new Vue(&#123;el: &#x27;#app&#x27;,components: &#123;&#x27;component-a&#x27;: ComponentA,&#x27;component-b&#x27;: ComponentB&#125;&#125;) PropProp大小写因HTML中的attribute名是大小写不敏感的，所以浏览器会把所有的大写字符解析为小写字符。所有在使用DOM模板时，camelCase的prop名 需要 使用其等价的 kebab-case Prop类型检查和验证123456789101112props: &#123; propA: &#123; type: Object, // 类型 default: function() &#123; // 默认值，对象和数组默认值必须从一个工厂函数返回 return &#123;message: &#x27;hello, jiang!&#x27;&#125; &#125;, // 自定义验证函数 validator: function(value) &#123; return value.length &lt; 15; &#125; &#125;&#125; 类型检测，type可以是以下原生构造函数，也可以是自定义的构造函数，并且通过instanceof来进行检查确认。 注意：Prop检查和验证 是 在一个组件实例创建之前，所有实例的property 在 default或 validator函数中是不可用的 String Number Boolean Object Function Data Array Symbol 传递静态或动态Prop在传递非字符串类型时，即便是静态的，仍然要使用v-bind来告诉Vue，其是JavaScript表达式，而不是一个字符串 123456789&lt;!-- 即便 `42` 是静态的，我们仍然需要 `v-bind` 来告诉 Vue --&gt;&lt;!-- 这是一个 JavaScript 表达式而不是一个字符串。--&gt;&lt;blog-post v-bind:likes=&quot;42&quot;&gt;&lt;/blog-post&gt;&lt;!-- 传递的prop 是 字符串 &#x27;42&#x27; --&gt;&lt;blog-post likes=&quot;42&quot;&gt;&lt;/blog-post&gt;&lt;!-- 用一个变量进行动态赋值。--&gt;&lt;blog-post v-bind:likes=&quot;post.likes&quot;&gt;&lt;/blog-post&gt; 传入一个对象的所有property使用不带参数的v-bind,可将一个对象的所有property都作为prop传入 123456789101112post: &#123; id: 1, title: &#x27;Jiang with Vue&#x27;&#125;&lt;blog-post v-bind=&quot;post&quot;&gt;&lt;/blog-post&gt;// 等价于&lt;blog-post v-bind:id=&quot;post.id&quot; v-bind:title=&quot;post.title&quot;&gt;&lt;/blog-post&gt; 单项数据流prop数据都是从父级流向子级的，即父级prop的更新会向下流到子组件。例外，每次父级组件发生变更时，子组件中所有的prop也将更新为最新的值。这意味不应该在子组件内部改变prop。但有2种常见的视图变更prop的情况： prop用来传递一个初值，子组件内后续可能会变更。此情况，最好定义一个本地的data property 并将这个prop 用作其初始值 123456props: [&#x27;initialCounter&#x27;],data: function() &#123; return &#123; counter: this.initialCounter &#125;&#125; prop作为原始的值传入并需要进行转换。此情况，最好使用这个prop来定义一个计算属性 1234567props: [&#x27;name&#x27;],computed: &#123; normalizedName: function() &#123; return this.name.trim().toLowerCase() &#125;&#125; 非 Prop的 Attribute非prop的 attribute 会被添加到组件的根元素上 对于绝大多数 attribute 来说，从外部提供给组件的值会替换到组件内部 根元素 设置好的值。但 class和 style 会被合并。 如果不希望组件的根元素继承 attribute，可以在组件的选项中设置 iheritAttrs: false,从而禁用 attribute 继承 123Vue.component(&#x27;my-component&#x27;, &#123; inheritAttrs: false&#125;) 例外，实例的$attrs，包含了父作用域中不作为 prop 被识别 (且获取) 的 attribute 绑定 ，class，style 除外，在通过v-bind=&quot;$attrs&quot;传入内部组件 1234567891011121314Vue.component(&#x27;base-input&#x27;, &#123; inheritAttrs: false, props: [&#x27;label&#x27;, &#x27;value&#x27;], template: ` &lt;label&gt; &lt;input v-bind=&quot;$attrs&quot; v-bind:value=&quot;value&quot; v-on:input=&quot;$emit(&#x27;input&#x27;, $event.target.value)&quot; /&gt; &lt;/label&gt; `&#125;) 使用该组件就像使用原始的input元素一样设置attribute,因为这些attribute都被设置在组件内的 input 元素上，而非根元素上 12345&lt;base-input v-model=&quot;username&quot; required placeholder=&quot;Enter your username&quot;&gt;&lt;/base-input&gt; 自定义事件事件名触发事件的事件名必须要完全匹配 监听该事件所用的名称，并且v-on事件监听器在DOM模板中会别自动转换为全小写，v-on:myEvent被转换成v-on:myevent,因此推荐始终使用kebab-case的事件名 自定义组件的v-model组件的v-model默认利用名为value的prop，和名为input的事件，·**model选项可以定制prop 和 event**，这样就可以将valueprop用作其他地方。 1234567891011121314151617181920212223&lt;template&gt; &lt;input type=&quot;checkbox&quot; v-bind:checked=&quot;checked&quot; v-on:change=&quot;$emit(&#x27;change&#x27;, $event.target.checked)&quot; /&gt;&lt;/template&gt;&lt;script&gt;export default &#123; name: &quot;BaseCheckobx&quot;, model: &#123; prop: &quot;checked&quot;, event: &quot;change&quot; &#125;, props: &#123; checked: Boolean &#125;, data() &#123; return &#123;&#125;; &#125;&#125;;&lt;/script&gt; 将原生事件绑定到组件v-on的.native修饰符，监听原生事件。 $listeners是一个对象，包含了作用于该组件上 v-on监听器，不包括带.native修饰符的.可通过v-on=&quot;$isteners&quot;传入内部组件的某个特定的子元素 1234567891011121314151617181920212223242526272829303132Vue.component(&#x27;base-input&#x27;, &#123; inheritAttrs: false, props: [&#x27;label&#x27;, &#x27;value&#x27;], computed: &#123; inputListeners: function () &#123; var vm = this // `Object.assign` 将所有的对象合并为一个新对象 return Object.assign(&#123;&#125;, // 我们从父级添加所有的监听器 this.$listeners, // 然后我们添加自定义监听器， // 或覆写一些监听器的行为 &#123; // 这里确保组件配合 `v-model` 的工作 input: function (event) &#123; vm.$emit(&#x27;input&#x27;, event.target.value) &#125; &#125; ) &#125; &#125;, template: ` &lt;label&gt; &#123;&#123; label &#125;&#125; &lt;input v-bind=&quot;$attrs&quot; v-bind:value=&quot;value&quot; v-on=&quot;inputListeners&quot; &gt; &lt;/label&gt; `&#125;) 此时&lt;base-input&gt;组件就是一个完全透明的&lt;input&gt;包裹器,可以完全像一个普通的&lt;input&gt;元素一样 使用。 12345&lt;!-- 监听 foucs，失败，$listeners 不包含带`.native`的`v-on`监视器 --&gt;&lt;base-input v-on:focus.native=&quot;onFocus&quot;&gt;&lt;/base-input&gt;&lt;!-- 可正常监听 foucs --&gt;&lt;base-input v-on:focus=&quot;onFocus&quot;&gt;&lt;/base-input&gt; 动态组件&lt;component&gt;vue的内置组件，动态组件，依据is的值，来决定那个组件被渲染.is的值，可以是已注册组件的名字，或 一个组件的选项对象。 使用&lt;keep-alive&gt;元素将动态组件包裹起来，可使失活的组件被缓存 123&lt;keep-alive&gt;&lt;component :is=&quot;currentTabComponent&quot;&gt;&lt;/component&gt;&lt;/keep-alive&gt; 异步组件在大型 应用中，需要将应用分割成多个小模块，并且只在需要的时候才从服务器加载该模块。Vue允许 以一个工厂函数的方式定义组件，并异步解析。只在该组件 被渲染的时候才会触发该工厂函数，并会把结果缓存起来 供以后重新渲染。 也可以在工厂 函数返回一个Proomise,通过webpack和import语法，可写成 如下： 1234567891011// 全局注册Vue.component( &#x27;async-component&#x27;, // 这个 `import` 函数会返回一个 `Promise` 对象。 () =&gt; import(&#x27;./my-async-component&#x27;))// 局部注册 components: &#123; &#x27;async-component&#x27;: () =&gt; import(&#x27;./my-async-component&#x27;) &#125; 处理异步组件的加载状态12345678910111213const AsyncComponent = () =&gt; (&#123; // 需要加载的组件 (应该是一个 `Promise` 对象) component: import(&#x27;./MyComponent.vue&#x27;), // 异步组件加载时使用的组件 loading: LoadingComponent, // 加载失败时使用的组件 error: ErrorComponent, // 展示加载时组件的延时时间。默认值是 200 (毫秒) delay: 200, // 如果提供了超时时间且组件加载也超时了， // 则使用加载失败时使用的组件。默认值是：`Infinity` timeout: 3000&#125;) 过渡 、动画Vue在插入、更新、移除DOM时，提供了4种方式的应用过渡效果。 在CSS 过渡和动画中自动应用class 配合使用第三方CSS动画库，如 Animate.css 在过渡钩子函数中使用JavaScript直接操作DOM 配合使用第三方JavaScript动画库，如 Velocity.js 基本过渡的类名在进入/离开的过渡中，会有6个class切换 v-enter： 过渡开始状态 v-enter-active：过渡生效状态，此类被用来定义进入过渡的过程时间、延迟、曲线函数 v-enter-to：过渡结束状态 v-leave： 离开过渡的开始状态 v-leave-active：离开过渡的生效状态，此类被用来定义 离开过渡的 过程时间、延迟、曲线函数 v-leaver-to： 离开过渡的结束状态 没有设置name attribute 的&lt;transition&gt;时,v-这些类名的默认前缀。设置了name attribute 的 &lt;transition name=&quot;myTransitionName&quot;&gt;，则name的值会替换V, 即myTransitionName-是这些类名的前缀 自定义过渡的类名通过&lt;transition&gt;一些的 attrubute 可定义过渡的类名。自定义过渡的类名优先级 _高于_普通类名，因此可轻松的使用其他第三方CSS过渡/动画库。 enter-class enter-active-class enter-to-class leave-class leave-active-class leave-to-class 结合Animate.css 12345678910111213141516171819202122 &lt;div class=&quot;example-2&quot;&gt; &lt;button v-on:click=&quot;show2 = !show2&quot;&gt;Toggle&lt;/button&gt; &lt;transition name=&quot;custom-classes-transition&quot; enter-active-class=&quot;animate__animated animate__tada&quot; leave-active-class=&quot;animate__animated animate__bounceOutRight&quot; &gt; &lt;p v-if=&quot;show2&quot;&gt;Jiang Jiang&lt;/p&gt; &lt;/transition&gt; &lt;/div&gt;&lt;script&gt;import &quot;animate.css/animate.css&quot;; // 引用外部 animate 样式export default &#123; name: &quot;TransitionDemo&quot;, data() &#123; return &#123; show1: true, show2: true &#125;; &#125;&#125;;&lt;/script&gt; JavaScript钩子函数JS钩子函数，其实就是transition组件上的事件： before-enter,befroe-leave enter,leave afer-enter,after-leave 当只用javaScript过渡时，在enter和leave中必须使用done进行回调，否则，它们被同步调用，过渡会立即完成。 对于仅使用JavaScript过渡的元素，transition 组件的cssprop设置为false(v-bind:css=&quot;false&quot;),Vue会跳过CSS检查，将只通过事件 触发 注册的JavaScript钩子。 结合Velocity.js 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354 &lt;div id=&quot;example-3&quot; style=&quot;width:150px&quot;&gt; &lt;button v-on:click=&quot;show3 = !show3&quot;&gt;Toggle&lt;/button&gt; &lt;transition v-on:before-enter=&quot;beforeEnter&quot; v-on:enter=&quot;enter&quot; v-on:leave=&quot;leave&quot; v-bind:css=&quot;false&quot; &gt; &lt;p v-if=&quot;show3&quot;&gt;volecity.js&lt;/p&gt; &lt;/transition&gt; &lt;/div&gt;&lt;script&gt;import &quot;animate.css/animate.css&quot;;import Velocity from &quot;velocity-animate&quot;; // 引用velocity.jsexport default &#123; name: &quot;TransitionDemo&quot;, data() &#123; return &#123; show1: true, show2: true, show3: true &#125;; &#125;, mounted() &#123; // &#125;, methods: &#123; beforeEnter(el) &#123; console.log(&quot;el&gt;&gt;&quot;, el); el.style.opacity = 0; el.style.transformOrigin = &quot;left&quot;; &#125;, enter(el, done) &#123; Velocity(el, &#123; opacity: 1, fontSize: &quot;1.4em&quot; &#125;, &#123; duration: 300 &#125;); Velocity(el, &#123; fontSize: &quot;1em&quot; &#125;, &#123; complete: done &#125;); &#125;, leave(el, done) &#123; Velocity(el, &#123; translateX: &quot;15px&quot;, rotateZ: &quot;50deg&quot; &#125;, &#123; duration: 600 &#125;); Velocity(el, &#123; rotateZ: &quot;100deg&quot; &#125;, &#123; loop: 2 &#125;); Velocity( el, &#123; rotateZ: &quot;45deg&quot;, translateY: &quot;30px&quot;, translateX: &quot;30px&quot;, opacity: 0 &#125;, &#123; complete: done &#125; ); &#125; &#125;&#125;;&lt;/script&gt; 过渡模式&lt;transition&gt;的默认行为-进入和离开同时发生,但是在滑动过渡时不能满足要求，所以Vue提供了过渡模式, mode 12&lt;transition name=&quot;fade&quot; mode=&quot;out-in&quot;&gt;&lt;/transition&gt; in-out: 新元素先进行过渡，完成后 当前元素再过渡离开 out-in： 当前元素先进行过渡，完成后 新元素再过渡进入 单元素/组件的 过渡Vue提供 transition的封装组件，以下情况，可以元素/组件 添加 进入/离开 过渡 条件渲染（v-if） 条件展示（v-show） 动态组件 （is） 组件根节点 简单例子： 12345678910111213141516171819202122232425262728293031323334&lt;template&gt; &lt;div id=&quot;example-1&quot;&gt; &lt;h2&gt;Transitions &amp; Animation&lt;/h2&gt; &lt;div&gt; &lt;button v-on:click=&quot;show = !show&quot;&gt;Toggle&lt;/button&gt; &lt;transition name=&quot;fade&quot;&gt; &lt;p v-if=&quot;show&quot;&gt;Jiang Jiang&lt;/p&gt; &lt;/transition&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; name: &quot;TransitionDemo&quot;, data() &#123; return &#123; show: true &#125;; &#125;&#125;;&lt;/script&gt;&lt;style lang=&quot;less&quot; scoped&gt;.fade-enter-active,.fade-leave-active &#123; transition: opacity 0.5s;&#125;.fade-enter,.fade-leave-to &#123; opacity: 0;&#125;&lt;/style&gt; 多个元素的过渡当有相同标签名的元素时，需要通过给key设置唯一的值来标记，以让Vue区分它们，否则Vue未来效率会替换相同标签内部的内容。所以，在给&lt;transition&gt;组件中多个元素设置key是一个更好的实践。 通过给同一个元素的key设置不同状态来代替v-if和v-else 12345&lt;transition&gt; &lt;button v-bind:key=&quot;isEditing&quot;&gt; &#123;&#123;isEditing ? &#x27;Save&#x27; : &#x27;Edit&#x27;&#125;&#125; &lt;/button&gt;&lt;/transition&gt; 例外，多个v-if的多元素的过渡，也可重写为绑定了动态的key的单个元素 1234567891011121314151617181920212223242526272829303132333435&lt;transition&gt; &lt;button v-if=&quot;docState === &#x27;saved&#x27;&quot; key=&quot;saved&quot;&gt; Edit &lt;/button&gt; &lt;button v-if=&quot;docState === &#x27;edited&#x27;&quot; key=&quot;edited&quot;&gt; Save &lt;/button&gt; &lt;button v-if=&quot;docState === &#x27;editing&#x27;&quot; key=&quot;editing&quot;&gt; Cancel &lt;/button&gt;&lt;/transition&gt;// 重写&lt;transition&gt; &lt;button v-bind:key=&quot;docState&quot;&gt; &#123;&#123; buttonMessage &#125;&#125; &lt;/button&gt;&lt;/transition&gt;&lt;script&gt;// ... data() &#123; return &#123; docState: &#x27;Save&#x27; &#125;&#125;,computed: &#123; buttonMessage: function () &#123; switch (this.docState) &#123; case &#x27;saved&#x27;: return &#x27;Edit&#x27; case &#x27;edited&#x27;: return &#x27;Save&#x27; case &#x27;editing&#x27;: return &#x27;Cancel&#x27; &#125; &#125;&#125;&lt;/script&gt; 多个组件的过渡多个组件不需要使用key ，只需要使用动态组件即可 12345678910111213141516171819202122232425262728293031323334&lt;div id=&quot;example-4&quot;&gt; &lt;label&gt; &lt;input type=&quot;radio&quot; name=&quot;&quot; id=&quot;&quot; value=&quot;v-a&quot; v-model=&quot;view&quot; /&gt;A&lt;/label &gt; &lt;label&gt; &lt;input type=&quot;radio&quot; name=&quot;&quot; id=&quot;&quot; value=&quot;v-b&quot; v-model=&quot;view&quot; /&gt;B&lt;/label &gt; &lt;transition name=&quot;component-fade&quot; mode=&quot;out-in&quot;&gt; &lt;component v-bind:is=&quot;view&quot;&gt;&lt;/component&gt; &lt;/transition&gt;&lt;/div&gt;&lt;script&gt; // .... components: &#123; &quot;v-a&quot;: &#123; // template: &quot;&lt;div&gt;aaaa&lt;/div&gt;&quot; render: h =&gt; h(&quot;div&quot;, &quot;aaaa&quot;) &#125;, &quot;v-b&quot;: &#123; // template: &quot;&lt;div&gt;bbbbb&lt;/div&gt;&quot; render: h =&gt; h(&quot;div&quot;, &quot;bbbb&quot;) &#125; &#125;,&lt;/script&gt;&lt;style&gt;.component-fade-enter-active, .component-fade-leave-active &#123; transition: opacity .3s ease;&#125;.component-fade-enter, .component-fade-leave-to &#123; opacity: 0;&#125;&lt;/style&gt; 列表过渡transition的过渡，只是 单个节点 同一时间渲染多个节点中的一个 &lt;transition-group&gt;，同时渲染整个列表，或使用v-for时同时渲染多个节点。该组件的特点： 不同transition，它会以一个 真实元素呈现，默认span,通过tag attribute 更换为其他元素 内部元素总需要提供唯一的key值 CSS过渡的类会应用到内部元素中，而不是这个组件/容器本身 内部元素在改变定位的过程中，也可以添加过渡效果。使用新增的过渡的类名 v-move，通过name来自定义前缀，通过move-class attribute 手动设置 可复用的过渡要创建一个可复用的过渡组件，只需将&lt;transition&gt;，transition-group作为根组件，然后将任何子组件放置其中即可 动态过渡 过渡 attribute 都时可以动态绑定的，通过name来绑定动态值，从而在不同的过渡间切换 通过事件钩子获取上下文中的所有数据，即 可根据组件的状态，设置不同的Javascript过渡表现 状态过渡对于数据元素本身的动效，例如 _数字和运算_，可以结合Vue的响应式和组件系统，使用第三方库来实现过渡状态。 使用GreenSock，通过watch,监听数据更新，应用过渡状态 混入 Mixin混入一般用来分发Vue组件中可复用的功能。一个混入对象可以包含任意组件的选项。当组件属于混入对象时，所有混入对象将混入“进该组件本身的选项。 选项合并当组件和混入对象含有同名选项时，这些选项按选项合并策略进行”合并“ 数据对象data在内部会进行递归合并，在发生冲突时以组件内数据优先 同名钩子函数将合并成一个数组，因此都将被调用。且混入对象的钩子函数将在组件自身钩子之前被调用 值为对象的选项，例如methods,components,directives,computed,将被合并为同一对象，当有键名冲突时，取组件对象的键值对。 自定义选项合并策略如果想要自定义选项合并策略，可以向Vue.configin.optionMergeStrategies添加一个函数： 12345678910const merge = Vue.config.optionMergeStrategies.computedVue.config.optionMergeStrategies.vuex = function (toVal, fromVal) &#123; if (!toVal) return fromVal if (!fromVal) return toVal return &#123; getters: merge(toVal.getters, fromVal.getters), state: merge(toVal.state, fromVal.state), actions: merge(toVal.actions, fromVal.actions) &#125;&#125; 自定义指令如果需要对普通DOM元素进行底层操作，可使用自定义指令。全局注册使用Vue.directive(),局部注册, 使用组件的选项directives 利用指令，实现输入框聚焦 12345678910111213141516// 全局注册Vue.directive(&#x27;focus&#x27;, &#123; inserted: function(el) &#123; el.focus(); &#125;&#125;);// 组件内 局部注册 directives: &#123; focus: &#123; inserted: function(el) &#123; el.focus(); &#125; &#125; &#125;, 钩子 函数指令对象可以提供5个可选的钩子函数 bind： 只调用一次，指令在第一次 绑定 到元素时调用。在这里通常 进行 一次性的初始化设置 inserted：被绑定元素插入父节点时调用，但不一定被插入文档，仅仅保证了父节点的存在 unpdate： 所在组件的VNode更新时调用，可能发生在其子VNode更新之前 componentUpdated：所在组件的VNode及其子VNode全部更新后调用 unbind： 只调用一次，指令与元素解绑时调用 钩子函数可接受4个参数，除了el外，其他参数都应该是可读的，切勿修改 el： 指令所绑定的元素，可用来直接操作DOM binding： 一个对象，包含如下property name：指令名 不包含v-前缀 value：指令绑定的值 oldValue：指令绑定的前一个值 expression：字符串形式的指令表达式 arg： 传给指令的参数。 例如：v-my-directive:foo,参数 为foo modifiers：包含修饰符的对象。例如：v-my-directive:foo.bar.zar,修饰符对象为&#123;bar:true, zar:true&#125; vnode： Vue编译生成的虚拟节点 oldVnode：上一个虚拟节点","categories":[{"name":"技术总结","slug":"技术总结","permalink":"https://better-jiang.github.io/categories/%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%93/"}],"tags":[{"name":"vue","slug":"vue","permalink":"https://better-jiang.github.io/tags/vue/"},{"name":"面试","slug":"面试","permalink":"https://better-jiang.github.io/tags/%E9%9D%A2%E8%AF%95/"}]},{"title":"Typora简单指南","slug":"Typora简单指南","date":"2020-05-13T07:19:12.000Z","updated":"2023-02-03T12:14:22.421Z","comments":true,"path":"2020/05/13/Typora简单指南/","link":"","permalink":"https://better-jiang.github.io/2020/05/13/Typora%E7%AE%80%E5%8D%95%E6%8C%87%E5%8D%97/","excerpt":"","text":"概述Markdown是由Daring Fireball创造，这是其原始的 指南，但它的语法在不同的解析器喝编辑器之间是不同的。Typora试图去跟随[ GitHub Flavored Markdown，但仍然有些小的不兼容。 块级元素段落和换行段落是一个或多个连续的文本行。在markdown源码中，段落由两个或多个空行分隔。但是,在Typora中，只需要一行空白（按回车一次）就可以创建一个新的段落。 按 Shift + Return ** 可以创建单个换行符。大多数的markdown解析器会忽略单个换行符**，因此，为了让其他markdown解析器也能识别换行符，需要在行尾留下两个空格，或者插入&lt;br&gt; 标题 Header在一行的开始使用1-6个#字符，对应标题的1-6级。快捷键 : Ctrl 1 - Ctrl 6 123# H1## H2###### H6 引用块 Block quote使用&gt;字符后跟所要引用的内容。添加不同级别的&gt;可实现嵌套的引用块 123456&gt; blockquote 1 &gt;&gt; blockqoute 1&gt; anthoer blockqoute 2 block quote 1 nested block quote 3 nested block quote 3 block quote 1 block quote 2 列表 List*：无序列表，1.：有序列表 12345678无效列表* Red* Green* Blue有序列表1. Red2. Green3. Blue Red Green Blue Red Green Blue 任务列表 Task List[ ]：未完成, [x]：已完成 123- [ ] task list item- [ ] incomplete- [x] completed task list item incomplete completed completed 代码块 Code Block键入``` + type + 回车，创建带语言高亮的代码块 123456789101112an example​```function test() &#123;consle.log(&#x27;jiang&#x27;)&#125;​```语法高亮​```jsfunction test() &#123;consle.log(&#x27;jiang&#x27;)&#125;​``` + 回车`，语法不会高亮1 function test() {consle.log(‘jiang’)} 1234567````js + 回车 `，语法会高亮显示```jsfunction test() &#123;consle.log(&#x27;jiang&#x27;)&#125; 数学公式Typora 支持使用 Tex/LaTeX语法来呈现数学公式，该渲呈现过程是由MathJax处理 参考数学公式- 在线编辑器 在MathJax中可用的Tex命令 块间数学公式 Math Block公式分隔符：$$...$$ 12345678$$\\begin&#123;align*&#125; y = y(x,t) &amp;= A e^&#123;i\\theta&#125; \\\\ &amp;= A (\\cos \\theta + i \\sin \\theta) \\\\&amp;= A (\\cos(kx - \\omega t) + i \\sin(kx - \\omega t)) \\\\&amp;= A\\cos \\Big(\\frac&#123;2\\pi&#125;&#123;\\lambda&#125;x - \\frac&#123;2\\pi v&#125;&#123;\\lambda&#125;t\\Big)\\end&#123;align*&#125;$$ $$\\begin{align*}y = y(x,t) &amp;= A e^{i\\theta} \\&amp;= A (\\cos \\theta + i \\sin \\theta) \\&amp;= A (\\cos(kx - \\omega t) + i \\sin(kx - \\omega t)) \\&amp;= A\\cos \\Big(\\frac{2\\pi}{\\lambda}x - \\frac{2\\pi v}{\\lambda}t\\Big)\\end{align*}$$ 行内数学公式 Inline Math默认公式分隔符：\\(...\\)，或者在Typora偏好设置-&gt;Markdown，勾选Inline Math,就可以使用$...$分隔符 行内公式1：$\\frac{2\\pi}{T}$ 化学式 Chemistry Expressions公式分隔符：$\\ce&#123;...&#125;$ 例如$\\ce&#123;CO2 + C -&gt; 2 CO&#125; $: $ \\ce{co2 + c -&gt; 2 co} $，$\\ce&#123;H20&#125; $: $\\ce{H2O}$ 表格 Table键入|First Header|Second Header| 然后按回车键，创建一个2列的表格 通过在标题行中包含的冒号(:)，可以设置该列的文本对齐方式 12345| Left-Aligned | Center Aligned | Right Aligned || :------------ |:---------------:| -----:|| col 3 is | some wordy text | $1600 || col 2 is | centered | $12 || zebra stripes | are neat | $1 | Left-Aligned Center Aligned Right Aligned col 3 is some wordy text $1600 col 2 is centered $12 zebra stripes are neat $1 脚注 Footnote使用[^fn1]来创建引用脚注标识，使用[^fn1]:脚注内容来创建脚注内容 1234You can create footnotes like this[^fn1] and this[^fn2].[^fn1]: Here is the *text* of the first **footnote**.[^fn2]: Here is the *text* of the second **footnote**. 脚注1^1 ，脚注2^2 水平线 Horizontal Line使用***或者---来画一条水平线 目录 Table Of Contents （TOC）键入[toc]然后按回车键，创建文档的目录部分,TOC从文档中提取所有的标题，并且其内容会自动更新 [toc] 行内元素链接 LinkMarkdown支持3种链接样式 行内链接 Inline Link 12This is [baidu](http://baidu.com &quot;百度&quot;) inline linkThis is [刘振江-个人博客](https://better-jiang.github.io/) has no title attribut. This is baidu inline linkThis is 刘振江-个人博客 has no title attribut. 内部链接 Internal Link 使用header元素的名称作为href，可创建一个类似“书签”的内部链接，并在单击后跳转到该部分 1Hold down Ctrl and click on [引用块 Block quote](#引用块 Block quote) to jump to header `引用块 Block quote` Hold down Ctrl and click on [引用块 Block quote](#引用块 Block quote) to jump to header 引用块 Block quote 引用链接 Reference Link 1234This is [刘振江-个人博客][lzj-blog] reference-style link.Then, anywhere in the document,you define your link label on a line by itself like this: [lzj-blog]: https://better-jiang.github.io/ &quot;刘振江-个人博客，关于技术总结，工作心得，随便感悟&quot; This is 刘振江-个人博客 reference-style link. Then, anywhere in the document,you define your link label on a line by itself like this: URLsTypora允许用链接的形式插入url，并用&lt;&gt;包装。例如 &lt;betterjiangjiang@gmail.com&gt;将成为&#x62;&#x65;&#116;&#x74;&#x65;&#114;&#x6a;&#105;&#x61;&#x6e;&#103;&#106;&#105;&#97;&#x6e;&#103;&#x40;&#103;&#x6d;&#x61;&#x69;&#x6c;&#x2e;&#99;&#111;&#x6d; &lt;www.baidu.com&gt; Typora 还会自动链接那些没有尖括号包装的准url,（例如： www.gogle.com） 图片 /Image12![Alt text](/path/to/img.jpg)![Alt text](/path/to/img.jpg &quot;Optonal title&quot;) 强调/加重 Emphasis使用一个星号（*）或者下划线(_)包装需要强调的文本，同HTML种&lt;em&gt;标签 12*Single asterisks*_single underscores_ Empjasis Single asterisksEmpjasis Sngle underscores 加粗 Strong两个星号（*）或者下划线(_)会使其包含的内容被HTML&lt;strong&gt;标签包装 12**double asterisks**__double underscores__ produces: double asteriks double underscores 代码 Code使用反引号 (`),(使用了双反引号来显示反引号)，来在行内插入代码 1Use the `Printf()` function. Use the Printf() function. 删除线 Strikethrough使用双波浪线~~包裹内容。~~Mistaken text~~ ，变成 Mistaken text 表情符号 Emoji123:smile: smile emoji:cry: sad emoji:laughing: laughing :smile: smile emoji :cry: cry emoji :laughing: laughing emoji 行内数学公式 Inline Math使用$包裹 LaText命令。例如 $\\lim_&#123;x \\to \\infty&#125; \\exp(-x) = 0$,即 $\\lim_{x \\to \\infty} \\exp(-x) = 0$ 上/下脚标、高亮 Subscript/SuperScript、Highlight要使用该功能，Typora首先要在偏好设置的Markdown选项中启用它们 使用~包裹下标内容，例如 H~2~O,H2O 使用^包裹上标内容，例如 X^2^,X^2^ 使用==包括高亮内容，例如 ==highlight==，==hightlight== HTML可以使用HTML来设计纯Markdown不支持的样式内容。例如 使用&lt;span style=&quot;color:red&quot;&gt;this text is red&lt;/span&gt;添加红色文本 如果明天，我依然 爱 😔你！ 下划线 UnderlineMarkdown中没有指定下划线，但是支持属于HTML中的下划线标签&lt;u&gt; &lt;u&gt;Underline&lt;/u&gt;，Underline 嵌入内容 Embed Content有一些网站提供了基于iframe的嵌入代码，可将其粘贴到Typora中。 1&lt;iframe height=&#x27;265&#x27; scrolling=&#x27;no&#x27; title=&#x27;Fancy Animated SVG Menu&#x27; src=&#x27;http://codepen.io/jeangontijo/embed/OxVywj/?height=265&amp;theme-id=0&amp;default-tab=css,result&amp;embed-version=2&#x27; frameborder=&#x27;no&#x27; allowtransparency=&#x27;true&#x27; allowfullscreen=&#x27;true&#x27; style=&#x27;width: 100%;&#x27;&gt;&lt;/iframe&gt; See the Pen Solution 10 - Intro to Vue by 江 (@better-jiang) on CodePen. 画图 Draw DiagramTypora在从偏好设置中启用后，会支持一些图表的Markdown扩展。此外，你应该注意到图表是不受标准Markdown、CmmonMark或GFM支持的。因此，建议插入图表的图片，而不是直接在Markdown中写它们。 时序/序列图 Sequence Diagram该特性使用js-sequence,它将下面的代码块转化为一个时序图 123Alice-&gt;Bob: Hello Bob, how are you ?Note right of Bob: Bob ThinksBob--&gt;Alice: I am good thanks! 123Alice-&gt;Bob: Hello Bob, how are you ?Note right of Bob: Bob ThinksBob--&gt;Alice: I am good thanks! 语法下图显示了js-sequence绘制时序图的语法 用法js-sequence-diagrams依赖 Snap.svg和 Underscore.js（或者 lodash） 1234&lt;script src=&quot;webfont.js&quot;&gt;&lt;/script&gt;&lt;script src=&quot;snap.svg-min.js&quot;&gt;&lt;/script&gt;&lt;script src=&quot;underscore-min.js&quot;&gt;&lt;/script&gt;&lt;script src=&quot;sequence-diagram-min.js&quot;&gt;&lt;/script&gt; 12345&lt;div id=&quot;diagram&quot;&gt;&lt;/div&gt;&lt;script&gt; var diagram = Diagram.parse(&quot;A-&gt;B: Message&quot;); diagram.drawSVG(&quot;diagram&quot;, &#123;theme: &#x27;hand&#x27;&#125;);&lt;/script&gt; 流程图 Flowchart该特性使用flowchart.js,它将下面代码块转化成一个流程图 12345678st=&gt;start: Startop=&gt;operation: Your Operationcond=&gt;condition: Yes or No?e=&gt;endst-&gt;op-&gt;condcond(yes)-&gt;econd(no)-&gt;op 12345678st=&gt;start: Startop=&gt;operation: Your Operationcond=&gt;condition: Yes or No?e=&gt;endst-&gt;op-&gt;condcond(yes)-&gt;econd(no)-&gt;op 一个比较复杂的demo，locize简单使用指南123456789101112131415161718192021222324252627st=&gt;start: Imporve your110n process!e=&gt;end: Continue to have fun! :&gt;https://youtu.be/YQryHo1iHb8[blank]op1=&gt;operation: Go to locize.com :&gt;https://locize.com[blank]sub1=&gt;subroutine: Read the awesomenesscond=&gt;condition: Interested to getting started?io=&gt;inputoutput: Register :&gt;https://www.locize.app/register[blank]sub2=&gt;subroutine: Read about inprovingyour localization workflowor anther source :&gt;https://medium.com/@adrai/8-signs-you-should-improve-your-localization-process-3dc075d53998[blank]op2=&gt;operation: Login :&gt;https://www.locize.app/login[blank]cond2=&gt;condition: Valid password?cond3=&gt;condition: Reset password?op3=&gt;operation: Send emailsub3=&gt;subroutine: Create a demo projectsub4=&gt;subroutine: Start your real projectio2=&gt;inputoutput: Subscribest-&gt;op1-&gt;sub1-&gt;condcond(yes)-&gt;io-&gt;op2-&gt;cond2cond2(no)-&gt;cond3cond3(no,bottom)-&gt;op2cond3(yes)-&gt;op3op3(right)-&gt;op2cond2(yes)-&gt;sub3sub3-&gt;sub4-&gt;io2-&gt;econd(no)-&gt;sub2(right)-&gt;op1 MermaidTpora 还集成了mermaid，它支持序列图，流程图，甘特图，类图，状态图和饼图。 123​&lt;pre class=&quot;mermaid&quot;&gt;graph TBStart --&gt; Stop​&lt;/pre&gt; graph TB Start --> Stop flowchartGraph该语句声明一个新的流程图，及其布局方向。使用%%来注释 TB - top bottom BT - bottom top RL - right left LR - left right TD - 同TB，top bottom 12graph LRStart --&gt; Stop graph LR Start --> Stop Nodes &amp; shapes 节点和形状 节点使用id声明,节点框内默认显示id 12graph LRid graph LR id 可在id不同的框设置文本 12graph LRid1[This is the text in the box] graph LR id1[This is the text in the box] 带圆角的节点 12graph LRid2(node with round edges) graph LR id2(node with round edges) 菱形形的节点 12graph LRid3&#123;&quot;node(rhombus)&quot;&#125; graph LR id3{\"node(rhombus)\"} 平行四边形 12graph LRid4[/Parallelogram/] graph LR id4[/\"node(parallelogram)\"/] Links between nodes 节点之间的联系 带箭头的连接 12graph LRA --&gt; B graph LR A --> B 带文本的连接 123456graph LRA --&gt;|text|B// orgraph LRc -- text --&gt; D graph LR A -->|text|B c -- text --> D 虚线连接 12graph LRA -. text .-&gt; B graph LR A -. text .-> B 粗细连接 12graph LRA == text ==&gt; B graph LR A == text ==> B 节点链 12graph LRA --&gt; B &amp; C &amp; D --&gt; E graph LR A --> C --> D 子图 1234567891011graph TB c1--&gt;a2 subgraph one a1--&gt;a2 end subgraph two b1--&gt;b2 end subgraph three c1--&gt;c2 end graph TB c1-->a2 subgraph one a1-->a2 end subgraph two b1-->b2 end subgraph three c1-->c2 end Sequence diagrams语法 Syntax 参与者/角色（actor），可隐式/显示定义，在图中按定义顺序出现，也可指定其呈现顺序 12345678sequenceDiagramparticipant John participant A as AliceA-&gt;&gt;John: Hello John, how are you?John--&gt;&gt;A: Great!A-&gt;&gt;Shery: Hello Shery ? sequenceDiagram participant John participant A as Alice A->>John: Hello John, how are you? John-->>A: Great! A->>Shery: Hello Shery ? 消息 Messages1[Actor][Arrow][Actor]: Message text 6中箭头类型 Type Description -&gt; 带箭头的实线 –&gt; 不带箭头的虚线 -&gt;&gt; 带箭头的实线 –&gt;&gt; 不带箭头的虚线 -x 末尾带叉号的实线 –x 末尾带叉号的虚线 sequenceDiagram A->B: Solid line without arrow B-->A: Dotted line without arrow A->>B: Solid line with arrow B->>A: Dotted lne with arrow A-xB: Solid line with a cross at the end B--xA: Dotted line with a cross at the end 激活 Activation使用**activate和deactive**声明，激活或停用某个角色，快捷方法，在消息箭头添加+,-后缀。 sequenceDiagram A->>J: Hello, how are you? activate J J-->>A: Gread! deactivate J 同一角色可叠加激活 12345sequenceDiagramA-&gt;&gt;+J: Hello John, how are you?A-&gt;&gt;+J: John, can you hear me?J--&gt;&gt;-A: Hi Alice, I can hear you!J--&gt;&gt;-A: I fell gread! sequenceDiagram A->>+J: Hello John, how are you? A->>+J: John, can you hear me? J-->>-A: Hi Alice, I can hear you! J-->>-A: I fell gread! 注释 /说明 Notes1Note [right of | left of | over][Actor]: Text in note content 123sequenceDiagramparticipant JohnNote right of John: Text in note sequenceDiagram participant John Note right of John: Text in note sequenceDiagram Alice->>John: Hello John-->>Alice: Hi Note over Alice, John: A typical interaction 循环 Loops123loop Loop text... statements ...end sequenceDiagram Alice->>John: Hello, how are you? loop Every minute John-->>Alice: Great! end 选择 Alt（alternative） 2选1 12345alt Describing text... statements ...else... statements ...end 可选 (可选可不选，没有第二选项) 123opt Descibing text... statements ...end 1234567891011sequenceDiagramA-&gt;&gt;B: Hello Bob, how are you?alt is sick B--&gt;&gt;A: Not so goodelse is well B--&gt;A: Feeling goodendopt Extra responese B--&gt;&gt;A: Thanks for askingend sequenceDiagram A->>B: Hello Bob, how are you? alt is sick B-->>A: Not so good else is well B-->A: Feeling good end opt Extra responese B-->>A: Thanks for asking end 并行 Parallel显示并行发生的操作 1234567par [Action 1]... statements ...and [Action 2]... statements ...and [Action N]... statements ...end 12345678sequenceDiagrampar Alice to BobAlice-&gt;&gt;Bob: Hello guys!and Alice to JohnAlice-&gt;&gt;John: Hello guys!endBob--&gt;&gt;Alice: Hi Alice!John--&gt;&gt;Alice: Hi Alice! sequenceDiagram par Alice to Bob Alice->>Bob: Hello guys! and Alice to John Alice->>John: Hello guys! end Bob-->>Alice: Hi Alice! John-->>Alice: Hi Alice! 背景高亮 Background Highlighting12345678rect rgb(0,125,0)... content ...endrect rgba(0,123,0,0.4)... contentend 12345678910111213sequenceDiagramrect rgba(0,123,0,0.8) A-&gt;&gt;B: Hello Bob, how are you? alt is sick B--&gt;&gt;A: Not so good else is well B--&gt;A: Feeling good end opt Extra responese B--&gt;&gt;A: Thanks for asking endend sequenceDiagram rect rgba(0,123,0,0.8) A->>B: Hello Bob, how are you? alt is sick B-->>A: Not so good else is well B-->A: Feeling good end opt Extra responese B-->>A: Thanks for asking end end 序号标识 sequenceNumbers1234567891011sequenceDiagram autonumber Alice-&gt;&gt;John: Hello John, how are you? loop Healthcheck John-&gt;&gt;John: Fight against hypochondria end Note right of John: Rational thoughts! John--&gt;&gt;Alice: Great! John-&gt;&gt;Bob: How about you? Bob--&gt;&gt;John: Jolly good! Class Diagram定义类12345678classDiagramclass BankAccount &#123;+String owner+BigDecimal balance+deposit(amount)+withdrawl(amount) &#125; classDiagram class BankAccount { +String owner +BigDecimal balance +deposit(amount) +withdrawl(amount) } 可见性 Visiblity + Public - Private # Protected ~ Package/Internal 关系 RelationShip Type Description &lt;|– Inheritance 继承 ..|&gt; Realization 实现 ..&gt; Dependency 依赖 –&gt; Association 关联 *– Composition 组合 o– Aggregation 聚合 – Link （Solid） .. Link （Dashed） 1234567891011121314classDiagramclassA &lt;|-- classB : Inheritance,继承（一般与特殊关系），箭头指向父类classM &lt;|.. classN : Realization，实现，箭头指向接口classK &lt;.. classL : Dependency, 依赖（使用关系），箭头指向被使用者classG &lt;-- classH : Association，关联（拥有关系），箭头指向被拥有者classC *-- classD : Composition，组合（整体与部分关系，部分不能离开整体而单独存在），菱形指向整体classE o-- classF : Aggregation，聚合，（整体部分关系，但部分可以离开整体而单独存在），菱形指向整体classI -- classJ : Link(Solid)classO .. classP : Link(Dashed) class classM &#123;&lt;&lt;interface&gt;&gt;&#125; classDiagram classA Still Still --> Moving Moving --> Still Moving --> Crash Crash --> [*] Still --> [*] 分支 Forks使用&lt;&lt;fork&gt;&gt;,&lt;&lt;join&gt;&gt;在状态图中指定分支，合并 1234567891011stateDiagramstate fork_state &lt;&lt;fork&gt;&gt;[*] --&gt; fork_statefork_state --&gt; State2fork_state --&gt; State3state join_state &lt;&lt;join&gt;&gt;State2 --&gt; join_stateState3 --&gt; join_statejoin_state --&gt; State4State4 --&gt; [*] stateDiagram state fork_state [*] --> fork_state fork_state --> State2 fork_state --> State3 state join_state State2 --> join_state State3 --> join_state join_state --> State4 State4 --> [*] 复合状态 Composite12345678910111213stateDiagram[*] --&gt; Firststate First &#123; [*] --&gt; Second state Second &#123; [*] --&gt; sec sec --&gt; Third state Third &#123; [*] --&gt; third third --&gt; [*] &#125; &#125; &#125; stateDiagram [*] --> First state First { [*] --> Second state Second { [*] --> sec sec --> Third state Third { [*] --> third third --> [*] } } } 并发状态 Concurrency1 stateDiagram [*] --> Active state Active { [*] --> NumLockOff NumLockOff --> NumLockOn : EvNumLockPressed NumLockOn --> NumLockOff : EvNumLOckPressed -- [*] --> CapsLockOff CapsLockOff --> CapsLockOn : EvCapsLockPressed CapsLockOn --> CapsLockOff : EvCapsLockPressed } Grantt甘特图将每个计划任务记录为一个从左到右延续的连续条。x轴代表时间，y轴记录不同的任务和它们完成的顺序。 1234567891011121314151617181920212223242526272829gantt dateFormat :YYYY-MM-DD title :Adding GANTT diagram functionality to mermaid excludes :excludes the named dates/days from being included in a charted task.. (Accepts specific dates in YYYY-MM-DD format, days of the week (&quot;sunday&quot;) or &quot;weekends&quot;, but not the word &quot;weekdays&quot;.) section A section Completed task :done, des1, 2014-01-06,2014-01-08 Active task :active, des2, 2014-01-09, 3d Future task : des3, after des2, 5d Future task2 : des4, after des3, 5d section Critical tasks Completed task in the critical line :crit, done, 2014-01-06,24h Implement parser and jison :crit, done, after des1, 2d Create tests for parser :crit, active, 3d Future task in critical line :crit, 5d Create tests for renderer :2d Add to mermaid :1d section Documentation Describe gantt syntax :active, a1, after des1, 3d Add gantt diagram to demo page :after a1 , 20h Add another diagram to demo page :doc1, after a1 , 48h section Last section Describe gantt syntax :after doc1, 3d Add gantt diagram to demo page :20h Add another diagram to demo page :48h gantt title A Gantt Diagram dateFormat YYYY-MM-DD section A section Completed task :done, des1, 2014-01-06,2014-01-08 Active task :active, des2, 2014-01-09, 3d Future task : des3, after des2, 5d Future task2 : des4, after des3, 5d section Critical tasks Completed task in the critical line :crit, done, 2014-01-06,24h Implement parser and jison :crit, done, after des1, 2d Create tests for parser :crit, active, 3d Future task in critical line :crit, 5d Create tests for renderer :2d Add to mermaid :1d section Documentation Describe gantt syntax :active, a1, after des1, 3d Add gantt diagram to demo page :after a1 , 20h Add another diagram to demo page :doc1, after a1 , 48h section Last section Describe gantt syntax :after doc1, 3d Add gantt diagram to demo page :20h Add another diagram to demo page :48h Pie Chart123456pie title key elements in Product X &quot;Calcium(钙)&quot; : 42.96 &quot;Potassium（钾）&quot; : 50.05 &quot;Magnesium（镁）&quot; : 10.01 &quot;Iron（铁）&quot; : 5 pie title key elements in Product X \"Calcium(钙)\" : 42.96 \"Potassium（钾）\" : 50.05 \"Magnesium（镁）\" : 10.01 \"Iron（铁）\" : 5","categories":[{"name":"技术总结","slug":"技术总结","permalink":"https://better-jiang.github.io/categories/%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%93/"}],"tags":[]},{"title":"浏览器揭秘","slug":"浏览器揭秘","date":"2020-04-16T23:19:51.000Z","updated":"2023-02-03T12:14:22.420Z","comments":true,"path":"2020/04/17/浏览器揭秘/","link":"","permalink":"https://better-jiang.github.io/2020/04/17/%E6%B5%8F%E8%A7%88%E5%99%A8%E6%8F%AD%E7%A7%98/","excerpt":"","text":"浏览器结构浏览器主要组件有 7 个，用户界面，浏览器引擎，渲染引擎，网络，用户界面 后端，JS 解析器，数据存储 用户界面： 除了浏览器主窗口显示请求的页面外，其他显示的各部分都属于用户界面，如地址栏，状态栏，工具栏等 浏览器引擎：在用户界面和渲染引擎之间传送指令 渲染引擎： 负责显示所请求的内容。解析 HTML 和 CSS，并将解析后的内容显示在屏幕 网络：用于网络调用，例如 HTTP 请求 JS 解析器：用于解析和执行 JavaScript 代码 数据存储：持久层，浏览器需要在硬盘保持各种数据，例如 Cookie。浏览器还支持存储机制，如LocalStorage,IndexedDB,WebSQL 渲染引擎（Rendering engine）不同浏览器使用不同的渲染引擎 Blink： Chrome, Opera Webkit: Safari Gecko: Firefox Trident: Internet Explorer EdgeHTML: Edge Presto: Opera(遗留) 渲染流程渲染引擎一开始会从网络层获取请求文档的内容，内容大小一般限制在 8kb 的块以内。然后进行如下基本流程： 解析 HTML 文档，并将元素转为内容树（content tree）中的 DOM 节点； 解析 css 样式，样式消息和 HTML 中的可视化指令一起创建了渲染树(redner tree) 渲染树包含带有颜色和尺寸等视觉属性的矩形，这些矩形会按其排列的顺序在屏幕上显示 渲染树构建完成之后，进入布局阶段，也就是为每一个节点分配一个它应该出现在屏幕上的确切坐标 绘制阶段，渲染引擎会遍历渲染树，并由用户界面后端层将每个节点绘制处理 注意： 这是一个渐进的过程。为了获得更好的用户体验，渲染引擎将会尽快在屏幕显示内容。它不会等到所有 HTML 都被解析后才开始构建渲染树、设置布局。在不断接受和处理来自网络的其余内容的同时，渲染引擎会将部分内容解析并显示。 解析/DOM 树构建树包含 DOM 节点，指的是树是由实现了某个 DOM 接口的元素构成的 解析解析文档是指将文档转化成为有意义的，可以让代码理解、使用的结构。解析得到的结构通常代表了文档结构的节点树，它被称之为解析树/语法树。 HTML 解析：将 HTML 标记解析成解析树。解析树是由 DOM 元素和属性节点构成的树结构。DOM（文档对象模型），是 HTML 文档的对象表示，同时也是外部内容与 HTML 元素之间的接口 CSS 解析： 将 CSS 文件解析成 StyleSheet 对象，且每个对象都包含 CSS 规则。CSS 规则对象则包含选择器和声明对象。 脚本顺序解析器遇到&lt;script&gt;标记时立即解析并执行脚本，文档的解析将停止，直到脚本执行完毕。如果脚本是外部的,解析过程会停止，直到从网络同步获取资源完成后再执行。脚本标注为defer,它不会停止文档解析，而是等到解析结束才执行；脚本标注为async,它表示异步，由其它线程解析和执行，文档解析不受影响 渲染树构建在 DOM 树构建的同时，浏览器还会构建另一个树结构，渲染树，它是由可视化元素按照其显示顺序而组成的树，即文档的可视化表示。其目的是使让内容按照正确的顺序绘制。webkit 将渲染树中的元素成为渲染对象/渲染器，它知道如何布局并将自身及其子元素绘制出来。RenderObject 类使所有渲染对象的基类，其定义如下： 123456789calss RenderObject &#123; virtual void layout(); virtual void paint(PaintInfo); virtula void rect repaintRect(); Node* node; // DOM 节点 RenderStyle* style; // 计算样式 RenderLayer* containgLayer; // the containing z-index layer&#125; 每个渲染对象都代表一个矩形区域，通常对应于相关节点的 CSS 框 渲染树和 DOM 树的关系 渲染对象和 DOM 元素相对应，但并非一一对应，非可视化的 DOM 元素不会插入 DOM 树，如&lt;head&gt;元素，如果元素的样式display:none;，该元素也不在渲染树中。但visibility:hidden;的元素仍会显示。 有些 DOM 元素对应多个可视化对象，它们往往具有复杂结构的元素，无法用单一的矩形来描述。例如，&lt;select&gt;元素有 3 个渲染对象，显示区域，下拉列表框，按钮。 有些渲染对象对应于 DOM 节点，但在树中的位置与 DOM 节点不同。浮动定位，绝对定位的元素，处于正常的流程之外，放置在树中的其他地方，而放置在原位的使占位对象 构建渲染树的流程处理&lt;html&gt;,&lt;body&gt;标记会构建渲染树的根节点。这个根节点渲染对象对应于 CSS 最上层的容器 block,且包含了其他所有的 block。它的尺寸就是视口，即浏览器窗口显示区域的尺寸。渲染树的其余部分以 DOM 树节点插入的形式来构建。 构建渲染树时，需要计算每一个渲染对象的可视化属性，这是通过计算每个元素的样式属性来完成的， 布局渲染对象在创建完成并添加到渲染树时，并不包含位置和大小信息。计算这些值的过程称为布局或重排。 Dirty 位系统为了避免对所有细小的更改都进行整体布局，浏览器采用了一种弄”dirty 位”的系统。如果某个渲染对象发生了更改，或将自身或其子代标记为”dirty”,表示需要进行布局 全局布局和增量布局 全局布局（往往是同步触发的）指触发了整个渲染树范围的布局，触发原因可能包括： 影响所有渲染对象的全局更改，如字体大小 屏幕大小调整 当渲染对象为 dirty 时，会异步触发增量布局。浏览器会将“reflow 命令”加入队列，而调度程序 会触发这些命令的批量执行。 请求样式信息的脚本可同步触发增量布局 绘制在绘制阶段，系统会遍历渲染树，并调用渲染对象的”paint”方法，将渲染对象绘制在屏幕上。绘制工作用户界面基础组件完成的。 绘制顺序CSS2 规范定义了绘制流程的顺序,即按照属性z-index来决定绘制顺序 根元素具有根层叠上下文 z-index 不为”auto”的定位元素，就创建了一个新的层叠上下文（Stacking Context） 定位元素以及父元素为 flex 定位的元素，必须依赖 z-index 值才能创建层叠上下位，所以统称为依赖 z-index 的层叠上下文元素。而其他属性即不依赖 z-index 的层叠上下文。 一个层叠上下文有 7 中层叠等级，由低到高： 背景和边框： 层叠上下文的元素的背景和边框 负 z-index 值：层叠上下文内负 z-index 值的子元素 块级盒： 文档流中非行内非定位的子元素 浮动盒： 非定位的浮动元素 行内盒：文档流中行内非定位子元素 z-index:0 正 z-index 的值","categories":[{"name":"技术总结","slug":"技术总结","permalink":"https://better-jiang.github.io/categories/%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%93/"}],"tags":[{"name":"前端性能","slug":"前端性能","permalink":"https://better-jiang.github.io/tags/%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD/"}]},{"title":"http知识点梳理","slug":"http知识点梳理","date":"2020-04-13T04:27:21.000Z","updated":"2023-02-03T12:14:22.420Z","comments":true,"path":"2020/04/13/http知识点梳理/","link":"","permalink":"https://better-jiang.github.io/2020/04/13/http%E7%9F%A5%E8%AF%86%E7%82%B9%E6%A2%B3%E7%90%86/","excerpt":"","text":"http 是应用层协议，且是无状态的。它时基于 TCP/IP 的通信协议，用于在网络中传递数据，默认端口号 TCP 80.HTTP 规范指定如何构造客户端的请求数据并将起发送到服务器，以及服务器如何响应这些数据。 基本特性有 3 个基本特性使得 HTTP 成为一个简单且强大的协议： HTPP 是无连接的，客户端和服务器仅在当前请求和响应期间是相互知道对方，进一步的请求会建立新的连接，就像客户端和服务器彼此是新的一样 HTTP 是独立于媒体，与媒体无关的，这意味，只要客户端和服务器都知道如何处理数据内容，任何类型的数据都可以通过 HTTP 发送。因此，客户端和服务器都需要使用适当的MIME-type来指定内容类型 HTTP 是无状态的，如上所述，HTTP 是无连接的，只在当前请求期间，客户端与服务器才能相互感知，之后，就会忘记对方。因此，客户端和服务器都不能在跨 web 页面的不同请求之间保留信息。 HTTP/1.0 为每个请求/响应交换 使用一个新连接，而 HTTP/1.1 一个连接可以用于一个或多个 请求/响应交换 基础架构 HTTP 协议是基于客户端/服务器架构的请求/响应协议。其中 web 浏览器，搜索引擎等充当 HTTP 的客户端，web 服务器充当服务器 Client 客户端HTTP 客户端以 请求方法+URL+协议版本的形式向服务器发送消息，然后通过 TCP/IP 连接发送一个类似 mime（MIME-like）的消息，其中包含请求修饰符，客户机信息，可能的主体内容。 Server 服务器HTTP 服务器使用一个状态行（消息协议版本 + 成功或错误代码）进行响应，然后是一个类似 mime 消息，其中包含服务器信息，实体元信息，可能的实体-主体信息 HTTP-参数版本HTTP/1.0, HTTP/1.1 同一资源标识符（URI）不区分大小写，一般语法 1URI = &quot;http:&quot; &quot;//&quot; host [&quot;:&quot; port] [abs_path [&quot;?&quot; query]] 如果port为空，则默认 HTTP 端口号 80; 如果abs_path为空，则相对于/ 除保留字符和有特殊含义的字符之外的字符会被进行编码，等效于%+十六进制编码 日期/时间格式所有 HTTP 日期/时间戳，必须用格林威治时间表示 last-modified: Sat, 11 Apr 2020 02:05:18 GMT 字符集指定客户端喜欢字符集，多个字符集用逗号分隔；如果未指定，默认为 US-ASCII 内容编码在通过网络传递内容之前，使用编码算法对内容进行编码，主要用于在不丢失标识的情况下对文档进行压缩或其他转化。内容编码的值是大小写不敏感的，在HTTP/1.1中，Accept-Encoding和Content-Encoding头字段中使用内容编码值 1234567Accept-encoding: gzipAccept-encoding: compressAccept-encoding: deflateContent-encoding: gzip 媒体类型在Content-Type和Accept头字段中使用互联网媒体类型，以便提供开放的，可扩展的数据类型和类型协商。所有的媒体类型的值都在互联网号码分配机构(IANA)注册，可查看媒体类型最新列表。MIME 类型对大小写不敏感，其通用结构：type/subtype 独立类型独立类型表明了对文件的分类 类型 说明 示例 text 普通文本，理论上是人可读的 text/plain,text/html,text/css,text/javascript image 图像，包括 gif 动图 image/gif,image/png,image/jpeg,image/x-icon audio 音频文件 audio/midi,audio/mpeg,audio/webm,audio/ogg video 视频文件 video/webm,video/ogg application 某种二级制数据 application/octet-stream,application/xml,application/pdf 复合（Multipart）类型123multipart/form-datamultipart/byteranges Multipart 类型表示细分领域的文件类型，是复合文件的一种表现方式。multipart/form-data 用于HTML Forms和POST方法;multipart/byteranges使用状态码 206 Partial Content来发送整个文件的子集。HTTP 对不能处理的复合文件使用特殊的方式：将信息 直接传给浏览器(这是可能会建立一个“另存为”窗口，但是不知道如何去显示文件) 语言标签HTTP 在Accept-Language和Content-Language字段使用语言标签，它是由一个主语言和一系列的子语（可能为空）言组成。不允许有空格，且大小写不敏感。 123Accept-language: en,zh-CN;q=0.9,zh;q=0.8,la;q=0.7// q 表示对该语言的喜好程度，0-1之间 HTTP-header 字段HTTP 消息头允许客户端和服务器通过请求，响应来传递附加信息。一个请求头由名称（不区分大小写）后跟一个冒号:，冒号后再跟具体的值（不带换行符）组成。根据不同上下文，消息头可分为： General headers: 同时适用于请求和响应消息，但是不能应用于内容本身。常见的有Date，Cache-Control，Connection Request headers： 包含更多有关要获取的资源或客户端本身信息的消息头 Response headers: 包含有关响应的补充信息 Entity headers： 包含有关实体主体的更多信息 通用的头字段 Cache-Control: 被用在请求和响应中，通过指令来实现缓存机制。指令不区分大小写，具有可选参数，多个指令以逗号分隔 缓存请求指令 no-cache: 在没有与原始服务器成功验证的情况下，缓存不得使用。即在发送缓存副本之前，强制要求缓存把请求提交给原始服务器进行验证（协商缓存验证） no-store: 缓存不应存储有关客户端请求或服务器响应的任何内容，即不使用任何缓存 max-age = seconds: 设置缓存存储的最大周期，超过该时间缓存被认为过期 max-stale [=seconds]: 表示客户端愿意接受超过到期时间的响应。如果给定了时间，它的过期时间不得超过该时间。 min-fresh= seconds: 表示客户端愿意接受还剩余多少秒过期的缓存 only-if-cached: 表示客户端直接受已缓存的响应，并且不要向原始服务器检查是否有更新的拷贝。 缓存响应指令 public: 表明响应可以被任何对象（包括 客户端，代理服务器，等待）缓存 private: 响应只能被单个用户缓存，不能作为共享缓存（即代理服务器不能缓存），私有缓存可以缓存响应内容，比如，对应用户的本地浏览器 must-revalidate: 一旦资源过期，在成功向原始服务器验证之前，缓存不能用该资源响应后续请求 proxy-revalidate: 代理重新验证指令，与must-revalidate作用相同，但它仅适用于共享缓存，被私有缓存忽略 Connection: 决定当前事务完成后，是否关闭网络连接；值为”keep-alive”,网络连接是持久的，不会关闭，使得对同一服务器的请求可以继续在该连接上完成。”close”,关闭该网络连接 Date： 报文创建的日期和时间。在 HTTP 协议中，时间都是用格林威治标准时间来表示，而非本地时间。&lt;day-name&gt;, &lt;day&gt; &lt;month&gt; &lt;year&gt; &lt;hour&gt;:&lt;minute&gt;:&lt;second&gt; GMT,Date: Tue, 14 Apr 2020 23:40:03 GMT Via: 网关和代理必须使用Via来指示中间协议和接收者。可用来追踪消息转发情况，防止循环请求 请求消息的头字段 Accept: 请求头用来告知服务器，客户端可处理的内容类型，用 MIME 类型表示。借助内容协商机制，服务器可以从诸多备选项中选择一项进行应用，并使用Content-Type通知客户端它的选择 Accept-Charset: 用来告知服务器，客户端可以处理的字符集类型。服务器使用Content-Type应答。Content-Type: text/hml; charset=utf-8 Accept-Encoding: 用来告知服务器，客户端能够理解的内容编码方式，通常是某种压缩算法。服务器使用Content-Encoding应答 值indentity，未经过压缩和修改 Accept-Language： 客户端可理解的自然语言 Authorization: 请求消息头含有服务器 用于验证用户代理身份的凭证，通常会在服务器返回401 Unauthorzied状态码之后，在后续请求中发送此消息头。Authorization: &lt;type&gt; &lt;credentials&gt;, Authorization: Basic YWxhZGRpbjpvcGVuc2VzYW1l,“基本验证（Basic)”,用冒号将用户名和密码进行拼接(username:password),再用 base64 方式编码 Cookie: 其中含有先前由服务器通过Set-Cookie首部存储到客户端的HTTP cookies,其值是一系列的名称/值对，之间用分号和空格隔开。Cookie: PHPSESSID=298zf09hf012fh2; csrftoken=u32t4o3tb3gg43; _gat=1; Host: 指明了服务器的域名，以及服务器监听的 TCP 端口号，默认 80.HTTP/1.1请求缺少 Host 头字段，返回400 Bad Request状态码 If-Match: 表示这是一个条件请求 在 GET,HEAD 请求，服务器仅在请求的资源满足此首部的ETag值时才会返回资源。 对 PUT 请求，只有在满足条件的情况下才可以将资源上传 If-Modified-Since: 是一个条件式的请求首部，如果在该字段中指定的时间以来，请求的资源未被修改，则返回一个不带消息主体的 304 Not Modified 响应。如果资源修改过，则返回 200 Ok.在Last-Modified响应首部中会带有上次修改的时间。如果没有ETag匹配，则服务器不能执行该请求方法，返回412 Precondition Failed If-None-Match: 是一个条件式请求。当且仅当服务器上没有任何资源的ETag的值与此首部中列出的相匹配时，才返回200 Ok.2 个常见应用场景 采用 GET,HEAD 方法，来更新拥有特定的 ETag 属性值的缓存 采用其他方法，尤其是 PUT,将If-None-Match的值设置为 *,(可以代表任意资源），来检查拥有相同 ID 的资源是否存在，如果存在，则验证失败，服务器返回412 Precondition Failed（前置条件失败） User-Agent: 包含有关发送请求的用户代理的信息，软件类型、操作系统、开发商、版本号等。要避免进行用户代理检测，因为为不同浏览器提供不同的网页或服务通常是一个坏主意， 功能检测，弄清楚浏览器中某种特定功能是否可用，如果不可用，找应变策略 渐进增强，自底向上的方法，从一个简单的层次开始，在一系列连续的层次中通过使用更多的功能来逐步提升站点的能力 优雅降级，自顶向下的方式，先使用所有想要的功能，然后改进使其能在更老旧的浏览器上工作，与渐进增强的方式相比，这种方法更困难，效率更低 响应消息的头字段 ETag: 资源是特定版本的标识符。如果给定 URL 中的资源更改，则一定要生成新的 ETag 值。常见的应用场景 避免“空中碰撞”，借助ETag和If-Match头部，可以检测到“空中碰撞”的编辑冲突，POST 请求将包含有 ETag 值的If-Match头来检查是否为最新版本，如果不匹配，则意味已经被编辑，返回412前置条件失败错误 缓存未更改的资源，在请求时发送值为 ETag 的If-None-Match字段，服务器与其当前版本资源的 ETag 进行比较，如果两个值匹配，即资源未更改，返回304 Location: 指定了需要将页面重定向到的地址，一般在状态码为3XX的响应中才会有意义 Retry-After: 表示客户端需要等待多长时间后才能继续发送请求。经常同503 Service Unavailable, 当前服务不存在响应一起使用，表示服务器下线的预期时长，可用于对于计划内宕机时间的处理 Server: 处理请求的源头服务器所用的软件相关信息 Set-Cookie: 被用来由服务器端向客户端发送 cookie，即设置此网址的 cookie Set-Cookie: id=a3fWa; Expires=Wed, 21 Oct 2015 07:28:00 GMT; Secure; HttpOnly 实体消息(Entity Headers)的头字段 Allow: 资源所支持的 HTTP 方法的合集。若服务器返回状态码405 Method Not Allowed,则该首部字段需要同时返回给客户端 Content-Ecoding: 表示消息主体进行了何种方式的内容编码（压缩）。如果源服务器不接受请求信息中的内容编码，服务器返回415 Unsupported Media Type Content-length: 用来指明发送给接收方的消息主体的大小 Content-Type: 消息主体的媒体类型 Expires: 响应过期是日期/时间。 0，代表过去时间，即资源已经过期。如果在Cache-Control响应头设置了max-age或s-max-age指令，则Expires会被忽略 Last-Modified: 源服务器中资源最后修改的日期/时间 HTTP-消息HTTP 是基于客户机-服务器体系结构模型，无状态请求/响应协议，通过可靠的 TCP/IP 来交换消息。HTTP 利用 URI 来标识给定的资源并建立连接，一旦建立了连接，HTTP 消息将以 MIME 类型传递。这些消息包含从客户机到服务器的请求和从服务器到客户机的响应。HTTP 请求和响应使用 RFC 822 的通用消息格式来传输所需的数据，此通用消息格式由四个部分组成:起始行,头部，空行,消息正文 HTTP-请求http-请求方法HTTP 定义了一组请求方法，以表明要对给定资源执行的操作。 GET：使用给定 URL 从服务器获取数据，且不会对数据产生其他影响 HEAD: 请求资源的头部信息， 且与 GET 方法请求时返回的一致，不包含响应正文。使用场景，在要下载一个大文件前先获取文件大小后再决定是否要下载，以节约带宽资源 POST: 发送数据给服务器，请求主体的类型由Content-Type首部指定PUT 方法是幂等（idempotent,指同样的请求被执行一次或连续执行多次的效果是一样的）的，即连续调用一次或多次的效果相同（无副作用），但 POST 不是，连续调用可能会带来额外的影响，比如多次提交订单POST 请求通常通过 HTML 表单发送，并返回服务器的修改结果，在这种情况下，content-type是通过在&lt;form&gt;元素中设置正确的enctype属性，或在&lt;input&gt;,&lt;button&gt;元素中设置formenctype属性来选择的,如application/x-www-form-urlencoded multipart/form-data``text/plain PUT: 使用请求中的内容创建或替换目标资源 如果目标资源不存在，并且 PUT 方法成功创建了一份，则服务器必须返回201 Created来通知客户端资源已创建 如果目标资源已经存在，且成功进行了更新，则服务器必须返回200 OK或204 No Content来表示请求成功完成 PATCH：用于对资源进行部分修改，不同与 PUT 对资源进行整体覆盖。PATCH 方法是非幂等的，如何理解？PATCH 请求中的实体保存的是修改资源的指令，该指令指导服务器来对资源做出修改，例如，对于服务器的 A 对象有个属性 b 为 1，如果要修改为 3，PUT 请求直接将改过的 b 属性的整个新对象发送给服务器查找并替换；而 PATCH 请求是在实体中包含指令:将 A 对象中的 b 属性的值+2，所有如果该请求被执行多次，b 属性就不是 3 了。 DELETE: 删除指定的资源，是幂等的。如果成功执行，会有以下几种状态码： 202 Accepted, 表示请求的操作可能会成功执行，但是尚未开始执行 204 No Content, 操作已执行，但无进一步的相关信息 200 OK,操作已执行，并且响应中提供了相关状态的描述信息 OPTIONS: 用于获取目的资源所支持的通信选项。客户端可对特性 URL 使用 OPTIONS 方法，也可对整站(RUL 设置为*)使用该方法 检测服务器所支持的请求方法，响应报文会包含Allow首部字段，该字段的值表明了服务器支持的所有 HTTP 方法 1$ curl -X OPTIONS http://example.org -i HTTP/1.1 200 OK Allow: OPTIONS, GET, HEAD, POST Cache-Control: max-age=604800 Content-Type: text/html; charset=UTF-8 Date: Tue, 14 Apr 2020 03:21:01 GMT Expires: Tue, 21 Apr 2020 03:21:01 GMT Server: EOS (vny/0454) Content-Length: 0 ``` 在中的预检请求，在CORS中，使用 OPTIONS 方法发起一个预检请求，以检查请求是否被服务器接收。 HTTP-响应 状态行: 协议版本 状态码 状态文本，HTTP/1.1 404 Not Found Headers: 遵循和任何其它 header 相同的结构 Body： 不是所需响应都有 body HTTP-状态码HTTP 状态码可分为 5 种类型 分类 描述 1XX 信息性状态码，服务器收到请求，需要请求者继续执行操作 2XX 成功状态码，操作被成功接收并处理 3XX 重定向，需要进一步的操作以完成请求 4XX 客户端错误，请求包含语法错误 5XX 服务器错误，服务器在处理请求的过程中发生了错误 常用状态码 200 OK: 请求已经成功，默认情况下状态码为 200 的响应可以被缓存。 201 Created: 请求已经被成功处理，并且创建了新的资源，常作为POST请求的返回值 204 No Content: 请求成功，但没有资源返回给客户端。常用于在PUT请求进行资源更新时，如果创建了资源，则返回201 Created 206 Partial Content: 对资源某一部分的请求，响应报文中包含由 Content-Range 指定范围的实体内容 301 Moved Permanently: 永久重定向，请求的资源已经被移动到由Location头部指定的 URL 上，因为有些用户代理在进行重定向时会改变请求 method 和 body，用308 Permanent Redirect,它不会。 302 Found，请求的资源被暂时的移动到由Location头部指定的 URL 上。部分用户代理在重定向时无法保证请求 method 和 body 不变，推荐使用307 Temporary Redirect. 303 See Other: 通常作为PUT和POST操作的返回结果，它表示重定向的链接指向的不是新上传的资源，而是另一个页面，比如信息确认页面或上传进度页面，且方法总是使用GET 304 Not Modified: 未改变，说明无需再次传输请求的内容，可以使用缓存的内容 400 Bad Request: 表示服务器无法理解的请求，请求报文中可能存在语法错误 401 Unauthorized: 缺少目标资源要求的身份验证凭证，这个状态码会和www-Authenticate头部一起返回，其中包含有如何进行验证的消息 403 Forbidden: 指定是服务器有能力处理请求，但是拒绝授权（没权限，未授权 IP 等） 404 Not Found: 服务器无法找到请求的资源，路径错误 405 Method Not Allowed: 表明服务器禁止使用当前的 HTTP 方法的请求 500 Internal Server Error: 服务器遇到意外的情况，并阻止其执行请求。通用的“万能”的错误响应 502 Bad Gateway: 表示最为网关或代理角色的服务器，从上游服务器中接收到的响应式无效的。 503 Service Unavailable: 表示服务器尚未处于可接受请求的状态。原因可能是停机维护或者已超载。在必要可行的情况下，应该在Retry-After头部包含服务恢复的预期时间","categories":[{"name":"技术总结","slug":"技术总结","permalink":"https://better-jiang.github.io/categories/%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%93/"}],"tags":[{"name":"http","slug":"http","permalink":"https://better-jiang.github.io/tags/http/"}]},{"title":"Axios知识点梳理","slug":"Axios知识点梳理","date":"2020-04-13T00:16:23.000Z","updated":"2023-02-03T12:14:22.420Z","comments":true,"path":"2020/04/13/Axios知识点梳理/","link":"","permalink":"https://better-jiang.github.io/2020/04/13/Axios%E7%9F%A5%E8%AF%86%E7%82%B9%E6%A2%B3%E7%90%86/","excerpt":"","text":"axios是是个基于promise的 HTTP 库，它可以用在浏览器喝 node.js 中，有以下重要特性： 从浏览器中创建XMLHttpReuqest 从 node.js 中创建http请求 支持 Promise Api, async/await 可拦截请求、响应 能主动取消请求 创建请求通过向axios传递相关配置来创建请求，返回promise axios(config) axios(url[,config]),默认get方法 请求方法别名在使用别名时，url,method,data属性不必在config中指定 axios.request(config) axios.get(url[,config]) axios.post(url[,data[,config]]) axios.put(url[,data[,config]]) axios.patch(url[,config]): patch方法用来更新局部资源,而put虽然也是更新资源，但要求前端提供的是一个完整的资源对象。 axios.delete(url[,config]) axios.head(url[,config]): head请求与get类型，但是head并不返回消息体，此方法经常用来 检测资源的有效性 检测超链接的有效性 检查网页是否被篡改 自动机器人获取网页的标记信息，传递安全认真信息 axios.options(url[,config]): options请求主要用途 获取服务器支持的 HTTP 请求方法，在响应报文Allow首部字段 在跨域请求中，options请求是浏览器在复杂请求（复杂请求，可能对浏览器数据产生副作用，如 delete, put,都会对服务器数据进行修改，所以在请求之前要先询问服务器，是否允许该跨域请求）时自动发起的预检请求（preflight request），以检测实际请求是否可以被浏览器接收 并发请求axios.all(iterable),参数为可迭代的对象，且是 promise.axios.spread(callback),回调函数参数为并非请求的响应对象，顺序同axios.all(iterable)中一致 1234567axios.all([ axios.get(&quot;https://api.github.com/users/mzabriskie&quot;), axios.get(&quot;https://api.github.com/users/mzabriskie/orgs&quot;)]).then(axios.spread(user,orgs) &#123; // user &quot;/users/mzabriskie&quot; 请求的响应 // org &quot;/users/mzabriskie/orgs&quot;&quot; 请求的响应&#125;) 创建实例使用自定义配置新建一个axios实例 123const instance = axios(&#123; // 请求配置&#125;); 实例方法指定的配置将与实例的配置合并，同请求方法别名类似。 请求配置选项 url: 请求的服务器 URL 必填 method: 请求方法，默认:&#39;get&#39; baseURL: 将自动加在url前面，除非url是绝对 URL transformRequest: 在向服务器发送之前，修改请求数据；后面数组中的函数（函数可接受 2 个参数，data，headers）必须返回字符串、或 ArrayBuffer，或 Stream 123456transformRequest: [ function (data, headers) &#123; // 对 data 进行转化处理 return data; &#125;,]; transformResponse: 修改响应数据，在传递给then/catch之前 123456transformResponse: [ function (data，headers) &#123; // 对 data 进行转化处理 return data; &#125;,]; headers: 自定义请求头 params: 与请求一起发送的 URL 参数,对象 1234params: &#123; id: 123, name: jiang&#125; paramsSerializer, params序列化的函数 12345678910111213141516171819paramsSerializer: function(params) &#123; return Qs.stringify(params, &#123;arrayFormat: &#x27;brackets&#x27;&#125;)&#125;// qs 模块，查询字符串解析和序列化字符串的库// 在 序列化数组时 通过 arrayForm选项进行格式化输出// &quot;indices&quot;: 带索引, 默认值// &quot;brackets&quot;: 仅带有方括号// &quot;repeat&quot;: 重复// &quot;comma&quot;: 以逗号分隔const Qs = require(&quot;qs&quot;);let obj = &#123; id: 123, friends: [&quot;jiang&quot;, &quot;ting&quot;],&#125;;console.log(decodeURIComponent(Qs.stringify(obj))); // id=123&amp;friends[0]=jiang&amp;friends[1]=tingconsole.log(decodeURIComponent(Qs.stringify(obj, &#123; arrayFormat: &quot;indices&quot; &#125;))); // d=123&amp;friends[0]=jiang&amp;friends[1]=tingconsole.log(decodeURIComponent(Qs.stringify(obj, &#123; arrayFormat: &quot;brackets&quot; &#125;))); // id=123&amp;friends[]=jiang&amp;friends[]=tingconsole.log(decodeURIComponent(Qs.stringify(obj, &#123; arrayFormat: &quot;repeat&quot; &#125;))); // id=123&amp;friends=jiang&amp;friends=tingconsole.log(decodeURIComponent(Qs.stringify(obj, &#123; arrayFormat: &quot;comma&quot; &#125;))); // id=123&amp;friends=jiang,ting data: 作为请求主体被发送的数据，仅适用于put,post,patch请求，在没有设置transformRequest时，必须是以下类型： String, plain object, ArrayBuffer,ArrayBufferView,URLSearchParams 浏览器专属，FormData,File,Blob Node 专属，Stream timeout: 请求超时毫秒数（0 表示无超时时间），请求超时，则被中断 withCredentials: 跨域请求是否需要使用凭证，默认值 false auth: 表示使用 HTTP 基本认证，并提供身份凭据，用户名和口令 1234auth: &#123; username: &#x27;jiang&#x27;, password: &#x27;123456&#x27;&#125; responseType: 服务器响应的数据类型，默认json,也可以是arraybuffer,blob,text,stream,documnet responseEncoding: 用于解码响应信息的编码 默认utf8 onUploadProgress/onDownloadProgress: 为上传/下载 处理进度事件 123onUploadProgress: function(progressEvent) &#123; let percentCompleted = Math.round(progressEvent.loaded * 100 / progressEvent.total);&#125; maxContentLength: 响应内容的最大字节数 validateStatus: 定义对于给定的 HTTP 响应状态码是 promise 是 resolve 或 reject；返回 ture，promise 被 resolve，返回 false, promise 被 reject 123validateStatus: function(status) &#123; return status &gt;= 200 &amp;&amp; status &lt; 300; // 默认值&#125; 响应结构请求的响应包含以下信息 data: 由服务器提供的响应 status: 服务器响应的 HTTP 状态码 statusText: 响应的 HTTP 状态信息 headers: 服务器响应头 config: 为请求提供的 配置信息 request: 生成该响应的请求， 在浏览器中是一个XMLHttpRequest实例 在 node.js 中是一个ClientRequest实例 配置默认值 全局的 axios 默认值，12axios.defaluts.headers.post[&quot;Content-Type&quot;] = &quot;application/x-www-form-urlencoded&quot;; 自定义实例的默认值12345const instance = axios.create(&#123; baseURL: &quot;https://better-jiang.github.io/&quot;,&#125;);instance.defaults.headers.post[&quot;Content-Type&quot;] = &quot;application/x-www-form-urlencoded&quot;; 配置优先顺序顺序：全局默认值 &lt; 实例的defaults属性 &lt; 请求时的config参数；后者会覆写前者。 拦截器 请求拦截器,axios.interceptors.request.use(successFn,errorFn) 12345678910let resInterceptor = axios.interceptors.request.use( function (config) &#123; // do some thing return config; &#125;, function (error) &#123; // do some thing return Promise.reject(error); &#125;); 响应拦截器: axios.interceptors.response.use(successFn, errorFn) 12345678910let repInterceptor = axios.interceptors.response.use( function (response) &#123; // ... return response; &#125;, function (error) &#123; // ... return Promise.reject(error); &#125;); 移除拦截器 12axios.interceptors.request.eject(resInterceptor);axios.interceptors.response.eject(repInterceptor); 错误处理123456789axios.get(&quot;/user/123456&quot;).catch(function (error) &#123; if (error.response) &#123; // 响应出错 &#125; else if (error.request) &#123; // 请求出错 &#125; else &#123; // 其他 &#125;&#125;);","categories":[{"name":"技术总结","slug":"技术总结","permalink":"https://better-jiang.github.io/categories/%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%93/"}],"tags":[{"name":"http","slug":"http","permalink":"https://better-jiang.github.io/tags/http/"},{"name":"axios","slug":"axios","permalink":"https://better-jiang.github.io/tags/axios/"}]},{"title":"JS知识点梳理(10)-Ajax","slug":"JS知识点梳理-10-Ajax","date":"2020-04-09T07:36:41.000Z","updated":"2023-02-03T12:14:22.420Z","comments":true,"path":"2020/04/09/JS知识点梳理-10-Ajax/","link":"","permalink":"https://better-jiang.github.io/2020/04/09/JS%E7%9F%A5%E8%AF%86%E7%82%B9%E6%A2%B3%E7%90%86-10-Ajax/","excerpt":"","text":"Ajax(Asynchronous JavaScript and XML)技术核心是 XMLHttpRequest 对象，能够以异步的方式从服务器获取信息，从而可以不必刷新页面也能获取新数据。即使用 XHR 对象取得新数据，再通过 DOM 操作将新数据插入到页面中。 XHR 的用法 创建 XHR 对象1var xhr = new XMLHttpRequest(); open(),初始化请求open(method,url,async)方法，接受 3 个参数：请求类型，请求的 URL，是否异步（默认为异步请求） send(),发生请求send(data)发送请求，接受一个可选参数，作为请求主体发送的数据，如果不需要则必须传入null abort(),取消异步请求 处理响应在受到响应后，响应的数据会自动填充 XHR 对象的属性 responseText： 作为响应主体被返回的文本 responseXML： 如果响应的内容类型是”text/xml”,”application/xml”,则改属性保存着包含响应数据的 XML DOM 文档 status： 响应的 HTTP 状态 statusText： HTTP 状态说明 在发送异步请求，为了让 JavaScript 继续执行而不必等待响应，可为 XHR 对象添加readystatechange事件，来在请求/响应过程执行相应动作。XHR 对象的readyState属性，可表示请求的当前状态，可取值如下： 0：UNSENT，为初始化，尚未调用open()方法 1：OPENED， 启动，已经 调用open()方法，但未调用send()方法 2： HEADERS_RECEIVED，发送，已经调用send()方法，但尚未接收到响应 3： LOADING，接收，已经接收到部分响应数据 4： DONE，完成，已经接收到全部响应数据 HTTP 头部信息 setRequestHeader(header, value): 设置 HTTP 请求头部，此方法必须在open()和send()方法之间调用 getResponseHeader(name):返回指定的响应头信息 getAllResponseHeaders(): 返回所有响应头 XMLHttpRequest 2FormDataFormData 类型为序列化表单以及创建与表单格式相同的数据提供了便利。 创建 FormData 的 实例后，可直接将它传入 XHR 的send()方法 另外，XHR 对象能够识别传入的数据类型是 FormData 的实例，并配置适当的头部信息，不需在手动配置头部信息(shr.setRequestHeader(&quot;Content-Type&quot;, &quot;application/x-www-form-urlencoded&quot;)) 1234567// 序列化表单var data = new FormData(document.forms[0]);// 创建表单格式数据var data1 = new FormData();data.append(&quot;name&quot;, &quot;jiang jiang&quot;); 超时定时XHR 对象的timeout属性，表示请求在等待响应多少毫秒之后终止。在给 XHRtimeout设置一个数值后，如果在规定时间内浏览器还没有接收到响应，就会触发timeout事件. 123456// ...xhr.timeout = 1000;xhr.ontimeout = function() &#123; // ...&#125;xhr.send(null); overrideMimeType()XHR 的overrideMimeType(mimeType),指定一个 MIME 类型用于替换服务器指定的类型，使服务器响应信息中传输的数据按照该指定 MIME 类型处理。注意：如果服务器没有指定一个Content-Type头，XHR 默认 MIME 类型为&quot;text/xml&quot;。但如果接收的数据不是有效的 XML,就会出现格式不正确的错误。可用通过overrideMimeType()指定各种类型来 避免这种情况 进度事件XHR 对象提供了各种在请求被处理期间发生的事件以供监听，包括定期进度通知，错误通知，完成通知等。具体进度事件如下： loadstart： 在接收到响应数据的第一个字节时触发 progress： 在接收响应数据期间不断触发 error： 在请求发生错误时触发 abort： 因调用abort()方法而终止连接时触发 timeout： 请求超时时触发 load： 在接收到完成数据时触发 loadend： 通信终止（成功或失败）时触发，error，abort，timeout，load 任意事件后触发 progress 事件progress 事件在浏览器接收数据期间周期性的触发，其事件处理程序会接收到的 event 对象，具有以下特殊属性 target: XHR 对象 lengthComputable： 进度信息是否可用的布尔值，如果为 false，意味着总字节数为止并且 total 的值为 0 loaded： 已经接收到的字节数 total： 预计的总字节数 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657&lt;body&gt; &lt;div class=&quot;controls&quot;&gt; &lt;input class=&quot;xhr success&quot; type=&quot;button&quot; value=&quot;XHR (success)&quot; /&gt; &lt;input class=&quot;xhr abort&quot; type=&quot;button&quot; value=&quot;XHR (abort)&quot; /&gt; &lt;input class=&quot;xhr error&quot; type=&quot;button&quot; value=&quot;XHR (error)&quot; /&gt; &lt;/div&gt; &lt;textarea readonly class=&quot;event-log&quot; cols=&quot;80&quot; rows=&quot;20&quot;&gt;&lt;/textarea&gt; &lt;img class=&quot;img&quot; src=&quot;&quot; alt=&quot;图片&quot; width=&quot;400&quot; height=&quot;500&quot; /&gt; &lt;script&gt; const xhrButtonSuccess = document.querySelector(&quot;.xhr.success&quot;); const xhrButtonAbort = document.querySelector(&quot;.xhr.abort&quot;); const xhrButtonError = document.querySelector(&quot;.xhr.error&quot;); const log = document.querySelector(&quot;.event-log&quot;); const img = document.querySelector(&quot;.img&quot;); function handleEvent(event) &#123; console.log(&quot;event&gt;&gt;&gt;&quot;, event); log.textContent = log.textContent + `$&#123;event.type&#125;: lengthComputable: $&#123;event.lengthComputable&#125;, $&#123;event.loaded&#125; / $&#123;event.total&#125; bytes transferred\\n`; if (event.type === &quot;load&quot;) &#123; let xhr = event.target; console.log(xhr.getAllResponseHeaders()); img.src = xhr.responseURL; &#125; &#125; function addListeners(xhr) &#123; xhr.addEventListener(&quot;loadstart&quot;, handleEvent); xhr.addEventListener(&quot;progress&quot;, handleEvent); xhr.addEventListener(&quot;load&quot;, handleEvent); xhr.addEventListener(&quot;loaded&quot;, handleEvent); xhr.addEventListener(&quot;error&quot;, handleEvent); xhr.addEventListener(&quot;abort&quot;, handleEvent); &#125; function runXHR(url) &#123; log.textContent = &quot;&quot;; const xhr = new XMLHttpRequest(); addListeners(xhr); xhr.open(&quot;get&quot;, url); xhr.send(); return xhr; &#125; xhrButtonSuccess.addEventListener(&quot;click&quot;, () =&gt; &#123; runXHR( &quot;http://5b0988e595225.cdn.sohucs.com/images/20181012/f34af81a69b145ee83f35a462d8650bb.jpeg&quot; ); &#125;); xhrButtonAbort.addEventListener(&quot;click&quot;, () =&gt; &#123; runXHR( &quot;http://5b0988e595225.cdn.sohucs.com/images/20181012/f34af81a69b145ee83f35a462d8650bb.jpeg&quot; ).abort(); &#125;); xhrButtonError.addEventListener(&quot;click&quot;, () =&gt; &#123; runXHR(&quot;https://somewhere.com/dont-exist&quot;); &#125;); &lt;/script&gt;&lt;/body&gt; 跨域资源共享默认情况下,XHR 对象 只能访问与它包含的页面位于同一域中资源。跨域是指一个域下的文档或脚本试图去请求另一个域下的资源。 广义的跨域 资源跳转： a 链接，重定向，表单提交 资源嵌入： &lt;link&gt;,&lt;script&gt;,&lt;img&gt;标签，css 样式中url(),@font-face()等文件外链 脚本请求： ajax 请求 狭义的跨域通常所说的跨域是狭义的，是由浏览器同源策略所限制的一类请求场景。同源策略是浏览器最核心的安全功能，所谓同源是指协议+域名+端口三者相同。即使两个不同的域名指向同一 IP 地址，也非同源。 CORSCORS（Cross-Origin Resource Sharing，跨域资源共享），定义了在必须访问跨域资源时，浏览器与服务器应该如何沟通。其基本思想，就是使用自定义的 HTTP 头部让浏览器与服务器沟通，从而决定请求或响应是成功，还是失败。具体做法如下： 浏览器在发生请求时，会给 HTTP 头部附加一个额外的Origin头部，其中包含请求页面的源信息（协议+域名+端口），以便服务器根据该头部信息来决定是否响应1Origin: https://developer.mozilla.org 服务器如果认为该请求可以接受，就会在Access-Control-Allow-Origin头部中回发相同的源信息,如果是公共资源，可以回发*1Access-Control-Allow-Origin: * 如果是带凭证的请求，例如 带 cookie 请求时，需要将 XHR 对象withCredentials属性设置为 true,如果服务器接收带凭证的请求，会使用 HTTP 头部来响应Access-Control-Allow-Credentials: true.如果服务器的响应不含该头部，则浏览器不会把响应交给 JavaScript，于是 status 的值为 0，调用 onerror()事件处理程序 跨域解决方案jsonp原理：通过动态创建script，在请求时传参（一个回调函数）给后端，后端在返回时执行这个在前端定义的回调函数，回调函数传入的参数就要返回的数据前端 代码 1234567891011121314151617181920&lt;body&gt; &lt;input class=&quot;jsonp&quot; type=&quot;button&quot; value=&quot;JSONP&quot; /&gt; &lt;textarea class=&quot;responseData&quot; cols=&quot;30&quot; rows=&quot;10&quot;&gt;&lt;/textarea&gt; &lt;script&gt; const responseData = document.querySelector(&quot;.responseData&quot;); const jsonpButton = document.querySelector(&quot;.jsonp&quot;); function handleCallback(res) &#123; responseData.textContent = JSON.stringify(res); &#125; function runJSONP(url, callback) &#123; var script = document.createElement(&quot;script&quot;); script.type = &quot;text/javascript&quot;; script.src = `$&#123;url&#125;?callback=$&#123;callback&#125;`; document.head.appendChild(script); &#125; jsonpButton.addEventListener(&quot;click&quot;, () =&gt; &#123; runJSONP(&quot;http://127.0.0.1:8080/&quot;, &quot;handleCallback&quot;); &#125;); &lt;/script&gt;&lt;/body&gt; 后端 node.代码 1234567891011121314151617var querystring = require(&quot;querystring&quot;);var http = require(&quot;http&quot;);var server = http.createServer();server.on(&quot;request&quot;, function (req, res) &#123; var params = querystring.parse(req.url.split(&quot;?&quot;)[1]); var fn = params.callback; console.log(params); res.writeHead(200, &#123; &quot;Content-Type&quot;: &quot;text/javascript&quot; &#125;); var response = &#123; status: true, user: &quot;admin&quot; &#125;; res.write(`$&#123;fn&#125;($&#123;JSON.stringify(response)&#125;)`); res.end();&#125;);server.listen(&quot;8080&quot;);console.log(&quot;server is running at port 8080....&quot;); postMessage 跨域postMessage是 window 属性之一，可安全实现跨域通信，能解决以下问题： 页面和其打开的新窗口的数据传递 多窗口之间的息传递 页面与嵌套的iframe之间消息传递 基本思路:一个窗口可以获得对另一个窗口的引用，然后在发送窗口上调用otherWindow.postMessage()方法分发一个MessageEvent消息,接收消息的窗口可监听该事件(message),并可自由处理此事件。 分发消息otherWindow.postMessage(message, targetOrigin)方法，分发一个消息给targetOrigin窗口，是通过消息事件对象暴露给接收框口的。 targetWindow: 其他窗口的一个引用，例如，iframe 的contentWindow属性，window.open()返回的窗口对象，命名过或数值索引的winsdow.frames message: 要发送给接收窗口的数据，它会被序列化，无需自己序列化 targetOrigin: 指定那些窗口能接收到消息事件，其值可以是字符串&quot;*&quot;,或者一个 URL 接收消息window.addEventListener(&quot;message&quot;,receiveMessage),通过监听事件来接收消息，事件对象相关属性有： data： 从其他 window 中传递过来的消息内容 origin: 调用postMessage时发送方窗口的 origin. source: 对发送消息的窗口对象的引用","categories":[{"name":"技术总结","slug":"技术总结","permalink":"https://better-jiang.github.io/categories/%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%93/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://better-jiang.github.io/tags/javascript/"},{"name":"http","slug":"http","permalink":"https://better-jiang.github.io/tags/http/"}]},{"title":"JS知识点梳理(9)-事件","slug":"JS知识点梳理-9-事件","date":"2020-04-08T23:14:24.000Z","updated":"2023-02-03T12:14:22.420Z","comments":true,"path":"2020/04/09/JS知识点梳理-9-事件/","link":"","permalink":"https://better-jiang.github.io/2020/04/09/JS%E7%9F%A5%E8%AF%86%E7%82%B9%E6%A2%B3%E7%90%86-9-%E4%BA%8B%E4%BB%B6/","excerpt":"","text":"JavaScript 与 HTML 之间的交互是通过事件实现的。事件就是文档或浏览器窗口中发生的一些特定的交互瞬间，并使用侦听器（或处理程序）来预定事件，以便在事件发生时执行相应的代码。 事件流事件流描述的是从页面中接受事件的顺序，有 3 中类型 事件冒泡：事件开始时由最具体的元素接受，然后沿着 DOM 树逐级向上传播，直到传播到 document 对象 事件捕获：不太具体的节点更早接受到事件，最具体的节点最后接受到事件，即在事件到达预定目标之前捕获它。 DOM 事件流：分 3 个阶段依次为，事件捕获阶段，处于目标阶段，事件冒泡阶段。实际的目标在捕获阶段不会接受到事件。 事件处理程序事件时用户或浏览器自身执行的某种动作，而响应某个事件的函数叫做事件处理程序/事件侦听器。为事件指定处理程序的方法（3 种） HTML 事件处理程序 直接在 HTML 中定义事件处理程序及要执行的具体动作1&lt;input type=&quot;button&quot; value=&quot;111&quot; onclick=&quot;alert(&#x27;111&#x27;)&quot; /&gt; 在 HTML 中定义事件处理程序，执行的动作则调用其他地方定义的脚本1234567&lt;input type=&quot;button&quot; value=&quot;222&quot; onclick=&quot;showMsg(event)&quot; /&gt;&lt;script&gt; function showMsg(event) &#123; console.log(&quot;event&quot;, event); alert(222); &#125;&lt;/script&gt; 注意 事件处理程序在执行时，有权访问全局作用域中任何代码。 事件处理程序会接受一个参数 event，即事件对象。 缺点 HTML 与 JavaScript 代码紧密耦合，若要更换事件处理程序，二者则都需要改动。 存在一个时差问题，比如，用户已经在 HTML 页面中触发事件，但当时事件处理程序包含在一个外部文件，可能尚未加载。 DOM0 级事件处理程序通过 Javascript 指定事件处理程序，就是将一个函数赋值给一个事件处理程序属性。每个元素都有自己的事件处理程序属性，这些属性通常全部小写，例如 onclick,将该属性的值设置为一个函数，就可指定事件处理程序 123456789&lt;input type=&quot;button&quot; value=&quot;3333&quot; id=&quot;btn3&quot; /&gt;&lt;script&gt; btn3.onclick = function () &#123; alert(333); &#125;; btn3.onmouseover = function () &#123; console.log(&quot;mouseover&quot;); &#125;;&lt;/script&gt; 注意 指定事件处理程序在运行之前是无效的，因此如果这些代码在按钮之后，就有可能在一段时间内点击按钮没反应 使用 DOM0 级方法指定的事件处理程序被认为是元素的方法，所有此时的事件处理程序是在元素的作用域中运行，级程序中的 this 执行当前元素 重复指定事件处理程序，后者会覆盖前者。因此，仅触发一次执行动作 删除 DOM0 级方法指定的事件处理程序，只需将事件处理程序属性设置为null即可。btn3.onclick = null; DOM2 级事件处理程序DOM2 级事件处理程序定义了 2 个方法： addEventListener(type,listener,useCapture),添加事件处理程序 removeEventListener(type,listener,useCapture)，删除事件处理程序 这 2 个方法都可接受 3 个参数： 要处理的事件名 作为事件处理程序的函数 表示事件流方式的布尔值。true 为捕获阶段处理程序，false 为冒泡阶段处理程序。默认为 false 1234567891011121314var btn4 = document.getElementById(&quot;btn4&quot;);var handler = function (event) &#123; console.log(event, this); alert(4444);&#125;;btn4.addEventListener(&quot;click&quot;, handler, false);btn4.addEventListener( &quot;click&quot;, function () &#123; alert(555); &#125;, false); 注意 与 DOM0 级方法一样，这里添加的事件处理程序也是在其依附的元素的作用域中运行，即 this 执行当前元素 可以添加多个事件处理程序，并按照添加顺序触发 通过addEventListener()添加的事件处理程序只能使用removeEventListener()来移除，且移除是传入的参数与添加时使用的参数相同。这也就意味着，通过addEventListener()添加的匿名函数将无法移除 事件对象在触发 DOM 上的事件时，都会产生一个事件对象event，无论指定事件处理程序使用什么方法，都会将 event 对象传入到事件处理程序中。event 对象包含与创建它的特定事件有关的属性和方法，以下成员是所有事件都具有的： 属性/方法 类型 说明 type String 被触发事件的类型 bubbles Boolean 是否冒泡 cancelable Boolean 是否可取消事件的默认行为 currentTarget Element 事件处理程序当前正在处理事件的那个元素 target Element 事件的目标元素（真正触发事件的元素） defaultPrevented Boolean 是否已经调用 preventDefault() preventDefault() Function 取消事件的默认行为 stopPropagation() Function 取消事件的传播，即取消事件的进一步捕获或冒泡 在事件处理程序内部，this 对象始终等于currentTarget的值,而target则只包含事件的实际目标。 只有在事件处理程序执行期间，event 对象才存在，一旦事件处理程序执行完毕，event 对象会被销毁 事件类型 UI 事件(UIEvent):当用户与页面上的元素交互时触发 焦点事件(FocusEvent):当元素获得或失去焦点时触发 鼠标事件(MouseEvent):用户通过鼠标在页面上执行操作时触发 滚动事件(WheelEvent):使用鼠标滚动时触发 文本事件(InputEvent):可编辑的内容被修改时触发 键盘事件(KeyboardEvent):当用户通过键盘在页面上执行操作时触发 HTML5 事件 UI 事件 load： 当页面完全加载后在 window 上触发；当所有框架都加载完毕时在框架集上触发；当图集加载完毕时在&lt;img&gt;元素上触发；当嵌入的内容加载完毕时在&lt;object&gt;元素上触发 unload： 当页面完全卸载后在 window 上触发；当所有框架都卸载完成时在框架集上触发；当嵌入内容卸载完成时在&lt;object&gt;元素上触发 abort： 在用户停止下载过程时，如果嵌入的内容没有加载完，则在&lt;object&gt;元素上触发 error: 当发生 javascript 错误时在 window 上触发；当无法加载图片时在&lt;img&gt;元素上触发；当无法加载嵌入内容时在&lt;object&gt;元素上触发 select： 当文本内容被选中时触发，一般在&lt;input&gt;，&lt;textarea&gt;元素 resize: 当窗口大小变化时在 window 上触发 scroll： 当用户滚动带滚动条的元素内容时，在该元素上触发 焦点事件当焦点从一个元素移动到另一个元素，会依次触发以下事件： focusout，在失去焦点的元素（失去焦点之前）触发 focusint， 在获得焦点的元素（获得焦点之前）触发 blur， 在失去焦点的元素（失去焦点之后）触发 focus， 在获得焦点的元素（获得焦点之后）触发 鼠标事件9 个鼠标事件，页面上所有元素都支持鼠标事件，除了mouseenter,mouseleave,所有鼠标事件都会冒泡，也可以被取消 click：单击鼠标（一般是左键），或者按下回车键时触发 dblclick：双击鼠标触发 mousedown：按下任意鼠标按钮触发，不能通过键盘触发 mouseenter：光标从元素外部首次移动到元素范围之内触发。此事件不冒泡，而且在光标移动到后代元素也不会触发 mouseleave：光标从元素之上移动到元素之外时触发。此事件不冒泡，移动到后代元素不触发 mousemove： 光标在元素内部移动时触发 mouseout： 光标从一个元素之上，移入到另一个元素时触发。 mouseover： 光标从一个元素外部，移入另一个元素边界之内触发 mouseup： 释放鼠标按钮时触发 事件触发顺序 只有在同一个元素相继触发 mousedown，mouseup 事件，才会触发 click。如果 mousedown,mosueup 中的任意一个被取消，就不会触发 click 事件 只有触发两次 click，才会触发一次 dblclick 事件 双击鼠标 事件触发顺序 mousedown mousemove mouseup click mousemove mousedown mousemove mouseup click dblclick 光标由元素 B 移入到元素 A，再移出 事件类型 所在元素 说明 1 mousemove B 光标移入 元素 A 2 mouseover A 3 mouseenter A 4 mousemove A 多次触发 mousemove 事件 光标移出 元素 A 5 mouseout A 6 mouseleave A 光标移入元素 A，然后移动到一个嵌套的元素 B，再返回元素 A，再移出元素 A| 事件类型 | 所在元素 | 说明 || ————- | ——– | ————————– | — || 1 mousemove | | || | | 光标移入元素 A || 2 mouseover | A | || 3 mouseenter | A | || 4 mousemove | A | 多次触发 mousemove 事件 || | | 光标移入到嵌套的元素 B || 5 mouseout | A | || 6 mouseover | B | || 7 mouseenter | B | || 8 mousemove | B | 多次触发 mousemove 事件 || | | 光标 从元素 B 移入到元素 A || 9 mouseout | B | || 10 mouseleave | B | || 11 mouseover | A | || 12 mousemove | A | 多次触发 mousemove 事件 || | | 光标从 A 元素移出 || 13 mouseout | A | | || 14 mouseleave | A | | mousemove 光标坐标位置 视口坐标位置，event.clientX,event.clientY 页面坐标位置,event.pageX,event.pageY 屏幕坐标位置.event.screenX,event.screenY 修改键DOM 规定了 4 个属性，表示这些修改键的状态：shiftKey,altKey,ctrlKey,metaKey,相应的键被按下，其值为 true，否则为 false。当鼠标事件发生时，就可以检测这几个属性就可以确定用户是否同时按下了其中的几个键。 1234567891011121314151617btn4.addEventListener(&quot;click&quot;, function (event) &#123; var keys = []; console.log(event); if (event.shiftKey) &#123; keys.push(&quot;shift&quot;); &#125; if (event.ctrlKey) &#123; keys.push(&quot;ctrl&quot;); &#125; if (event.metaKey) &#123; keys.push(&quot;meta&quot;); &#125; if (event.altKey) &#123; keys.push(&quot;alt&quot;); &#125; alert(`keys: $&#123;keys.join(&quot;, &quot;)&#125;`);&#125;); 滚动事件 当用户通过鼠标滚动页面时，就会触发 mousewheel 事件，这个事件可以在任何元素上触发，但最终都会冒泡到 document 或 window 对象上。 与 mousewheel 事件对象的 event 对象除了包含鼠标事件的所有标准信息外，还包含一个特性的wheelDelta属性，当向上滚动时，wheelDelta的属性的值是 120 倍数，向下滚动时，wheelDelta的属性的值是-120 倍数 12345678910&lt;div style=&quot;height: 2500px;&quot;&gt; &lt;span id=&quot;wheelDelta&quot; style=&quot;position: fixed; top: 90px;&quot;&gt;0&lt;/span&gt;&lt;/div&gt;&lt;script&gt; document.addEventListener(&quot;mousewheel&quot;, function (event) &#123; console.log(event); document.getElementById(&quot;wheelDelta&quot;).innerHTML = event.wheelDelta; &#125;);&lt;/script&gt; 文本事件 beforeinput,可编辑的内容被修改之前触发 input，可编辑的内容被修改之后触发 事件对象的data属性的值为输入文本的内容 键盘事件 keydown：按下键盘上的任意键触发，按住不放，会重复触发 keyup：释放键盘上的按键时触发 keypress,已废弃 键盘事件 触发顺序 keydown beforeinput input keyup 12345678910111213141516&lt;input type=&quot;text&quot; name=&quot;&quot; id=&quot;input&quot; /&gt;&lt;script&gt; var input = document.getElementById(&quot;input&quot;); input.addEventListener(&quot;beforeinput&quot;, function (event) &#123; console.log(&quot;beforeinput&gt;&gt;&gt;&quot;, event); &#125;); input.addEventListener(&quot;input&quot;, function (event) &#123; console.log(&quot;input&gt;&gt;&gt;&quot;, event); &#125;); input.addEventListener(&quot;keydown&quot;, function (event) &#123; console.log(&quot;keydown&gt;&gt;&quot;, event); &#125;); input.addEventListener(&quot;keyup&quot;, function (event) &#123; console.log(&quot;keyup&gt;&gt;&gt;&quot;, event); &#125;);&lt;/script&gt; HTML5 事件 contextmenu 事件（已过时，被删除） 由于 contextmenu 事件是冒泡的，因此可以为 document 指定一个事件处理程序，用以处理页面中所有的此类事件。 DOMContentLoaded 事件在形成完整的 DOM 树之后就会触发，不理会图像、js 文件、css 文件或其他资源是否已经下载完毕。 事件相关的性能事件委托事件委托利用了事件冒泡，只指定一个事件处理程序，就可以关联某一类的所有事件。例如，click 事件会一种冒泡到 document 层，所以只需为整个页面指定一个 onclick 事件处理程序，而不必给每个可单击的元素分别添加事件处理程序。与传统做法相比具有的优势： document 对象很快就可以访问，而且可以在页面生命周期的任何点上为它添加事件处理程序，无需等待 DOMContentLoaded 或 load 事件 只添加一个事件处理程序所需的 DOM 引用更少，所花费是时间也更少，页面加载更快 这个页面占用的内存空间更少 移除不需要的事件处理程序在不需要的时候要移除事件处理程序，因为内存中留有的那些过时不用的“空事件处理程序”也是造成 web 内存与性能问题的原因。例如，通过innerHTML替换元素时，如果带有事件处理程序的元素被innerHTML替换，那么用来添加到元素的事件处理程序极有可能无法被当作垃圾回收。所以，在已经知道要移除 dom 时，最后手动移除对应的事件处理程序 模拟事件除了用户操作或通过浏览器功能触发事件，也可以使用 JavaScript 在任意时刻刻意触发特定的事件。在测试 web 应用程序中，模拟触发事件是极其有用的技术。","categories":[{"name":"技术总结","slug":"技术总结","permalink":"https://better-jiang.github.io/categories/%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%93/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://better-jiang.github.io/tags/javascript/"}]},{"title":"JS知识点梳理(8)-DOM2级遍历和范围","slug":"JS知识点梳理-8-DOM2级遍历和范围","date":"2020-04-08T09:28:11.000Z","updated":"2023-02-03T12:14:22.420Z","comments":true,"path":"2020/04/08/JS知识点梳理-8-DOM2级遍历和范围/","link":"","permalink":"https://better-jiang.github.io/2020/04/08/JS%E7%9F%A5%E8%AF%86%E7%82%B9%E6%A2%B3%E7%90%86-8-DOM2%E7%BA%A7%E9%81%8D%E5%8E%86%E5%92%8C%E8%8C%83%E5%9B%B4/","excerpt":"","text":"DOM 遍历“DOM2 级遍历和范围”模块定义了 2 个用于遍历 DOM 结构的类型：NodeIterator和TreeWalker。它们都是基于给定的起点对 DOMM 结构执行深度优先的遍历操作。 NodeIterator使用document.createNodeIterator(root,whatToShow,filter)方法创建. root,创建NodeIterator时指定的根节点，即搜索的起点 whatToShow,表示要呈现的 Node 类型，由常量构成的位掩码。不匹配的节点被跳过。该参数的值以常量形式在 NodeFilter 类型中定义，如下所示 NodeFilter.SHOW_ALL:显示所有类型的节点 NodeFilter.SHOW_ELEMENT:显示元素节点 NodeFilter.SHOW_TEXT:显示文本节点 NodeFilter.SHOW_DOCUMENT:显示文档节点 NodeFilter.SHOW_COMMENT:显示注释节点 filter,用来指定自定义的 NodeFilter 对象，或者指定一个功能类似节点过滤器的函数。每个 NodeFilter 对象只有一个方法，即acceptNode(),如果应该访问给定节点，该方法返回NodeFilter.FILTER_ACCEPT,如果不应该访问给定节点，则返回NodeFilter.FILTER_SKIP,如果不指定，则传入null 12345678910111213141516171819202122232425262728 // 只显示&lt;p&gt;元素的节点迭代器 var filterObj = &#123; acceptNode: function (node) &#123; return node.nodeType === Node.ELEMENT_NODE &amp;&amp; node.tagName.toLowerCase() === &quot;p&quot; ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP; &#125;, &#125;; var iterator = document.createNodeIterator( document.body, NodeFilter.SHOW_ALL, filterObj ); var filterFn = function (node) &#123; console.log(&quot;filterFn node&quot;, node); return node.tagName.toLowerCase() === &quot;p&quot; ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP; &#125;;var iterator2 = document.createNodeIterator( document.body, NodeFilter.SHOW_ELEMENT, filterFn ); NodeIterator类型有 2 个方法 nextNode(),返回下一个节点，不存在返回null previousNode(),返回前一个节点，不存在返回null TreeWalkerTreeWalker 是 NodeIterator 的更高级版本。使用document.createTreeWalker(root,whatToSHow,filter)，参数同doucument.createNodeIterator()方法相同.但 filter 可以返回的值不同。可以使用NodeFilter.FILTER_REJECT 在使用NodeIterator对象时，NodeFilter.FILTER_REJECT与NodeFilter.FILTER_SKIP的作用相同 在使用TreeWalker对象时，NodeFilter.FILTER_SKIP会跳过相应节点并前进到子树的下一个节点，而NodeFilter.FILTER_REJECT会跳过相应节点以及该节点的整个子树。除了包含nextNode()，previousNode()方法外，还提供了用于不同方向上的遍历方法 parentNode(),遍历到当前节点的父节点 firstChild(),遍历到当前节点的第一个子节点 lastChild(),遍历到当前节点的最后一个子节点 nextSibling(),遍历到当前节点的下一个同辈节点 previousSibling(),遍历到当前节点的上一个同辈节点 DOM 范围“DOM2 级遍历和范围”中定义了范围（Range）接口，通过该接口可以选择文档中的一个区域，而不必考虑节点的界限。可以Document对象中的creanteRange()方法创建 Range。每一个范围由一个 Range 类型的实例表示 Range 属性 startContainer,包含范围起点的节点 startOffset,范围在startContainer中起点的偏移量 endContainer,包含范围终点的节点 endOffset,范围在endContainer中终点的偏移量 commonAncestorContainer,包含整个startContainer和endContainer的共同的祖先节点 Range 方法简单的范围 定位方法 selectNode(node),范围设置为包含整个给定的 node 节点（包括节点本身及其内容），此时范围的startContainer和endContainer属性是 node 节点的父节点 seletNodeContents(node)，范围设置为包含给定 node 节点的内容。此时范围的startContainer和endContainer属性就是给定 node 节点，startOffset为 0，endOffset为 node 节点的字符数或子节点个数 复杂的范围 定位方法 setStart(startNode, startOffset),设置范围的起始位置，参照节点startNode变成范围startContainer属性的值，偏移量startOffset变成范围startOffset属性的值。 setend(endNode,endOffset)，设置范围的终点。 范围 编辑方法 deleteContents(),从文档中移除 范围中的内容 extractContents(),把范围中的内容从文档移动到一个文档片段中 cloneContents(),返回一个包含范围中内容的文档片段 insertNode(newNode),在范围的起始位置插入给定节点 cloneRange(),复制范围，返回一个克隆的范围 对象。 detach(),清理范围，在使用完范围后，最后调用detach()方法，以便从创建范围的文档中分离处该范围，同时要解除对范围的引用（设置为 null），从而回收内存","categories":[{"name":"技术总结","slug":"技术总结","permalink":"https://better-jiang.github.io/categories/%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%93/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://better-jiang.github.io/tags/javascript/"}]},{"title":"JS知识点梳理(7)-DOM","slug":"JS知识点梳理-7-DOM","date":"2020-04-08T00:25:53.000Z","updated":"2023-02-03T12:14:22.420Z","comments":true,"path":"2020/04/08/JS知识点梳理-7-DOM/","link":"","permalink":"https://better-jiang.github.io/2020/04/08/JS%E7%9F%A5%E8%AF%86%E7%82%B9%E6%A2%B3%E7%90%86-7-DOM/","excerpt":"","text":"DOM(文档对象模型)是针对 HTML 或 XML 文档的一个 API，它描绘了一个层次化的节点数，允许开发人员添加、移除、修改页面的某一部分。 节点层次 DOM 将 HTML 或 XML 文档描绘成一个由多次层节点构成的结构 节点由不同类型，每种类型分别表示文档中不同的信息或标记；每个节点都有各种的特点、数据、方法，并与其他节点存在某种关系。 节点之间的关系构成了层次，所有页面标记表现为一个以特定节点为根节点的树形结构 文档节点 是每个文档的根节点。每个文档只要一个文档元素，在 HTML 中，文档元素始终是&lt;html&gt;元素 Node 类型 DOM 中定义一个 Node 接口，该接口由 DOM 中所有节点类型实现。 JavaScript 中所有节点类型（12 种）都继承自 Node 类型 Node 属性 Node.nodeType, 返回该节点类型所有对应的数值常量（12 种） Node.nameName, 返回包含该节点名字的DOMString。HTMLElement节点的对应元素的标签名()，Text节点 对应的是&quot;#text&quot;，Document节点对应的是&quot;#document&quot;. Node.nodeValue,返回或设置当前节点的值 Node.childNodes，返回该节点的所有子节点的实时的NodeLis.即 NodeList 是动态变化的，如果该节点的子节点发生变化，NodeList 对象会自动更新 Node.parentNode,返回该节点的父节点Node，没有则为null Node.firstChild,返回该节点的第一个子节点Node,没有则为null Node.lastChild,返回该节点的最后一个子节点Node,没有则为null Node.nextSibling,返回该节点同辈的下一个节点Node,没有则为null Node.previousSibling,返回该节点同辈的前一个节点Node,没有则为null Node.ownerDocument,返回该节点属于的Document对象。如果没有与之关联的Document对象，则返回null Node.isConnected,检测该节点是否已经连接到一个上下文对象，可用来判断一个节点是否已插入文档中 另外，还有一组与之类似的新属性，是只考虑文档中的HTMLElment类型节点，忽略Text节点。Node.children,Node.childElementCount,Node.firstElementChild,Node.lastElementChild,Node.parentElement,Node.nextElementSibling,Node.previousElementSibling Node 方法 Node.appendChild(child),将指定节点作为最后一个子节点添加到当前节点。不能跨文档插入，只能将某个节点插入到同一文档的其他位置 Node.insertBefore(newNode,referenceNode),在参考节点之前插入一个子节点。 如果要插入的节点是对文档中现有节点的引用，那么insertBefore()会将其从当前位置移动到新的位置。这意味着，一个节点不能同时位于文档的两个位置。 如果插入节点在选用文档中，可使用Node.cloneNode()复制该节点，但需要注意，该节点 副本不会自动同原始节点保持同步 如果引用节点null,则指定节点添加到父节点末尾。 如果给定的子节点是DocumentFragment,那么其全部内容将被移动到父节点的子节点列表中 Node.removeChild(child),移除当前节点的指定子节点，并返回移除的节点。如果参数引用了 DOM 树上现有的节点，则节点从当前位置分离，并添加到新位置 Node.repalceChild(newChild,oldChild),用指定节点替换当前节点的一个子节点。并返回被替换掉的节点。 Node.cloneNode(deep),克隆一个节点，参数deep可选，是否参数深度克隆，为true，则该节点的所有后代节点也会被克隆，false,则只会克隆该节点本身。 克隆一个元素节点会拷贝它所有的属性以及属性值。所有属性上绑定的事件会被拷贝(例如node.onclick=&quot;alert(123)&quot;)。但是不会拷贝使用addEvntListener()方法或者`node.onclick=”fn”这种动态绑定的事件 如果元素节点设置了id属性，并且克隆节点要插入相同的文档中，那么应该更改克隆节点的id属性，以保持唯一性。name属性可能也需要进行修改。 123456789101112131415161718192021222324252627&lt;body&gt; &lt;div id=&quot;box&quot;&gt; &lt;p onclick=&quot;alert(123)&quot;&gt;nihao&lt;/p&gt; &lt;p&gt;天天向上&lt;/p&gt; &lt;/div&gt; &lt;script&gt; function sayHello() &#123; alert(&quot;hello&quot;); &#125; var box = document.getElementById(&quot;box&quot;); var p2 = box.lastElementChild; p2.onclick = sayHello; let clone = box.cloneNode(); clone.setAttribute(&quot;id&quot;, &quot;clone&quot;); let deepClone = box.cloneNode(true); deepClone.setAttribute(&quot;id&quot;, &quot;deepClone&quot;); console.log( &quot;clone: %o, deepClone: %o&quot;, clone.childNodes, deepClone.childNodes ); box.parentNode.appendChild(clone); box.parentNode.appendChild(deepClone); &lt;/script&gt;&lt;/body&gt; Node.getRootNode()，返回上下文对象的根节点 Node.hasChildNodes(),该节点是否包含子节点 Node.contains(otherNode),传入节点是否为该节点的后代节点.**如果插入节点是该节点本身，则也返回 ture. (例如document.body.contains(document.body),返回 true) ** Node.isEqualNode(),判断两个节点是否相同。两节点类型相同，且属性、属性值，节点值相同，则返回 true。 Documnet 类型JavaScript 通过 Document 类型表示文档，它是HTMLDocument的一个实例。在浏览器中，document对象表示整个 HTML 页面，是 window 对象的一个属性，因此可以将其作为全局对象来访问。通过该document对象，不仅可以取得与页面相关的信息，而且还能操作页面的外观以及其底层结构。 文档子元素 Document.documentElement，返回当前文档的直接子节点，在 HTML 文档中，指向 HTML 页面的&lt;html&gt;元素 Document.body,指向&lt;body&gt;元素 文档信息 Document.doctype,返回文档类型定义 Document.characterSet,返回当前文档的字符编码 Document.title,获取或设置文档的标题 Document.cookie,返回一个使用分号分隔的 cookie 列表，或设置一个 cookie Document.location,返回当前文档的 Location对象。 查找元素 getElementById(),返回一个Element元素 getElementTagName()，返回元素的 HTML 集合HTMLCollection querySelector()m 根据 css 选择器匹配，返回匹配的第一个Element元素 querySelectorAll(), 返回一个节点集合NodeList HTMLCollection 和 NodeListNodeList是一个节点的集合，由Node.chidNodes和documet.querySelectorAll()返回的。有item(),entries(),keys(),values()方法 一些情况下，NodeList是一个实时集合，例如Node.childNodes是实时的 在其他情况下，NodeList是一个静态集合，例如，querySelectorAll()返回的是一个静态NodeList. HTMLCollection是一个包含了 html 元素的集合，由getElementByTagName()返回的，它是即时更新的（live）,当其所包含的文档结构发生改变时，它会自动更新。有item()，namedItem()方法 特殊结合 Document.all,返回一个以文档节点为根节点的 HTMLAllCollection集合 Document.forms,返回当前 文档中所有表单元素&lt;form&gt;的HTMLCollection列表 Document.images,返回当前文档中所有图片元素&lt;img&gt;的HTMLCollection列表 Document.links,返回当前文档中所有超链接元素&lt;a&gt;的HTMLCollection列表 Element 类型Element 类型通常用于表现 THML 或 XML 元素，这个接口描述了所有相同类型元素所具有的方法和属性。一些接口继承自Element并增加了一些额外功能，例如，HTMLElement接口是所有 HTML 元素的基本接口。 元素特性信息 Element.id,该元素的 id 属性值 Element.tagName,该元素标签名，同Node.nodeName值相同.注意,标签名以全部大写表示 Element.className,该元素的 class 属性的值 Element.classList,该元素包含的 calss 属性，是一个DOMTokenList Element.attributes,与该元素相关的所有属性的集合NamedNodeMap Element.innerHTML,元素的内容 获取/设置特性 getAttribute(name),返回元素上一个指定的属性值，如果不存在，返回null style特性，其属性值和通过getAttribute()返回的值不同，前者返回一个对象CSSStyleDeclaration，后者返回 style 特性值中包含 CSS 文本 onclicke特性，属性值返回一个 JavaScript 函数 ，getAttribute()返回相应代码的字符串 setAttribute(name, value),设置元素上的某个属性值，如果属性已存在，则更新该值。 removeAttribute(name)，从元素 中删除指定属性。 classList 属性元素的classList属性是一个DOMTokenList集合，此类型定义了以下方法： add(value)，将指定字符串值添加到列表，如果已存在，则忽略 remove(value),从列表删除给定的字符串 toggle(value),如果列表中已存在给定的值，删除它。如果不存在，添加它。 contains(value),列表中是否存在给定的值 attrubutes 属性 Element.attributes,返回与该元素相关的所有属性的实时集合NamedNodeMap。 NamedNodeMap接口表示属性节点Attr对象的集合，它也是即时的（live）,如果它内部包含的对象发生改变，该对象会自动更新。 元素尺寸/位置信息 Element.clientHeight,Element.clientWidth,元素内部像素高度/宽度（包含内边距，但不包括滚动条，边框和外边距) Element.offsetHeight,Element.offsetWidth,元素像素高度/宽度，包含元素的内边距，边框，和滚动条（chrome 17px） Element.scrollHeight,Element.scrollWidth,元素的滚动视图高度/宽度，包括由于溢出导致的不可见内容。 在没有滚动条情况下，同 clientHeight,clientWidth值相同 scrollHeight也包括::before和::after伪元素 Element.scrollTop,Element.scrollLeft,元素纵向/横向滚动条位置（即超出可视区域的内容大写)纵向滚动条最底层滚动条位置：scrollTop = scrollHeight - clientHeight 创建元素 document.createElement(tagName),创建一个由标签名称指定的 HTML 元素 document.createTextNode(),创建一个新的文本节点 document.createAttribute(),创建并返回一个新的属性节点 insertAdjacentHTML()element.insertAdjacentHTML(position,text),将指定的文本，解析为 Element 元素，并将结果节点插入到 DOM 树种的给定位置。参数position表示插入内容相对于元素的位置。 &quot;beforbegin&quot;,插入到元素自身的前面 &quot;afterbegin&quot;,插入到元素内部的第一个子节点之前 &quot;beforeend&quot;,插入到元素内部的最后一个子节点之后 &quot;afterend&quot;,元素自身的后面 12345678910&lt;!-- beforebegin --&gt;&lt;div&gt; &lt;!-- afterbegin --&gt; &lt;p&gt;...&lt;/p&gt; &lt;p&gt;...&lt;/p&gt; &lt;p&gt;...&lt;/p&gt; &lt;!-- beforeend --&gt;&lt;/div&gt;&lt;!-- afterend --&gt; Text 类型文本节点由 Text 类型表示，可以包含转义后的 HTML 字符，但不能包含 HTML 代码。 操作文本节点 appendData(text),添加文本到节点末尾 deleteData(offset, count),从 offset 指定位置开始删除 count 个字符 insertData(offset,text),在 offset 位置插入文本 replaceDate(offset,count,text),用 text 替换从 offset 指定位置开始到offset+count为止处的文本 splitText(offset),从 offset 处将文本分成 2 个文本节点 substringData(offset,count),提取从 offset 位置到offset + count为止处的字符串 normalize(),规范文本节点，在包含 2 个或多个文本节点的父元素上调用，会将所有文本节点合并成一个节点 DocumentFragment 类型文档片段是一种“轻量级”的文档，可以包含、控制节点，但不会像完整的文档那些占用额外资源。虽然不能将文档片段直接添加到文档，但可以将它当作一个“仓库”开使用，在里面保存将来可能要添加到文档的节点。 文档片段继承了Node所有方法 在 将文档片段添加文档时，实际上只会将文档片段所有的子节点添加到文档相应的位置，此时文档片段中的所有子节点都被删除。 Attr 类型元素的特性在 DOM 中以 Attr 类型表示。 元素的attributes属性中节点，即使特性节点 尽管其也是节点，但特性却不认为是 DOM 文档树的部分。 方便的表格操作为了方便构建表格，HTMLDOM 还为&lt;table&gt;,&lt;tbody&gt;,&lt;tr&gt;元素提供了一些特殊的属性和方法. table 元素 caption，对&lt;caption&gt;元素的指针 tFoot,对&lt;tfoot&gt;元素的指针 tHead,对&lt;thead&gt;元素是指针 tBodies,&lt;tbody&gt;元素的 HTMLCollection rows,表格所有行的 HTMLCOllection createTHead(),deleteTHead(),创建/删除&lt;thead&gt;元素 createTFoot,deleteTFoot()，创建/删除&lt;tfoot&gt;元素 insetRow(pos),像 rows 集合中的指定位置插入一行 deleteRow(pos)，删除指定位置的行tbody 元素 rows，&lt;tbody&gt;元素 中所有行的 HTMLCollection insertRow(pos),deleteRow(pos),在&lt;tbody&gt;元素中，向 rows 集合中插入/删除指定 位置的一行 tr 元素 cells，&lt;tr&gt;元素单元格的 HTMLCollection insertCell(pos)，deleteCell(),向 cells 集合中，插入/删除指定的一个单元格 DOM 对性能的影响 NodeList对象是“动态的”，这意味中每次访问NodeList对象，都会运行一次基于文档的查询，因此，要尽量减少 DOM 操作 文档中每一次的添加(appendChild())或插入(insertBefore())节点，都会触发 DOM 树的重新渲染。可先在文档片段(document fragment)中处理好后，在一次性的插入到文档中，这种操作仅发生一次重新渲染。","categories":[{"name":"技术总结","slug":"技术总结","permalink":"https://better-jiang.github.io/categories/%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%93/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://better-jiang.github.io/tags/javascript/"}]},{"title":"JS知识点梳理(6)-BOM","slug":"JS知识点梳理-6-BOM","date":"2020-04-02T21:44:40.000Z","updated":"2023-02-03T12:14:22.420Z","comments":true,"path":"2020/04/03/JS知识点梳理-6-BOM/","link":"","permalink":"https://better-jiang.github.io/2020/04/03/JS%E7%9F%A5%E8%AF%86%E7%82%B9%E6%A2%B3%E7%90%86-6-BOM/","excerpt":"","text":"BOM 即浏览器对象模型，是与浏览器交换的方法和接口。它提供了可以与浏览器窗口进行交互的对象结构，BOM 由多个对象构成，其中代表浏览器窗口的 window 对象是 OBM 的顶层对象。 window 对象BOM 的核心对象是 window,它表示浏览器的一个实例。在浏览器中，window 对象有双重角色。 是 JavaScript 访问浏览器窗口的一个接口 也是 ECMAScript 规定的 Global 对象。即在网页中定义的所有的全局对象，全局函数，全局变量都是自动成为 window 对象的成员，甚至是 DOM 对象也是 window 的属性。window.document.getElementById(&quot;id&quot;)等同于document.getElementById(&quot;id&quot;) 窗口关系及框架 如果页面中包含框架（frame/iframe 标签），则每个框架都有自己的 window 对象，并保存在 frames 集合中 top对象始终指向最高层的框架，也就是浏览器窗口。 self对象，始终指向 window。 窗口大小 outerWidth,outerHeight，返回浏览器窗口本身大小 innerWidth,innerHeight，返回页面视口大小 如果是移动浏览器，都返回的是布局视口，即渲染后页面的实际大小（与可见视口不同，可见视口只是整个页面的一小部分） document.documentElement.clientWidth和document.documentElement.clientHeight也保存了页面视口信息，返回页面视口大小 导航、打开窗口 在 HTML 中，可以使用一个 a 标签1&lt;a href=&quot;foo.html&quot; target=&quot;windowName&quot;&gt;about foos&lt;/a&gt; 在 JavaScript，使用window.open()方法既可以导航到一个特定的 URL，也可以打开一个新的浏览器窗口。1window.open(&quot;foo.html&quot;, &quot;windowName&quot;) 上述 2 方法，如果已经参加名称为”windowName”的窗口或框架，就会在其中加载指定的 URL。否则，就会穿甲一个新窗口并将其命名为”windowName” 窗口的名称必须是单个单词(只能是字母、数字和下划线，不能以数字开头)。有 4 个预定义的target: _blank 总是打开一个新窗口 _self 总是在当前窗口或框架中打开 _parent 在父框架中打开（如果有的话），否则为_self _top 打开整个浏览器窗口，即使有框架 window.open()可接受 4 个参数： 要加载的 URL 窗口目标（target） 新窗口的特性（字符串形式，以逗号分隔），控制新窗口的样式 新页面是否取代浏览器历史记录中当前加载页面 （布尔值） 窗口特性的设置选项 1234567891011121314151617181920212223&lt;body&gt; &lt;button id=&quot;but&quot;&gt;Open new Window&lt;/button&gt; &lt;!-- &lt;button id=&quot;close&quot;&gt;close&lt;/button&gt; --&gt; &lt;script&gt; if (window.name == &quot;myWindow&quot;) &#123; // Opened by myself document.write(&#x27;&lt;div class=&quot;example&quot;&gt;\\n&#x27;); document.write( &#x27;&lt;input type=&quot;button&quot; onclick=&quot;window.close()&quot;&#x27; + &#x27; value=&quot;window.close()&quot;&gt;&lt;\\/div&gt;\\n&#x27; ); &#125; var but = document.getElementById(&quot;but&quot;); but.onclick = function() &#123; let randowTop = Math.floor(Math.random() * 500 + 2); var newWindow = window.open( location.href, &quot;myWindow&quot;, `height=300,width=300,left=100,top=$&#123;randowTop&#125;,menubar=no,status=no` ); &#125;; &lt;/script&gt;&lt;/body&gt; 参考文章: windowd 对象 location 对象location 对象提供了电器窗口中加载是文档有关的信息，以及一些导航功能。它既是 window 对象的属性，又是 document 对象的属性。 属性名 例子 说明 hash “#contents” URL 中 的 hash（#后跟的字符） host “www.baidu.com:80&quot; 服务器名称和端口（如果有） hostname “www.baidu.com&quot; 服务器名称，不带端口 href “https://www.baidu.com/&quot; 当前加载页面的完整 URL，toString()返回值 pathname “/zh-CN/“ URL 中的目录和文件名 port “8080” URL 中指定的端口号，如果不包含，则返回空字符串 protocol “https:” 页面使用的协议 search “?q=java” URL 的查询字符串，以问号开头 location 修改操作修改location对象的属性可以改变当前加载的页面，除 hansh 外，每次修改location对象的属性，页面都会以新的 URL 重新加载，并且浏览器的历史记录中也会生成一条新记录。reload()方法，重新加载当前显示页面。如果 不传递 参数，页面会以最有效的方式重新加载。如果传递参数 true,则是要强制从服务器重新加载。location.reload(true) navigator 对象navigator 对象包含有关浏览器的信息。主要属性及说明如下表： Property Description appCodeName 浏览器名称 通常是”Mozilla” appName 完整的浏览器名称 appVersion 浏览器版本 cookieEnabled cookie 是否启用 geolocation 可用于定位用户位置的地理地位对象 language 浏览器的主语言 onLine 浏览器是否联网 platform 浏览器所在的系统平台 product 产品名称 userAgent 发送给服务器的用户代理头信息 history 对象history 对象保存着用户上网的历史记录，从窗口被打开那一刻算起。因为 history 是 window 对象的属性，所以每个浏览器窗口，每个标签页，每个框架，都有自己的 history 对象。 history 对象 属性 length属性，保存着历史记录的数量 history 对象 方法 back(),在 history 中向后跳转，等同于 点击浏览器回退按钮 forward()，在 history 中向前跳转，等同于 点击浏览器前进按钮 go()，跳转到 history 中指定的一个页面，通过与当前页面相对位置来标志 pushState(),添加历史记录条目，调用后，浏览器不会立即加载该 URL，某种意义上，同window.location=&quot;#foo&quot;类似。需要三个参数，状态对象，标题，TURL。 状态对象，是一个 JavaScript 对象。无论什么时候用户导航到新的状态，popstate 事件就会触发， 标题，字符串形式 URL，定义了新的历史 URL 记录。 repalceState()，修改当前历史记录项，比如想要更新状态对象 state,或者带当前历史记录的 URL 因公 [success] dd graph LR; client---core; client---common; core---common; common---portal; common---Biz; Biz---ConfigService; Biz---AdminService;","categories":[{"name":"技术总结","slug":"技术总结","permalink":"https://better-jiang.github.io/categories/%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%93/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://better-jiang.github.io/tags/javascript/"}]},{"title":"JS知识点梳理(5)-函数","slug":"JS知识点梳理-5-函数","date":"2020-04-02T07:11:05.000Z","updated":"2023-02-03T12:14:22.419Z","comments":true,"path":"2020/04/02/JS知识点梳理-5-函数/","link":"","permalink":"https://better-jiang.github.io/2020/04/02/JS%E7%9F%A5%E8%AF%86%E7%82%B9%E6%A2%B3%E7%90%86-5-%E5%87%BD%E6%95%B0/","excerpt":"","text":"定义 函数有 2 种形式 函数声明，它有一个重要特就是函数声明提升，即在执行代码之前会先读取函数声明。 函数表达式，创建一个函数并将其赋值给变量，此种情况下创建的函数叫匿名函数，因为 function 关键字后面没有标识符 闭包闭包是指有权访问另一个函数作用域中的变量的函数。创建闭包的常见方式，在一个函数内部创建另一个函数。 作用域链作用域链的本质是一个指向变量对象的指针列表。无论什么时候在函数中访问一个变量时，就会从作用域链中搜索具有相应名字的变量。当某个函数被调用时，会创建一个执行环境及相应的作用域链，这个作用域链被保存在内部的[[Scopes]]属性中。然后使用arguments和其他命名参数的值函数的活动对象，并将该活动对象放至作用域链前端，外部函数的活动对象位于作用域链第二位，外部函数的外部函数的活动对象处于第三位，….直至作为作用域链终点的全局执行环境。 123456789101112131415161718function createComparisonFunction(propertyName) &#123; return function(obj1, obj2) &#123; var val1 = obj1[propertyName]; var val2 = obj2[propertyName]; if (val1 &lt; val2) &#123; return -1; &#125; else if (val1 &gt; val2) &#123; return 1; &#125; else &#123; return 0; &#125; &#125;;&#125;var compare = createComparisonFunction(&quot;name&quot;);var result = compare(&#123; name: &quot;Nicholas&quot; &#125;, &#123; name: &quot;Greg&quot; &#125;);// 解除对匿名函数（闭包）的引用（以便释放内存）compare = null; 在匿名函数从 createComparisonFunction()中返回后，它的作用域链被初始化位包含 createComparisonFunction()函数的活动对象和全局变量对象。并且在 createComparisonFunction()函数执行完毕后，其执行环境的作用域链会被销毁，但它的活动对象会保留在内存中，因为匿名函数的作用域链仍然在引用这个活动对象。直到匿名函数被消耗，createComparisonFunction()的活动对象才会被销毁。 闭包作用闭包有两个作用： 可以读取自身函数外部的变量（沿着作用域链寻找） 让这些外部变量始终保存在内存中 闭包与变量一个值的注意的地方：闭包只能取得包含函数中任何变量的最后一个值。闭包所保存的是整个变量对象，而不是某一个特殊的变量。 1234567891011121314function createFunctions() &#123; var result = new Array(); for (var i = 0; i &lt; 10; i++) &#123; result[i] = function() &#123; return i; &#125;; &#125; return result;&#125;var result = createFunctions();console.log(result()[0]()); // 10console.log(result()[1]()); // 10console.log(result()[9]()); // 10 上述函数会返回一个函数数组，表面是，似乎每个函数都应返回自己的索引值，但实际上，每个函数都返回 10.因为每个函数的作用域链中都保存着 createFunctions()函数的活动对象，所以它们引用的都是同一变量 i,当 createFunctions()返回后，变量 i 的值是 10，此时每个函数都引用着保存变量 i 的同一个变量对象，所以每个函数内部的 i 的值都是 10 要解决此问题，可以通过创建另一个匿名函数,并立即执行匿名函数，将其结果赋值给数组。这里的匿名函数中有一个参数 num,也就是最终函数要返回的值，即返回了一个返回 num 的闭包。 123456789101112function createFunctions() &#123; var result = new Array(); for (var i = 0; i &lt; 10; i++) &#123; result[i] = (function(num) &#123; return function() &#123; return num; &#125;; &#125;)(i); &#125; return result;&#125; 关于 this 对象this 对象是在运行时基于函数的执行环境绑定的：在全局函数中，this 指向 window,而当函数被作为某个对象的方法调用时，this 指向那个对象。不过，匿名函数的执行环境具有全局性，因此其 this 对象通常指向 window另外，每个函数在被调用时都会自动获取 2 个特殊变量：this 和 arguments。内部函数在搜索这 2 个 变量时，只会搜索到其活动对象为止，因此永远不能直接访问外部函数中的这两个变量。不过，可以把外部函数中的 this 对象保存在一个闭包能访问的变量里，就可以让闭包访问该对象了 1234567891011121314151617181920var name = &quot;The Window&quot;;var obj = &#123; name: &quot;My Object&quot;, getName: function() &#123; return function() &#123; return this.name; &#125;; &#125;, getName2: function() &#123; var that = this; return function() &#123; return that.name; &#125;; &#125;&#125;;let getNameFun = obj.getName();console.log(getNameFun()); // The Windowlet getName2Fun = obj.getName2();console.log(getName2Fun()); // My Object 模仿块级作用域JavaScript 没有块级作用域的概念，立即执行的匿名函数可以用来模仿块级作用域，语法如下： 123(function() &#123; // 块级作用域&#125;)(); 这种技术经常用于全局作用域中的外部函数，从而限制向全局作用域中添加过多的变量和函数。通过创建私有作用域，每个开发人员既可以使用 自己的变量，又不必担心同全局变量和函数发生命名冲突。此种做法可以减少闭包占用的内存问题，因为没有指向匿名函数的引用。只要函数执行完毕，就立即销毁其作用域链了 123456(function()&#123; var now = new Date(); if(now.getMonth === 0 &amp;&amp; now.getDate() === 1) &#123; alert(&quot;Happy new year!&quot;); &#125;&#125;)(); 私有变量任何函数中定义的变量，都可以认为是私有变量，因为不能在函数的外部访问这些变量。它包括函数的参数，局部变量，和在函数定义的其他函数。如果在函数内部创建一个闭包，那么闭包通过作用域链就可以访问这些变量，利用这一点，就可以创建用于访问私有变量的公用方法。有权访问私有变量和私有函数的公用方法称为特权方法 在构造函数中定义特区方法123456789101112function Person(name) &#123; this.getName = function() &#123; return name; &#125;; this.setName = function(value) &#123; name = value; &#125;;&#125;var person = new Person(&quot;jiang&quot;);console.log(person.getName()); // &quot;jiang&quot;person.setName(&quot;tingting&quot;);console.log(person.getName()); // &quot;tingting&quot; 2 个特权方法： getName()、 setName(),都可在构造函数外部使用，有权访问私有变量name.因为这 2 个方法都在构造函数内部定义，它们作为闭包能够通过作用域链访问到name. 模块模式模块模式是为单例（只要一个实例的对象）创建私有变量和特权方法。 JavaScript 是以对象字面量的方式来创建单例对象的。模块模式通过为单例添加私有变量和特权方法使其得到增强，语法如下： 12345678910111213141516var singleton = (function() &#123; var privateVariable = 10; function privateFunction() &#123; return privateVariable; &#125; // 公有属性，特权方法 return &#123; publicProperty: &quot;publicProperty&quot;, publicMethod: function() &#123; privateVariable++; return privateFunction(); &#125; &#125;;&#125;)();console.log(singleton.publicProperty); // &quot;publicProperty&quot;console.log(singleton.publicMethod()); // 11","categories":[{"name":"技术总结","slug":"技术总结","permalink":"https://better-jiang.github.io/categories/%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%93/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://better-jiang.github.io/tags/javascript/"}]},{"title":"JS知识点梳理(4)-面向对象","slug":"JS知识点梳理-4-面向对象","date":"2020-04-01T20:17:53.000Z","updated":"2023-02-03T12:14:22.419Z","comments":true,"path":"2020/04/02/JS知识点梳理-4-面向对象/","link":"","permalink":"https://better-jiang.github.io/2020/04/02/JS%E7%9F%A5%E8%AF%86%E7%82%B9%E6%A2%B3%E7%90%86-4-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/","excerpt":"","text":"理解对象ECMA 把对象定义为“无序属性的集合，其属性可以包含基本值、对象或函数”。也可把对象想象成散列表：无非就是一组名值对，其值可以是基本值、对象或函数。每个对象都是基于一个引用类型创建的，这个引用类型可以是原生类型，也可以是开发人员自己定义的类型。 属性类型对象的属性在创建时都带有一些特征值，JS 通过这些特征值来定义它们的行为。这些特性时内布值，不能直接访问它们，将其放在 2 对方括号内。其分为 2 中属性：数据属性和访问器属性 数据属性数据属性有 4 个描述其行为的特性： [[Configurable]]: 表示 能否通过delete删除属性，能否修改属性的特性，能否把属性修改为访问器属性。默认值为true [[Enumerable]]: 表示 是否可枚举，通过for..in循环返回属性。 默认值为true [[Writable]]: 表示 能否修改属性，默认值为true [[Value]]: 此属性的数据值。读取属性值时，从这里读；写入属性值时，把新值保存在这里。默认值为undefined 要修改属性默认的特性，必须使用Object.defineProperty(obj,prop,descriptor). 在调用Object.defineProperty()方法创建一个新属性时，描述符对象如果不指定特性值，configurable,enumerable,writable特性的默认值时false.如果是修改已定义的属性的特性，则无此限制 12345678910111213var person = &#123;&#125;;Object.defineProperty(person, &quot;name&quot;, &#123; value: &quot;jiang&quot;,&#125;);console.log(person.name); // &quot;jiang&quot;person.name = &quot;amile&quot;;// 创建新 name 属性时， writable,configurable，enumerable 默认值为false . 所有不可重写，不可配置console.log(person.name); // &quot;jiang&quot;console.log(Object.getOwnPropertyDescriptor(person, &quot;name&quot;));Object.defineProperty(person, &quot;name&quot;, &#123; configurable: true, value: &quot;amile&quot;&#125;); // 访问器属性访问器属性不包含数据值。但包含一对 getter,setter 函数（都不是必需的）。在读取访问器属性时，会调用 getter 函数，返回有效的值；在写入访问器属性时，会调用 setter 函数并传入新值，此函数决定如何处理函数。 [[Configurable]]: 同数据属性中的[[Configurable]] [[Enumerable]]: 同数据属性中的[[Enumerable]] [[Get]]: 在读取属性时调用的函数。默认值为undefined [[Set]]: 在写入属性时调用的函数。默认值为undefined **访问器属性不能直接定义，必须使用Object.defineProperty()**来定义。 读取属性的特性ECMAScript 5 的Object.getOwnPropertyDescriptor(obj,prop),可取得给定属性的描述符对象。 如果是数据属性，该对象的属性有configurable,enumerable,writable,value; 如果是访问器属性,该对象的属性有configurable,enumerable,get,set 1234567891011121314151617181920212223var book = &#123;&#125;;Object.defineProperties(book, &#123; _year: &#123; value: 2020 &#125;, edition: &#123; value: 1 &#125;, year: &#123; get: function() &#123; return this._year; &#125;, set: function(newValue) &#123; if (newValue &gt; 2020) &#123; this._year = newValue; this.edition = newValue - 2020 + 1; &#125; &#125; &#125;&#125;);console.log(Object.getOwnPropertyDescriptor(book, &quot;_year&quot;)); // Object &#123;value: 2020, writable: false, enumerable: false, configurable: false&#125;console.log(Object.getOwnPropertyDescriptor(book, &quot;year&quot;)); // Object &#123;get: function() &#123;...&#125; , set: function(newValue) &#123;...&#125;, enumerable: false, configurable: false&#125; 创建对象工厂模式用函数来封装创建对象的细节.有致命缺点，不知道对象的类型，没有解决对象识别问题 1234567891011// 工厂模式function createPerson(name, age) &#123; var person = new Object(); person.name = name; person.age = age; person.sayName = function() &#123; console.log(this.name); &#125;; return person;&#125;var person1 = createPerson(&quot;jiang&quot;, 26); 构造函数模式创建自定义的构造函数。按照惯例，构造函数始终都应该以一个大写字母开头，而非构造函数以一个小写字母开头。 创建实例的过程要创建新实例，必须使用new操作符，以此方式调用构造函数实际会经历以下步骤： 创建一个新对象 将构造函数的作用域赋给新对象，即 this也就指向了这个新对象 执行构造函数中的代码，为新对象添加属性 返回该新对象 123456789function Person(name, age) &#123; this.name = name; this.age = age; this.sayName = function() &#123; console.log(this.name); &#125;&#125;var person1 = new Person(&quot;jiang&quot;, 26);var person2 = new Person(&quot;amile&quot;, 22); 构造函数模式的优缺点优点对象的constructor属性指向创建它的构造函数，因此可以使用instanceof操作符来 检测对象类型。 1234var person1 = new Person(&quot;jiang&quot;, 26);console.log(person1.constructor === Person); // trueconsole.log(person1 instanceof Person); // trueconsole.log(person1 instanceof Object); // true 缺点构造函数内定义的每个方法，都要在每个实例上重新创建一遍。该问题可以通过原型模式来解决 原型模式 每一个函数都一个prototype(原型)属性，它是一个指针，指向一个对象。该对象包含 使用该构造函数创建的所有实例 共享的属性和方法。 prototype就是通过调用构造函数而创建的那个对象实例的 原型对象 原型对象包含的属性和方法，共享给所有对象实例。因此，不必在构造函数定义对象实例要共享的信息，而是把这些信息添加到原型对象中。 1234567891011function Person() &#123;&#125;Person.prototype.name = &quot;jaing&quot;;Person.prototype.age = 26;Person.prototype.sayName = function() &#123; console.log(this.name);&#125;;var person1 = new Person();var person2 = new Person();person1.sayName(); // &quot;jiang&quot;console.log(person2.age); // 26console.log(person1.sayName === person2.sayName); // true 理解原型对象 只要创建了一个新函数，就会创建一个prototype属性，这个属性指向函数的原型对象。 所有的原型对象都会自动包含一个constructor属性，它是一个指向prototype属性所在函数的指针。因为该属性在原型对象中，所以也是共享的，可通过对象实例访问。person.constructor === Person,Person.prototype.constructor === Person 但调用构造函数创建一个新实例后，该实例内部将包含一个指针（[[Prototype]],内部属性）,指向构造函数的原型对象。在浏览器中，每个对象都支持一个属性__proto__来访问[[Prototype]]. 实例的[[Prototype]] 或 __proto__指向的是构造函数的原型对象。该连接存在于实例和构造函数的原型对象之间，而不存在于实例和构造函数之间 ECMAScript 5 新增Object.getPrototypeOf() 可返回对象的原型，即一个对象的[[Prototype]] 或 __proto__的值。即Object.getPrototypeOf(person1) === Person.prototype，Object.getPrototypeOf(person1) === person1.__proto__ hasOwnProperty()方法 ，可以检测一个属性是否存在于实例中，还是存在于原型中。只有给定属性存在于实例对象中，才返回 true 原型 于 in 操作符 单独使用 in 操作符：只要对象能够访问指定属性就返回 true,无论该属性存在于实例还是原型中。 123456console.log(person1.hasOwnProperty(&quot;name&quot;)); // false name 来自 原型console.log(&quot;name&quot; in person1); // trueperson1.name = &quot;qiang&quot;;console.log(person1.hasOwnProperty(&quot;name&quot;)); // true name 来自 实例console.log(&quot;name&quot; in person1); // true for...in循环：循环所以能通过对象访问的，可枚举的属性，包含存在于实例中的，也包括存在于原型中的属性。会屏蔽 不可枚举的属性（即[[Enumerable]]标记为 false）。constructor,prototype是不可枚举的。 Object.keys()，获取对象上所有可枚举的实例属性。 Object.getOwnPropertyNames()，获取对象上所有实例属性，无论它是否可枚举。 12345678910111213141516function Person() &#123;&#125;Person.prototype.name = &quot;jaing&quot;;Person.prototype.age = 26;Person.prototype.sayName = function() &#123; console.log(this.name);&#125;;var person1 = new Person(); person1.school = &quot;26 school&quot;; var props = []; for (var v in person1) &#123; props.push(v); &#125; console.log(props); // [&quot;name&quot;, &quot;school&quot;, &quot;age&quot;, &quot;sayName&quot;] console.log(Object.keys(Person.prototype)); // [&quot;name&quot;, &quot;age&quot;, &quot;sayName&quot;] console.log(Object.getOwnPropertyNames(Person.prototype)); // [&quot;constructor&quot;, &quot;name&quot;, &quot;age&quot;, &quot;sayName&quot;] 更简单的原型语法前面例子中每添加一个属性或方法就要敲一遍Person.prototype，为减少输入，通常会使用一个包含所有属性和方法的对象字面量来重写整个原型对象。在将Person.prototype设置为一个新对象，其constructor属性对不再指向Person 构造函数了，而是指向了新对象的constructor属性，即 Object 构造函数。此时，尽管instanceof操作符返回正确结果，但通过constructor已经无法确定对象类型了。 12345678910111213function Person() &#123;&#125;Person.prototype = &#123; name: &quot;jiang&quot;, age: 26, sayName: function() &#123; console.log(this.name); &#125;&#125;;var friend = new Person();console.log(friend instanceof Person); // trueconsole.log(friend.constructor === Person); // falseconsole.log(friend.constructor === Object); // true 解决此问题，可以手动设置一个constructor属性，值为 Person，且不可枚举。 1234567891011121314151617function Person() &#123;&#125; Person.prototype = &#123; name: &quot;jiang&quot;, age: 26, sayName: function() &#123; console.log(this.name); &#125; &#125;; Object.defineProperty(Person.prototype, &quot;constructor&quot;, &#123; enumerable: false, value: Person &#125;); var friend = new Person(); console.log(friend instanceof Person); // true console.log(friend.constructor === Person); // true console.log(friend.constructor === Object); // false 原型的动态性由于在原型中查找值的过程是一次搜素，因此对原型对象所做的任何修改都能立即从实例反映出来，即使是先创建了实例之后，再修改原型也照样如此实例于原型之间的连接（[[Prototype]] 或者 __proto__）是一个指针，而非副本.如果重新整个原型，就会切断现有原型同之前已经存在的对象实例之间的联系。之前对象实例引用的仍然是最初的原型。 12345678910111213141516function Person() &#123;&#125;var friend = new Person();Person.prototype.sayName = function() &#123; console.log(&quot;hi&quot;);&#125;;friend.sayName(); // hi ,在原型中查找Person.prototype = &#123; constructor: Person, name: &quot;jiang&quot;, age: 26, sayName: function() &#123; console.log(this.name); &#125;&#125;;console.log(friend.name); // jiangfriend.sayName(); // hi ，在最初的原型中查找 原型对象的问题 它省略了为构造函数传参，结果所有实例在默认情况下都是相同的属性值。 最大问题，对应包含引用类型值的属性，在一个实例上修改，会被多个实例共享 1234567891011121314151617function Person() &#123;&#125;Person.prototype = &#123;constructor: Person,name: &quot;jiang&quot;,age: 26,sayName: function() &#123; console.log(this.name);&#125;,friends: [&quot;a&quot;, &quot;b&quot;]&#125;;var person1 = new Person();var person2 = new Person();person1.friends.push(&quot;c&quot;);console.log(person1.friends); // [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]console.log(person2.friends); // [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]console.log(person1.friends === person2.friends); // true 组合使用构造函数模式和原型模式 （最理想的模式）创建自定义类型最常见的方式，就是组合使用构造函数模式和原型模式。 构造函数模式用于定义实例属性 原型模式有于定义方法和共享的属性 每个实例都有自己的一份实例属性副本，同时又共享着对方法的引用，最大限度的节省了内存。 12345678910111213141516171819// 组合模式function Person(name, age) &#123; this.name = name; this.age = age; this.friends = [&quot;a&quot;, &quot;b&quot;];&#125;Person.prototype = &#123; constructor: Person, sayName: function() &#123; console.log(this.name); &#125;&#125;;var person1 = new Person(&quot;jiang&quot;, 26);var person2 = new Person(&quot;ting&quot;, 25);person1.friends.push(&quot;c&quot;);console.log(person1.friends); // [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]console.log(person2.friends); // [&quot;a&quot;, &quot;b&quot;]console.log(person1.sayName === person2.sayName); // true 动态原型模式使用组合模式，构造函数和原型是独立的，动态原型模式则把所有信息都封装在了构造函数中，并在必要情况下，在构造函数内初始化原型。也同时保存了使用构造函数和原型的优点。 1234567891011// 动态原型模式function Person(name, age) &#123; this.name = name; this.age = age; this.friends = [&quot;a&quot;, &quot;b&quot;];&#125;if (typeof this.sayName !== &quot;function&quot;) &#123; Person.prototype.sayName = function() &#123; console.log(this.name); &#125;;&#125; 寄生构造函数模式基本思想是创建一个函数，该函数的作用仅仅是封装创建对象的代码，然后返回新创建的对象。 1234567891011121314function Person(name, age) &#123; var o = new Object(); o.name = name; o.age = age; o.sayName = function() &#123; console.log(this.name); &#125;; return o;&#125;var person4 = new Person(&quot;tingyu&quot;, 28);person4.sayName();console.log(person4 instanceof Person); // falseconsole.log(person4.constructor); // function Object &#123;...&#125;console.log(Object.getPrototypeOf(person4)); // Object &#123;...&#125; 寄生构造函数模式，返回的对象于构造函数或者构造函数的原型属性之间没有关系，所有，不能依赖 instanceof 来确定对象类型 对象继承由于函数没有签名，在 ECMAScript 中无法实现接口继承，所以只支持实现继承，并主要依靠原型链来实现的。基本思路就是利用原型让一个引用类型继承另一个引用类型的属性和方法。 原型链构造函数、原型、实例间关系 每个构造函数都有一个原型对象（Fn.prototype） 原型对象都包含一个指向构造函数的指针(Fn.prototype.constructor) 实例都包含一个指向原型对象的内部指针(instance.__proto__) 让原型对象等于另一个类型的实例,此时的原型对象将包含一个指向另一个原型对象的指针，相应的，另一个原型中也包含着指向另一个构造函数的指针。假如，另一个原型又是另一个类型的实例，依次层层递进，就构成了实例与原型的链条 12345678910111213141516171819202122232425262728// 原型链function SuperType() &#123; this.property = true;&#125;SuperType.prototype.getSuperValue = function() &#123; return this.property;&#125;;function SubType() &#123; this.subproperty = false;&#125;// 继承SubType.prototype = new SuperType();SubType.prototype.getSubValue = function() &#123; return this.subproperty;&#125;;var instance = new SubType();console.log(instance.getSubValue()); // falseconsole.log(instance.getSuperValue()); // trueconsole.log(instance instanceof SubType); // trueconsole.log(instance instanceof SuperType); // trueconsole.log(Object.getPrototypeOf(instance)); // SuperType &#123;...&#125;console.log(instance.constructor); // function SuperType() &#123;...&#125;// instanceof 用于检测构造函数的 prototype 属性是否出现在某个实例对象的原型链// Object.getPrototypeOf() 方法返回指定对象的原型（内部[[Prototype]]属性的值） 在上面代码中，没有使用 SubType 默认提供的原型，而是给它换了一个新原型，就是 SuperType 的实例。新原型不仅具有 SuperType 的实例所拥有的全部属性和方法，而且其内部还有一个指针，指向 SuperType 的原型。所以，instance 指向 SubType 的原型，SubType 的原型又指向 SuperType 的原型。另外，instance.constructor现在指向的是SuperType，这是因为原来SubType.prototype中的constructor被重写的缘故。 原型搜索机制在通过原型链实现继承的情况下，搜索过程就是沿着原型链继续向上，直到原型链末端null停止。当访问一个实例属性时，首先在实例中搜索该属性。如果没有，则会继续搜索实例的原型，如果还没有，则去实例原型的原型中搜索，沿着原型链向上一直搜索，直到原型为 null 为止。 确定原型和实例的关系 instanceof:检测构造函数的 prototype 属性是否出现在某个实例对象的原型链上123console.log(instance instanceof Object); // trueconsole.log(instance instanceof SuperType); // trueconsole.log(instance instanceof SubType); // true isPrototypeOf()，用于测试一个对象是否存在于另一个对象的原型链上.123console.log(Object.prototype.isPrototypeOf(instance)); // trueconsole.log(SuperType.prototype.isPrototypeOf(instance)); // trueconsole.log(SubType.prototype.isPrototypeOf(instance)); // true 添加方法注意事项 给原型定义方法，一定要放在替换原型的语句之后 在通过原型链实现继承时，不能用对象字面量创建原型方法，因为这样就会重新原型链 原型链的问题 在通过原型来实现继承时，原型实际上会变成另一个类型的实例，于是，原先的实例属性也就顺理成章地变成了现在的原型属性了。1234567891011function SuperType() &#123; this.colors = [&quot;red&quot;, &quot;blue&quot;, &quot;green&quot;];&#125;function SubType() &#123;&#125;SubType.prototype = new SuperType();var instance = new SubType();instance.colors.push(&quot;white&quot;);console.log(instance.colors); // [&quot;red&quot;, &quot;blue&quot;, &quot;green&quot;, &quot;white&quot;]var instance2 = new SubType();console.log(instance2.colors); // [&quot;red&quot;, &quot;blue&quot;, &quot;green&quot;, &quot;white&quot;]console.log(instance2.colors === instance.colors); // true 在创建子类型的实例时，不能向超类型的构造函数中传递参数。 借用构造函数继承/伪造对象继承/经典继承基本思想就是在子类型构造函数的内部调用超类型构造函数。 123456789101112131415function SuperType(name) &#123; this.name = name; this.colors = [&quot;red&quot;, &quot;blue&quot;, &quot;green&quot;];&#125;function SubType(name,age) &#123; // 调用SuperType构造函数，继承了 SupperType SuperType.call(this,name); this.age = age;&#125;var instance = new SubType(&quot;jiang&quot;,26);instance.colors.push(&quot;white&quot;);console.log(instance.colors); // [&quot;red&quot;, &quot;blue&quot;, &quot;green&quot;, &quot;white&quot;]var instance2 = new SubType(&quot;yuting&quot;,28);console.log(instance2.colors); // [&quot;red&quot;, &quot;blue&quot;, &quot;green&quot;]console.log(instance2.colors === instance.colors); // false 借用构造函数的问题 方法都在构造函数中定义，因此函数无法复用 在超类原型上定义的方法，对子类而已是不可见的。 组合继承（最常用的继承模式）将原型链和借用构造函数的技术组合到一起，从而发挥二者之长。 使用原型链实现对原型属性和方法的继承 通过借用构造函数来实现对实例属性的继承 123456789101112131415161718192021222324252627282930// 组合继承function SuperType(name) &#123; this.name = name; this.colors = [&quot;red&quot;, &quot;blue&quot;, &quot;green&quot;];&#125;SuperType.prototype.sayName = function() &#123; console.log(this.name);&#125;;function SubType(name, age) &#123; // 继承属性 SuperType.call(this, name); this.age = age;&#125;// 继承方法SubType.prototype = new SuperType();SubType.prototype.constructor = SubType;SubType.prototype.sayAge = function() &#123; console.log(this.age);&#125;;var instance = new SubType(&quot;jiang&quot;, 26);instance.colors.push(&quot;white&quot;);console.log(instance.colors); // [&quot;red&quot;, &quot;blue&quot;, &quot;green&quot;, &quot;white&quot;]instance.sayName(); // &quot;jiang&quot;instance.sayAge(); // 26var instance2 = new SubType(&quot;yuting&quot;, 28);console.log(instance2.colors); // [&quot;red&quot;, &quot;blue&quot;, &quot;green&quot;]instance2.sayName(); // &quot;yuting&quot;instance2.sayAge(); // 28 原型式继承借助原型可以基于已有的对象创建新对象，同时还不必因此创建自定义类型的构造函数。为达到这个目的，使用如下函数。先创建一个临时的构造函数，然后将传入的对象作为该构造函数的原型，最后返回这个临时类型的新实例。 12345function Object(o) &#123; function F() &#123;&#125; F.prototype = o; return new F();&#125; ECMAScript 5 新增Object.create()方法规范了原型式继承，这个方法接受 2 个参数，第一个，为作为新对象原型的对象，第二个，为新对象定义额外属性的对象。其行为同上面Object()方法相同 123456789101112131415var person = &#123; name: &quot;jiang&quot;, friends: [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]&#125;;var person2 = Object.create(person);person2.friends.push(&quot;d&quot;);var person3 = Object.create(person, &#123; name: &#123; value: &quot;yuting&quot; &#125;&#125;);console.log(person3.name); // &quot;yuting&quot;console.log(person3.friends); // [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;]console.log(person.friends); // [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;] 问题，包含引用类型值的属性始终都会共享相应 的值，就 像使用原型模式一样。 寄生式继承寄生式继承 的思路同寄生构造函数和工厂模式类似，即创建一个仅用于封装继承过程的函数，该函数在内部以某种方式来增强对象，最后返回该对象。 12345678function createAnther(original) &#123; var clone = Object.create(original); original.sayHi = function() &#123; console.log(&quot;Hi Hi&quot;); &#125;; return clone;&#125;console.log(createAnther(&#123;&#125;).sayHi()); // &quot;Hi Hi&quot; 寄生组合式继承 （最理想的继承模式）组合继承是 JavaScript 中最常用的继承模式，但它有不足之处。会调用 2 次超类型构造函数：一次在创建子类型的原型时。另一次在子类型构造函数内部调用超类构造函数。 123456789101112131415161718function SuperType(name) &#123; this.name = name; this.colors = [&quot;red&quot;, &quot;blue&quot;, &quot;green&quot;];&#125;SuperType.prototype.sayName = function() &#123; console.log(this.name);&#125;;function SubType(name, age) &#123; // 继承属性 SuperType.call(this, name); // 第二次调用 SuperType() this.age = age;&#125;// 继承方法SubType.prototype = new SuperType(); // 第一次调用 SuperType()SubType.prototype.constructor = SubType;SubType.prototype.sayAge = function() &#123; console.log(this.age);&#125;; 第一次调用 SuperType 构造函数时，SubType.prototype会得到 2 个属性:name和colors，它们都是 SuperType 的实例属性，只不过位于 SubType 的原型上。 当调用 SubType 构造函数时，会第二次调用 SuperType 构造函数，这次是在新对象 SubType 的实例上创建了实例属性name,colors，于是这 2 个属性屏蔽了原型中的 2 个同名属性。 解决方法– 寄生组合式继承。通过构造函数来继承属性，通过原型链的混成形式来继承方法。不必为了指定子类型的原型而调用超类型的构造 函数，我们需要的无非就是超类型原型的一个副本而已。 简单形式，如下： 12345678910111213141516171819202122232425262728// 寄生组合模式function inheritPrototype(subTyppe, supperType) &#123; var prototype = Object.create(supperType.prototype); // 获取超类原型副本 prototype.constructor = subTyppe; // 为副本添加constructor 属性 subTyppe.prototype = prototype; // 将创建的副本 赋 给子类型的原型&#125;function SuperType(name) &#123; this.name = name; this.colors = [&quot;red&quot;, &quot;blue&quot;, &quot;green&quot;];&#125;SuperType.prototype.sayName = function() &#123; console.log(this.name);&#125;;function SubType(name, age) &#123; // 继承属性 SuperType.call(this, name); // 第二次调用 SuperType() this.age = age;&#125;// 继承方法inheritPrototype(SubType, SuperType);SubType.prototype.sayAge = function() &#123; console.log(this.age);&#125;;var instance = new SubType(&quot;jiang jiang&quot;, 26);instance.sayName();instance.sayAge();","categories":[{"name":"技术总结","slug":"技术总结","permalink":"https://better-jiang.github.io/categories/%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%93/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://better-jiang.github.io/tags/javascript/"}]},{"title":"JS知识点梳理(3)-引用类型","slug":"JS知识点梳理-3-引用类型","date":"2020-03-30T09:53:44.000Z","updated":"2023-02-03T12:14:22.419Z","comments":true,"path":"2020/03/30/JS知识点梳理-3-引用类型/","link":"","permalink":"https://better-jiang.github.io/2020/03/30/JS%E7%9F%A5%E8%AF%86%E7%82%B9%E6%A2%B3%E7%90%86-3-%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B/","excerpt":"","text":"Object 类型 对象字面量表示法是对象定义的一种简写形式。 有 2 种访问对象属性的方法：点表示法，方括号法。方括号法可以通过变量来访问属性。 Object.assign():将所有可枚举的自身属性的值从一个或多个 源对象复制到目标对象。其拷贝的是属性值，假如源对象的属性值是一个对象的引用，那么它也指向那个引用。可以使用 JSON 序列化，实现深拷贝。 123456let obj = &#123; a: 0, b: &#123; c: 0 &#125; &#125;;let deepClone = JSON.parse(JSON.stringify(obj));obj.a = 4;obj.b.c = 4;console.log(JSON.stringify(obj)); // &#123;&quot;a&quot;:4,&quot;b&quot;:&#123;&quot;c&quot;:4&#125;&#125;console.log(JSON.stringify(deepClone)); // &#123;&quot;a&quot;:0,&quot;b&quot;:&#123;&quot;c&quot;:0&#125;&#125; Object.create(proto[, propertiesObject]): 使用指定的原型对象和属性 创建新对象。指定新对象的__proto__ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748// 1. 实现类式继承Rectangle.prototype = Object.create(Shape.prototype);Rectangle.prototype.constructor = Rectangle;// 2. 创建一个原型为null的空对象var o = Object.create(null);var o1 = &#123;&#125;;// 3. 以字面量方式创建空对象就相当于o1 = Object.create(Object.prototype);// 4. 创建新对象，带着直到原型对象和属性o1 = Object.create(Object.prototype,&#123; foo:&#123; writable: true, cofigurable: true, value: &quot;jiang&quot; &#125;, // bar 成为所创建对象访问器属性，不可配置 bar: &#123; configurable: false, get: function() &#123; return 10 &#125;, set: function(value) &#123; console.log(&quot;Stting o.bar to&quot;,value); &#125; &#125;&#125;)// 5. 创建一个以另一个空对象为原型，其拥有属性p的对象，// 省略的属性特性默认为false，即属性p 是 不可写，不可枚举，不可配置的var o2 = Object.create(&#123;&#125;, &#123; p: &#123; value: 42 &#125; &#125;);console.log(Object.getOwnPropertyDescriptor(o2, &quot;p&quot;)); // Object &#123;value: 42, writable: false, enumerable: false, configurable: false&#125;var o3 = Object.create( &#123;&#125;, &#123; p: &#123; value: 42, writable: true, enumerable: true, configurable: true &#125; &#125; );// 对象字面量创建的对象，其属性 的属性特性默认为falsevar o4 = &#123; p: 23 &#125;;console.log(Object.getOwnPropertyDescriptor(o4, &quot;p&quot;)); // Object &#123;value: 23, writable: true, enumerable: true, configurable: true&#125; Object.defineProperty(obj,prop,descriptor):在一个对象上定义一个新属性，或者修改现有属性，并返回该对象. writable 属性：设置为false时，该属性“不可写的”，即不能被重新赋值。 enumerable 属性： 定义了对象属性是否可以在for...in循环和Object.keys()中被枚举 configurable属性： 表示对象的属性是否可以被删除，以及除value和writable特性外的其他特性是否可以被修改 Object.entries():返回一个给定对象自身可枚举属性的键值对数组（[key, value]）,同for..in循环遍历对象时返回的顺序一致，但for..in循环还会枚举原型链中的属性,可通 hasOwnProperty()方法过滤 Object.freeze(obj):冻结一个对象，被冻结的对象不能被修改，即不能添加新属性，不能删除已有属性，不能修改对象已有属性的可枚举性，可配置性，可写性，也不能修改属性的值。该对象的原型也不能被修改。 Object.seal(): 封闭一个对象。阻止添加新属性并将所有现有属性标记为不可配置。 Object.preventExtensions():让一个对象变的不可扩展，也就是不能再添加新的属性。 Object.getPrototypeOf(obj):返回指定对象的原型（内部[[Prototype]]属性的值，即 __proto__属性的值） Object.setPrototypeOf(obj,prototype):设置一个指定对象的原型（即，内部[[Prototype]]属性）到另一个对象或 null。因为更改对象的[[Prototype]]属性在浏览和 JS 引擎都是一个很慢的操作，应该避免设置一个对象的[[Prototype]],相反，应该使用Object.create()来创建带有想要的[[Prototype]]的新对象 Array 类型创建数组实例 Array 构造函数 数字字面量表示法 Array.from(arrayLike[, mapFn[, thisArg]]):从一个类似数组（拥有 length 属性和索引属性的对象）或可迭代对象（Map，Set）创建一个新的，浅拷贝的数组实例，可指定第二个参数，新数组中每个元素都会执行的回调函数。第三个参数，执行回调函数时this对象。 检测数组 对于一个网页或一个全局作用域而言，至少有以下几种方式去判断一个值是否是数组1234567891011var a = [];// 1. 基于 instanceofconsole.log(a instanceof Array);// 2. 基于constructorconsole.log(a.constructor === Array);// 3. 基于 isPrototypeOfconsole.log(Array.prototype.isPrototypeOf(a));// 4. getPrototypeOfconsole.log(Object.getPrototypeOf(a) === Array.prototype);// 5.基于Object.prototype.toStringconsole.log(Object.prototype.toString.call(a) === &quot;[object Array]&quot;); 但以上方法都不准确，我们可以手动的指定某个对象的[[Prototype]]/__proto__属性为Array.prototype,从而导致该对象继承 Array 对象。12var a = Object.create(Array.prototype);a.p = &#123; c: 33 &#125;; 如果网页中包含 对各框架(iframe)，实际上就存在不同的全局作用域，从而存在不同版本的 Array 构造函数。ECMAScript 5 新增了Array.isArray(obj)方法 原型js 中所有的数组方法均来自Array.prototype,和其他构造函数一样，可以通过扩展Array的prototype属性上的方法来给所有数组实例增加方法。 Array.prototype本身就是一个数组,且长度为 0 方法数组原型提供的方法主要分为三种：会改变自身值的，不会改变自身值的，遍历方法由于Array.prototype的莫些属性被设置为[[DontEnum]],不能用一般的方法遍历，可以通过getOwnPropertyNames()来获取： 1console.log(JSON.stringify(Object.getOwnPropertyNames(Array.prototype))); // [&quot;length&quot;,&quot;constructor&quot;,&quot;concat&quot;,&quot;pop&quot;,&quot;push&quot;,&quot;shift&quot;,&quot;unshift&quot;,&quot;slice&quot;,&quot;splice&quot;,&quot;includes&quot;,&quot;indexOf&quot;,&quot;keys&quot;,&quot;entries&quot;,&quot;forEach&quot;,&quot;filter&quot;,&quot;map&quot;,&quot;every&quot;,&quot;some&quot;,&quot;reduce&quot;,&quot;reduceRight&quot;,&quot;toString&quot;,&quot;toLocaleString&quot;,&quot;join&quot;,&quot;reverse&quot;,&quot;sort&quot;,&quot;lastIndexOf&quot;,&quot;copyWithin&quot;,&quot;find&quot;,&quot;findIndex&quot;,&quot;fill&quot;] 改变自身值的方法（9 个）改变自身值的方法一共有 9 个，分别是pop,push,shift,unshift,splice,reverse,sort,以及 ES6 新增的copyWithin,fill对于能改变自身值的方法，尽量避免再循环遍历中去改变原数组的项 pop,push pop()：删除一个数组的最后一个元素，并返回删除的元素 push(element1,...,elementN)：添加一个或多个元素到数组末尾，并返回数组新的长度。 同 pop 方法一样，push 方法也可应用到类数组对象上，如果 length 不能被转换成一个数值或者不存在，则插入的元素索引为 0，length 属性不存在时，江会创建它 1234var o = &#123;0:&quot;football&quot;, 1:&quot;basketball&quot;,length:1&#125;;var i = Array.prototype.push.call(o,&quot;golfball&quot;);console.log(o); // Object &#123;0: &quot;football&quot;, 1: &quot;golfball&quot;, length: 2&#125;console.log(i); // 2 实际上，push 方法是根据 length 属性来决定从哪开始插入给定的值。 1234var o = &#123;0:&quot;football&quot;, 1:&quot;basketball&quot;,length:1&#125;;var i = Array.prototype.push.call(o,&quot;golfball&quot;);console.log(o); // Object &#123;0: &quot;football&quot;, 1: &quot;golfball&quot;, length: 2&#125;console.log(i); // 2 结合push和apply方法，可实现数组的合并 12345var array = [&quot;football&quot;, &quot;basketball&quot;];var array2 = [&quot;volleyball&quot;, &quot;golfball&quot;];var i = Array.prototype.push.apply(array,array2);console.log(array); // [&quot;football&quot;, &quot;basketball&quot;, &quot;volleyball&quot;, &quot;golfball&quot;]console.log(i); // 4 shift, unshift shift()：从数组中删除第一个元素，并返回该元素的值。此方法也能通过call或apply方法作用于类数组对象上。 ubshift()：将一个或多个元素添加到数组的开头，并返回该数组的新长度。 splicesplice(start[,deleteCount[,item1[,item2[, ...]]]])方法通过删除或替换现有元素或者原地添加新元素来修改数组，并返回被删除元素组成的一个数组。start,指定修改的开始位置。超出数组的长度，则从数组末尾开始添加新元素。如果是负值，则位置等同于length+start.deleteCount,指定要删除的元素个数。若等于 0，则不删除，但要至少添加一个新元素。item1,item2,...要添加的新元素，从start位置开始。如果不指定，则splice()将只删除数组元素。返回值， 由原数组中被删除元素组成的数组。如果没有删除，则返回一个空数组。 reversereverse()方法颠倒数组中元素的位置，并返回对数组的引用。 sortsort([compareFn])方法对数组进行排序。compareFn参数是可选的，用来指定某种顺序进行排序的函数。如果省略，元素按照转换为的字符串的各个字符的 Unicode 位点进行排序。例如”Boy”将排在”apple”之前，数字 25 将排在 89 之前，因为转换为字符串”25”排在”89”之前。 12345678var array = [&quot;apple&quot;, &quot;Boy&quot;, &quot;Cat&quot;, &quot;dog&quot;];var array2 = array.sort();console.log(array); // [&quot;Boy&quot;, &quot;Cat&quot;, &quot;apple&quot;, &quot;dog&quot;]console.log(array2 == array); // truearray = [123, 1, 3, 25, 89];var array3 = array.sort();console.log(array3); // [1, 123, 25, 3, 89] 如果指定了comparefn排序函数，数组将按照调用该函数的返回值进行排序。 comparefn(a,b) &lt; 0,a 将排在 b 前面； comparefn(a,b) = 0,a 和 b 位置不变； comparefn(a,b) &gt; 0,a 将排在 b 的后面； copyWithincopyWithin(target[,start[,end]])方法复制数组的一部分到同一数组中的另一个位置，并返回它，不改变原数组的长度。target,start,end必须为整数，如果为负，则等同于length+target/start/end.如果start默认为 0；如果end默认为arr.length 12345console.log([1, 2, 3, 4, 5].copyWithin(-2)); // [1,2,3,1,2]console.log([1, 2, 3, 4, 5].copyWithin(0, 3)); // [4,5,3,4,5]console.log([1, 2, 3, 4, 5].copyWithin(0, 3, 4)); // [4,2,3,4,5]console.log([1, 2, 3, 4, 5].copyWithin(-2, -3, -1)); // [1,2,3,3,4]console.log([1, 2, 3, 4, 5].copyWithin(3, 2, 4)); // [1,2,3,3,4] fillfill(value[,start,[end]])方法用一个固定值填充一个数组从起始索引到终止索引的全部元素。start,起始索引，默认值为 0；end，终止索引，默认值为arr.length 123456console.log([1, 2, 3].fill(4)); // [4,4,4]console.log([1, 2, 3].fill(4, 1)); // [1,4,4]console.log([1, 2, 3].fill(4, 1, 2)); // [1,4,3]console.log([1, 2, 3].fill(4, 1, 1)); // [1,2,3]console.log([1, 2, 3].fill(4, -3, -2)); // [4,2,3]console.log(Array(3).fill(4)); //[4,4,4] 不改变自身的方法（8 个）不改变自身的方法，分别为concat,join,slice,indexOf,lastIndexOf,includes,toString,toLocaleString concatconcat()方法用于合并两个或多个数组，并返回一个新数组，不会更改现实有数组。 concat()方法不会改变this或任何作为参数提供的数组，而是返回一个浅拷贝。 若concat方法不传参，那么将基于原数组浅拷贝生成 一个新数组。 如果参数是对象引用，concat将对象引用复制到新数组。原数组和新数组都引用相同的对象。 joinjoin([separator])方法将一个数组或类数组对象的所有元素使用指定的分隔符连接成一个字符串并返回。如果一个元素为null或undefined，它会被转换为空字符串。 12const elements = [&#x27;Fire&#x27;, &#x27;Air&#x27;, ,null,&#x27;Water&#x27;];console.log(elements.join()); // &quot;Fire,Air,,,Water&quot; sliceslice([begin[,end]]),将数组中一部分元素浅拷贝至新的数组对象，并返回这个新数组对象。 123456var array = [&#123; color: &quot;yellow&quot; &#125;, 2, 3];var array2 = array.slice(0, 1);console.log(array2); // [&#123;color:&quot;yellow&quot;&#125;]array[0][&quot;color&quot;] = &quot;blue&quot;;console.log(array2); // [&#123;color:&quot;bule&quot;&#125;]console.log(array[0]); // &#123;color: &quot;blue&quot;&#125; indexOf,lastIndexOfindexOf(searchElement[,fromIndex]),lastIndexOf(searchElement[,fromIndex]),这两个方法都接受 2 个参数，要查找的元素，查找起点位置的索引。其中indexOf方法从数组的开头向后查找，lastIndexOf方法从数组的末尾向前查找。这两个方法都返回被查找元素在数组中的位置索引，如果不存在则返回-1. includesinclues(valueToFind[,fromIndex])方法用来判断一个数组是否包含一个指定的值。返回一个布尔值。如果传入了fromIndex，表示从fromIndex索引处开始查找。 toString，toLocaleStringtoString方法返回数组的字符串形式，该字符串由数组中的每个元素的toString()返回值经调用join()方法连接组成。 toLocaleString方法，类似toString,有数组中的每个元素的toLocaleString()返回值经调用join方法连接组成。 Object： Object.prototype.toLocaleString() Number: Number.prototype.toLocaleString() Date: Date.prototype.toLocaleString() 123var array = [&#123; name: &quot;zz&quot; &#125;, 123, &quot;abc&quot;, new Date()];var str = array.toLocaleString();console.log(str); // [object Object],123,abc,2020-3-31 07:34:50 遍历方法（12 个）分别为forEach,map,filter,every,some,reduce,reduceRight,以及 ES6 新增的entries,find,findIndex,keys,values forEachforEach(callback(curretValue[,index [, array]])[,thisArg]),按升序为数组中含有效值的每一项执行一次callback函数。 已经删除或者未初始化的元素将被跳过 如果thisArg参数有值，则每次调用callback函数时，this都会指向thisArg参数。 forEach遍历的范围在第一次调用callback函数前就会确定。所以调用 forEach 后添加到数组中的项不会被 callback 访问到。 如果数组莫一元素在迭代时被删除，这导致所有剩下的项上移一个位置。则之后的元素将被跳过。 mapmap(callback(curretValue[,index [, array]])[,thisArg])，创建一个新数组，其结果时该数组中的每个元素都调用callback函数后返回的结果 map会生成一个新数组，如果你不打算使用返回的新数组却使用map是违背设计初衷的，应该是用forEach或for-of替代。 map不修改调用它的原数组本身，但可以在 callback 执行时改变原数组 map方法处理数组元素的 范围在callback方法第一次调用之前就已经确定了。所以调用map方法之后追加的数组元素不会被callback访问。 如果存在的数组元素改变了，那么传给callback的值时map访问该元素时 的值。在map函数调用后但在访问元素之前，元素被删除的话，则无法访问到。 1234567var xs = [&quot;10&quot;, &quot;10&quot;, &quot;10&quot;];xs = xs.map(parseInt);console.log(xs); // [10,NaN, 2]// 1. parseInt(&quot;10&quot;, 0); 10// 2. parseInt(&quot;10&quot;, 1); NaN// 3. parseInt(&quot;10&quot;, 2); 2 filterfilter(callback(element[, index[, array]])[, thisArg])，使用传入的函数测试所以元素，并返回所有通过测试的元素组成的新数组。可理解为一个过滤器，过滤掉不符合条件的元素。 被删除或者从未被赋值的元素不会被遍历到。 filter遍历的元素在第一次调用callback之前就已经确定了，所有在调用filter之后添加到数组中的元素不会被filter遍历到。 如果已经存在的元素被改变了，则它们传入callback的值，是filter遍历到它们那一刻的值。 everyevery方法测试一个数组内所有元素是否都能通过指定函数的测试，返回一个布尔值。 被删除的元素或从来未被赋值的元素将不会被访问到 very 遍历的元素范围在第一次调用 callback 之前就已确定了。在调用 every 之后添加到数组中的元素不会被 callback 访问到 如果数组中存在的元素被更改，则他们传入 callback 的值是 every 访问到他们那一刻的值 somesome方法测试数组中是否至少有 1 个元素通过指定函数的测试，返回一个布尔值。只要有一个函数返回值为 true，则该方法返回 true，若全部返回 false，则该方法返回 false。 reduce, reduceRightreduce(callback(accumulator, currentValue[, index[, array]]) [, initialValue]),对数组中的每个元素执行指定的reducer函数，最终返回函数累计处理的结果。是从左向右遍历。reduceRight则相反，是从右向左遍历。 accumulator: 累计器累计回调的返回值。是上一次调用回调时返回的累计值 currentValue:数组中正在处理的元素 index:数组中正在处理当前元素的索引。如果提供了initialValue,则起始索引为 0，否则从 1 起始。 initialValue: 作为第一次调用callback函数的第一个参数的值（即 accumoulator,累计器的初始值）。如果没有提供，则将使用数组的第一个元素 回调函数第一次执行时，accumulator 和 currentValue 的取值有两种情况： 如果调用 reduce()时提供了 initialValue，accumulator 取值为 initialValue，currentValue 取数组中的第一个值； 如果没有提供 initialValue，那么 accumulator 取数组中的第一个值，currentValue 取数组中的第二个值。 find, findIndexfind(callback[, thisArg]),返回数组中满足提供的测试函数的第一个元素的值。否则返回undefinedfindIndex(callback[, thisArg])，返回数组中满足提供的测试函数的第一个元素的索引。否则返回-1 entriesentries()返回一个新的 数组迭代器对象（Array Iterator） 对象，该对象包含数组中每个索引的键/值对。 返回的数组迭代器对象，它的原型上有next方法，可用于遍历迭代器取的原数组的[key,value]. 123456789101112131415161718192021var arr = [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;];var iterator = arr.entries();console.log(iterator.next());/*&#123;value: Array(2), done: false&#125; done:false value:(2) [0, &quot;a&quot;] __proto__: Object*/console.log(iterator.next());/*&#123;value: Array(2), done: false&#125; done:false value:(2) [1, &quot;b&quot;] __proto__: Object*/console.log(iterator.next());/*&#123;value: Array(2), done: false&#125; done:false value:(2) [2, &quot;c&quot;] __proto__: Object*/ 使用for..of循环，遍历迭代器对象 12345678910var arr = [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;];var iterator = arr.entries();for (let [k, v] of iterator) &#123; console.log(`$&#123;k&#125;: $&#123;v&#125;`);&#125;/* 0: a 1: b 2: c*/ keys,values keys(),返回一个包含数组中每个索引键 的数组迭代对象。 values()，返回一个包含数组每个索引的值的数组迭代对象。 数组迭代器中存储的是原数组的地址，而不是数组元素值。如果数组中的元素改变，那么迭代器的值也会改变12345678const arr1 = [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;];const iterator = arr1.values();console.log(iterator); // Array Iterator &#123; &#125;console.log(iterator.next().value); // &quot;a&quot;arr1[1] = &quot;n&quot;;arr1[2] = &quot;jiang&quot;;console.log(iterator.next().value); // nconsole.log(iterator.next().value); // jiang Symbol.iterator (@@iterator)arr[Symbol.iterator](),返回数组的iterator方法，默认情况下，与values()返回值相同。即arr[Symbol.iterator]等同于values()函数。 12345var array = [&quot;abc&quot;, &quot;xyz&quot;];var iterator = array[Symbol.iterator]();console.log(iterator.next().value); // abcconsole.log(iterator.next().value); // xyz 也可以使用 for…of 循环进行 迭代 123456var array = [&quot;abc&quot;, &quot;xyz&quot;];var iterator = array[Symbol.iterator]();for(let value of iterator) &#123; console.log(value);&#125; RegExp 类型语法 字面量 /pattern/flags 构造函数 new RegExp(pattern [,flags]) flags,标志可以具有以下值的任意组合： g,全局匹配 i,忽略大小写 m,多行 u，将模式视为 Unicode 序列点的序列 以下表达式创建相同是正则表达： 123/ab+c/i;new RegExp(&quot;ab+c&quot;,&quot;i&quot;);new RegExp(/ab+c/,&quot;i&quot;); RegExp 实例属性RegExp 的每个实例都具有以下属性： global: 布尔值，表示是否设置了 g 标志 ignoreCase: 布尔值， 是否设置了 i 标志 multiline: 布尔值，是否设置了 m 标志 lastIndex: 整数，表示开始搜素下一个匹配的字符位置，从 0 算起 source: 正则表达式的字符串表示 RegExp 实例方法exec()该方法是专门为捕获组而设计的。在一个指定字符串中执行一个搜素匹配，返回包含第一个匹配项信息的数组，在没有匹配的情况下返回 null。 如果匹配成功，exec()返回一个数组，第 0 项，表示匹配的全部字符串，其他项表示括号中的分组捕获。2 个额外属性，index,表示匹配项在字符串中的位置；input，表示应用正则表达式的字符串。同时更新正则表达式对象的lastIndex属性，表示下一次匹配开始的位置。 如果匹配失败，exec()返回null,并将lastIndex重置为 0. 因为 RegExp 对象是有状态的，它们会更新lastIndex 属性，即使再次查找的字符串不是原来的字符串时，lastIndex也不会被重置，依旧从记录的lastIndex位置开始查找exec()可用来对单个字符串中的多次匹配结果进行逐条的遍历，相比之下，String.prototype.match()只返回匹配到的结果。如果只是为了判断是否匹配，可 使用RegExp.test(),返回布尔值或String.search()，返回索引，或者 -1。 test()regexObj.test(str)方法执行一个检索，用来查看正则表达式与指定的字符串是否匹配，返回一个布尔值。当 设置全局标志时，test()的执行会更新正则表达式lastIndex属性，连续执行test()，后续的执行将从lastIndex处开始匹配字符串。 123var regex = /foo/g;console.log(regex.test(&quot;foo&quot;)); // trueconsole.log(regex.test(&quot;foo123&quot;)); // false 正则表达式中特殊字符的含义 字符类别（Character Classes） .,匹配 任意单个字符。在字符集中，(.)就是匹配一个字面点. \\d,匹配任意阿拉伯数字，等价于[0-9] \\D,匹配任意一个不是阿拉伯数字的字符。等价于[^0-9] \\w,匹配任意字母、数字字符，还包括下划线。等价于[A-Za-z0-9_] \\W，匹配任意不是字母、数字、下划线字符的字符。等价于[^A-Za-z0-9_] \\s,匹配一个空白符，包括空格、制表符、换页符，换行符和其他 Unicode 空格。等价于[ \\f\\n\\r\\t\\v​\\u00a0\\u1680​\\u180e\\u2000​\\u2001\\u2002​\\u2003\\u2004​ \\u2005\\u2006​\\u2007\\u2008​\\u2009\\u200a​\\u2028\\u2029​​\\u202f\\u205f​ \\u3000] \\S,匹配一个非空白符。例如/\\S\\w*/匹配“foo bar”中的“foo” \\t, 匹配一个水平制表符(tab) \\r, 匹配一个回车符（carriage return） \\n，匹配一个换行符（linefeed） \\xhh,匹配编码为hh（2 个十六进制）的字符 \\uhhhh,匹配 Unicode 值为hhhh（4 个十六进制）的字符 字符集合 (Character Sets) [xyz],一个字符结合，匹配集合中的任意一个字符。 [^xyz],一个反义字符组，它匹配任何不在括号内的字符。可使用连字符-，[^abcd]等价于[^a-d] 边界 (Boundaries) ^,匹配输入开始，如果多行标记(multiline)设置为 true，该字符也会匹配一个断行符后的开始处。/^A/，匹配一个在开始处的 A $,匹配输入结尾。/t$/匹配eat中的“t”， 但不匹配eater中的“t” \\b，匹配一个单词边界。 \\B, 匹配一个分单词边界。 分组 (Grouping) (x),匹配x并且捕获匹配项。例如/(foo)/匹配且捕获”foo bar”中的”foo”.被匹配的子字符串可以在结果数组中的元素[1], ..., [n]中找到 \\n，指向正则表达式中第 n 个括号中匹配的子字符串。例如/apple(,)\\sorange\\1/匹配”apple, orange, cherry, peach”中的”apple, orange,” 数量词 (Quantifiers) x*，匹配前面的模式x 0 次或多次 x+, 匹配前面的模式x 1 次或多次 等价于&#123;1,&#125; x*?,x+?,同上面的*，+一样匹配前面的模式x，但是最小可能匹配。例如/a+/匹配”caaaaaaaandy”所有的“a”;/a+?/匹配“caaaaaaaandy”中第一个”a” x?,匹配前面的模式x, 0 次或 1 次 x|y，匹配x或y x&#123;n&#125;，前面模式x连续出现 n 次时匹配 x&#123;n,&#125;，前面模式x连续出现至少 n 次时匹配 x&#123;n,m&#125;, 前面模式x连续出现至少 n 次，至多 m 次时匹配 断言 (Assertions)， 以下断言只匹配x,y 不参与匹配 x(?=y)，仅匹配被 y 跟随的 x。例如/Jack(?=Sprat)/，如果”Jack”后面跟着”Sprat”,则匹配 x(?!y),仅匹配不被 y 跟着的 x。例如/\\d+(?!\\.)/，只匹配不被.跟着的数字。/\\d+(?!\\.)/.exec(&quot;3.141&quot;)，匹配“141” (?&lt;=y)x，x 只有在 y 后面才匹配。/(?&lt;=\\$)\\d+)/.exec(&quot;on the $100 bill, not @132&quot;)，匹配$符号后面的数字,“100” (?&lt;!y)x,x 只有不在 y 后面才匹配。/(?&lt;!\\$)\\d+/.exec(&#39;it’s is worth about €90&#39;),匹配不在$符号后面的数字，“90” Function 类型函数实际上对象，每个函数都是 Function 类型的实例。函数名是一个指向函数对象的指针。 函数声明和函数表达式 解析器会率先读取函数声明，并使其在执行任何代码之前可用；即函数声明提升的过程，读取并将函数声明添加到执行环境 函数表达式，则必须等到解析器执行到它所在的代码行，才会真正被解析执行。 arguments和this arguments传递给函数的参数的类数组对象，且只能在函数内使用 函数中this指向 普通函数 this 指向 window 定时器方法中的 this 指向 window 构造函数中的 this 指向 实例对象 对象方法中的 this 指向 实例对象 原型对象上中 this 指向 实例对象 箭头函数不会创建自己的 this，它只会从自己的作用域链的上一层继承 this 函数属性和方法函数包含 2 个属性：length和prototype length,表示函数希望接受的命名参数的个数 prototype属性保存了所有实例方法，它是不可枚举的。 apply(),call(),bind() apply()和call()，在调用一个存在的函数时，你可以为其指定一个 this 对象。区别就是 call()方法接受的是参数列表，而 apply()方法接受的是一个参数数组。 bind(),创建一个新的绑定函数（BF bound function），其 this 值是bind()的第一个参数，其余参数作为新函数的参数，供调用时使用。 基本包装类型为了便于操作基本类型值，ECMAScript 提供了 3 个特殊的引用类型：Boolean，Number，String.实际上，每当读取一个基本类型值时，后台就会创建一个对应的基本包装类型的对象，从而让我们能够调用一些方法来操作这些数据。 例如： 12var s1 = &quot;some text&quot;;var s2 = s1.substring(2); 当第二行代码访问 s1 时，后台会自动完成以下处理： 创建 String 类型的一个实例 在实例上调用指定的方法 销毁这个实例 构造函数与转型函数 使用new调用基本包装类型的构造函数，得到的是对应类型的实例，是对象 （typeof 返回 “object”） 直接调用同名的转型函数，得到的是一个基本类型 （typeof返回对应 基本类型 “number” ,”boolean”,”string” ） 12345678var value = &quot;25&quot;;var number = Number(value); // 转型函数console.log(number); // 25console.log(typeof number); // &quot;number&quot;var obj = new Number(value); // 构造函数console.log(obj); // Number &#123;[[PrimitiveValue]]: 25&#125;console.log(typeof obj); // &quot;object&quot; Boolean 类型Boolean 类型是与布尔值对应的引用类型。Boolean 类型的实例重写了valueOf(),返回基本类型值true或false；重写了toString()，返回&quot;true&quot;或&quot;false&quot;. typeof操作符，对基本类型返回&quot;boolean&quot;,对 Boolean 对象返回&quot;object&quot; instanceof操作符，测试 Boolean 对象返回true,测试基本类型的布尔值则 返回false 123456ar falseObj = new Boolean(false);var falseValue = false;console.log(typeof falseObj); // &quot;object&quot;console.log(typeof falseValue); // &quot;boolean&quot;console.log(falseObj instanceof Boolean); // trueconsole.log(falseValue instanceof Boolean); // false Number 类型静态属性 Number.EPSILON: 两个可表示数之间的最小间隔(2.220446049250313e-16) Number.MAX_SAFE_INTEGER: 最大的安全整数（2^53 - 1） Number.MAX_VALUE: 最大正数(1.7976931348623157e+308) Number.MIN_SAFE_INTEGER: 最小的安全整数 -Number.MAX_SAFE_INTEGER Number.MIN_VALUE: 最小正数，即最接近 0 的正数。 Number.NaN: “非数字”值 Number.NEGATIVE_INFINITY: 负无穷(-Infinity) Number.POSITIVE_INFINITY: 正无穷（Infinity） 静态方法 Number.isNaN(): 判断给定的值是否为 NaN Number.isFinite(): 判断给定的值类型及本身是否是有穷数。和全局的isFinite()函数相比，该方法不会强制将一个非数值的参数转换成数值12console.log(isFinite(&quot;123&quot;)); // trueconsole.log(Number.isFinite(&quot;123&quot;)); // false Number.isInteger(): 判断给定的值类型是”number”,且是整数 Number.isSafeInteger(): 判断给定的值是否为安全整数(-(2^53-1)~2^53-1) Number.parseFloat(): 把一个字符串解析成浮点数,与全局的 parseFloat() 函数相同 Number.parseInt(string, radix): 依据指定基数radix（2-36 之间的整数），把字符串解析成整数。 将数值格式化字符串方法 toFixed(digits): 使用定点表示法来格式化一个数值。即四舍五入为指定小数位数。参数digits指定小数点后数值的个数，介于 0-20 之间，必要时用 0 来填充小数部分。 toExponential(fractionDigits): 以指数表示法返回该数值字符串表示形式。参数fractionDigits用来指定小数点后有几位数，字介于 0-20 之间（多余时，四舍五入处理），默认情况下用尽可能多的位数来显示数字。 toPrecision(precision): 以指定的精度返回该数值对象的字符串表示.参数precision用来指定有效数个数，介于 1-100 之间（多余时，四舍五入） String 类型字符方法访问字符串中特定字符的方法 charAt(index):从一个字符串中返回指定的字符 charCodeAt(index): 返回 0-65535 之间的整数，表示给定索引出的 UTF-16 代码单元。 codePointAt(pos): 返回在字符串中的给定索引的 Unicode 编码点值 字符串操作方法 concat(string2,string3[,...,stribngN]): 将一个或多个字符串与原字符串连接合并，形成一个新字符串并返回。建议使用赋值操作符+,+= 代替 concat 方法 slice(beginIndex [, endIndex]):截取某个字符串的一部分，并返回一个新的字符串，且不会改动原字符串。 substring(indexStart [, indexEnd]): 返回一个字符串在开始索引到结束索引之间的一个子集。 如果indexStart等于indexEnd，返回一个空字符串 如果省略indexEnd,则默认提取字符到字符串末尾 如果任一参数小于 0 或者 为 NaN，则被当作 0 如果indexStart大于indexEnd，则两参数调换。 字符串修剪方法 trim()： 从一个字符串的两端删除空白字符。 trimStart() / trimeLeft(): 从字符串开头删除空白字符 trimEnd() / trimRight(): 从字符串末尾删除空白字符 字符串位置方法 indexOf(searchValue[,fromIndex]):指定值第一次出现的索引，从 fromIndex 处进行搜索。如果未找到该值，则返回 -1。如果fromIndex的值小于 0，从 0 查找。 lastIndexOf():指定值最后一次出现的索引，从fromIndex 处从后向前搜索。如果没找到，则返回-1 。 字符串模式匹配方法 match(regexp): 返回字符串匹配正则表达式的结果 (Array) 如果使用g标志，则返回匹配的所有结果，但不返回捕获组 如果未使用g标志，则仅返回第一个完整匹配及其相关的捕获组(Array) 12345var str = &quot;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz&quot;;var regexp = /[A-C]/g;var matches_array = str.match(regexp);console.log(matches_array); // [&quot;A&quot;,&quot;B&quot;,&quot;C] matchAll(regexp)：返回一个包含所有匹配正则表达式的结果及分组捕获组的迭代器。 12345678 var regexp = /t(e)(st(\\d?))/g;var str = &quot;test1test2&quot;;var matches_array = str.match(regexp);console.log(matches_array); // [&quot;test1&quot;, &quot;test2&quot;]var array = [...str.matchAll(regexp)];console.log(array);console.log(array[0]); // [&quot;test1&quot;, &quot;e&quot;, &quot;st1&quot;, &quot;1&quot;, index: 0, input: &quot;test1test2&quot;, groups: undefined]console.log(array[1]); // [&quot;test2&quot;, &quot;e&quot;, &quot;st2&quot;, &quot;2&quot;, index: 5, input: &quot;test1test2&quot;, groups: undefined] search(regexp): 返回字符中第一次匹配项的索引；否则，返回-1 字符串 判断方法 startsWith(searchString [, position]):判断当前字符串是否以另给定的子字符串开头，返回一个布尔值。 endsWith(searchString [, length]):判断当前字符串是否以另给定的子字符串结尾，返回一个布尔值。1234var str = &quot;To be, or not to be, that is the question.&quot;;console.log(str.endsWith(&quot;question.&quot;)); // trueconsole.log(str.endsWith(&quot;to be&quot;)); // falseconsole.log(str.endsWith(&quot;to be&quot;, 19)); // true includes(searchString [, position]): 判断一个字符串是否包含在另一个字符串中，返回一个布尔值 大小写转化方法 toUpperCase(): 字符串转换为大写形式 toLowerCase():字符串转换为小写形式 其他方法 fromCharCode(num1,...,numN):返回由指定的 UTF-16 代码单元序列创建的字符串 fromCodePoint(num1,...,numN): 返回由指定的代码点序列创建的字符串 padStart(targetLength [, padString]): 用指定字符串（默认为””）从当前字符串的开头开始填充，直到填充后长度达到指定长度，并返回填充后的字符串。 padEnd(targetLength [, padString]): 用指定字符串(默认为””)从当前字符串的末尾开始填充，直到填充后长度达到指定长度，并返回填充后的字符串。 1234567891011console.log(&quot;abc&quot;.padStart(10)); // &quot; abc&quot;console.log(&quot;abc&quot;.padStart(10, &quot;foo&quot;)); // &quot;foofoofabc&quot;console.log(&quot;abc&quot;.padStart(6, &quot;123465&quot;)); // &quot;123abc&quot;console.log(&quot;abc&quot;.padStart(8, &quot;0&quot;)); // &quot;00000abc&quot;console.log(&quot;abc&quot;.padStart(1)); // &quot;abc&quot;console.log(&quot;abc&quot;.padEnd(10));(&quot;abc &quot;);console.log(&quot;abc&quot;.padEnd(8, &quot;12345678&quot;)); // &quot;abc12345&quot;console.log(&quot;abc&quot;.padEnd(10, &quot;123&quot;)); // &quot;abc1231231&quot;console.log(&quot;abc&quot;.padEnd(2)); // &quot;abc&quot; split(separator [, limit]): 使用指定的分隔符字符串将一个字符串分割成子字符串数组。如果分隔符为空字符串，则将 str 原字符串中每个字符的数组形式返回。 1234// 限制返回值中分隔元素的数量var myString = &quot;Hello World. How are you doing?&quot;;var splits = myString.split(&quot; &quot;, 5);console.log(splits); // [&quot;Hello&quot;, &quot;World.&quot;, &quot;How&quot;, &quot;are&quot;, &quot;you&quot;] replace(regexp|substr, newSubStr| function): 返回一个由替换值(replacement)替换一些或所有匹配的模式(pattern)后的新字符串. regexp: 一个 RegExp 对象或其字面量，该正则所匹配 的内容被第二个参数的返回值替换掉 substr: 被newSubStr替换 的字符串。且仅被第一项替换掉 newSubStr： 用于替换第一个参数匹配到的结果 function: 用来创建新子字符串的函数，其返回值替换第一个参数匹配到的结果。 函数参数如下： match，匹配的子串 p1,p2,..., 假设第一个参数是RegExp对象，则代表第 n 个括号匹配的字符串。 offset, 匹配到的子字符串在原字符串中的偏移量。 string， 被匹配的原字符串。 12345678910function swapper(match, p1, p2, offset, string) &#123; console.log(arguments); // [&quot;John Smith&quot;, &quot;John&quot;, &quot;Smith&quot;, 0, &quot;John Smith&quot;] return `$&#123;p2&#125; &lt;==&gt; $&#123;p1&#125;`;&#125;var regexp = /(\\w+)\\s(\\w+)/;var str = &quot;John Smith&quot;;console.log(str.replace(regexp, &quot;$2 $1&quot;)); // Smith Johnvar newStr = str.replace(regexp, swapper);console.log(newStr); // Smith &lt;==&gt; John 内置对象内置对象是由 ECMAScript 实现提供的，不依赖于宿主环境的对象，这些对象在程序执行前就已经存在了。开发人员也不必显式的实例化内置对象，因为它们已经实例化了。常见的内置对象如Object,Array,String,Math等。 Global 对象该对象是不存在的，但在某种意义上它作为一个”兜底对象”,实际上，所有的全局变量和函数都是 Global 对象的属性。 URL 编码方法 encodeURI()主要用于对整个 URI 进行编码，但它不会对本身属于 URI 的特殊字符（例如冒号，正斜杠，问号，井号）进行编码。 decodeURI()进行解码 encodeURIComponent()只要用于对 URI 中的某一段（查询字符串参数）进行编码，它会对所有的任何非标准字符进行编码。decodeURIComponent()进行解码。 1234var uri = &quot;https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/encodeURI&quot;;console.log(encodeURI(uri)); // https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/encodeURIconsole.log(encodeURIComponent(uri)); // https%3A%2F%2Fdeveloper.mozilla.org%2Fzh-CN%2Fdocs%2FWeb%2FJavaScript%2FReference%2FGlobal_Objects%2FencodeURI Math 对象Math 是一个内置对象，拥有一些数学常数属性和数学函数方法。Math 不是一个函数对象，它不是一个构造器。Math 所有的属性和方法都是静态的。 舍入方法 Math.ceil(): 向上舍入 Math.floor(): 向下舍入 Math.round(): 四舍五入 随机数 Math.random(): 返回大于 0 小于 1 的一个随机数;以下是一个随机产生 n-m 之间的整数值,包含 n,m 123456789function randomRange(lowerValue, upperValue) &#123;let choices = upperValue - lowerValue + 1; return Math.floor(Math.random() * choices + lowerValue);&#125;var arr = [];for (let i = 0; i &lt; 15; i++) &#123; arr.push(randomRange(5, 10));&#125;console.log(arr.join());","categories":[{"name":"技术总结","slug":"技术总结","permalink":"https://better-jiang.github.io/categories/%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%93/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://better-jiang.github.io/tags/javascript/"}]},{"title":"JS知识点梳理(2)-变量、作用域、垃圾收集","slug":"JS知识点梳理-2-变量、作用域、垃圾收集","date":"2020-03-30T00:37:51.000Z","updated":"2023-02-03T12:14:22.419Z","comments":true,"path":"2020/03/30/JS知识点梳理-2-变量、作用域、垃圾收集/","link":"","permalink":"https://better-jiang.github.io/2020/03/30/JS%E7%9F%A5%E8%AF%86%E7%82%B9%E6%A2%B3%E7%90%86-2-%E5%8F%98%E9%87%8F%E3%80%81%E4%BD%9C%E7%94%A8%E5%9F%9F%E3%80%81%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86/","excerpt":"","text":"基本类型、引用类型 基本类数据类型：Undefined, Null, Boolean,Number, String。存储在栈中的简单数据段，按值访问的，可以操作保存在变量中的实际的值。 引用类型的值是保存在堆中对象，JS 不允许直接访问内存中的位置，即不能直接操作对象的内存空间。在操作对象时，实际上是在操作对象的引用而不是实际的对象 当复制引用类型时，创建的副本实际上是一个指针，指向内存在堆中的一个对象。2 个变量实际上引用同一个对象。 传递参数 ECMAScript 中所有函数的参数都是按值传递。即把函数外部的值复制给函数内部的参数。 在向参数传递引用类型的值时，会把此值在内存中的地址复制给一个局部变量，因此该局部变量的变化会反映到函数的外部。（并不能称之为“按引用传递”，因为函数接收的参数不是直接的对象别名，而是该引用地址的拷贝） 按值传递：将值的拷贝传递进去，形参的改变不会影响实参； 按引用传递：把地址（指向堆中的对象）传递进去，操作形参会影响实参 按共享传递：把地址的拷贝传递进去，实参和形参中的地址同时指向对象，形参对对象的属性操作会在实参反映出，但对形参重新赋值，不会影响到实参。 执行环境、作用域 执行环境（execution context）/环境：定义了变量或函数有权访问的其他数据，决定了它们各自的行为。每个执行环境都有一个与之关联的变量对象（variable object），保存了环境定义的所有变量和函数。可以理解为，执行环境始终时 this 关键字的值，它拥有当前所执行代码的对象的引用 执行环境中的所有代码执行完毕后，该环境被销毁，保存在其中的所有变量和函数定义也随之销毁。 每个函数都有自己的执行环境，当执行流进入一个函数时，函数的环境就会被推入一个执行环境栈中，在函数执行完后，栈就其环境弹出，把控制权返回给之前的执行环境。 当代码在一个环境中执行时，回创建变量对象的一个作用域链（scope chain）。其用途，是保证对执行环境有权访问的所有变量和函数的有序访问 作用域链的前端，始终都是当前执行的代码所在环境的变量对象。如果这个环境是函数，则将其活动对象（activation object）作为变量对象。作用域链中的下一个变量对象来自包含环境，而再下一个变量对象来自下一个包含环境，这样，一直延续到全局执行环境。全局执行环境 的变量对象始终都是作用域链中的最后一个对象。 活动对象可理解为被激活的变量对象。即每进入一个函数执行环境，该执行环境中的变量对象就被激活 执行环境分为：执行、创建 2 个阶段 创建阶段（当函数被调用，但未执行任何其内部代码之前） 解析器首先创建一个变量对象，由定义在执行环境中的变量、函数、参数做成。 初始化 作用域链 确定 this 的 值 执行阶段 初始化变量的值和函数的引用，解析并执行代码 作用域链（scope chain）：当代码在一个环境中执行时，会创建变量对象的一个作用域链 执行环境栈 浏览器中的 JS 解析器是单线程，因此同一时间只能发生一件事情，其他事件会被放如一个叫做执行栈的内存队列中。 当浏览器首次载入 JS 代码，默认进入全局执行环境，如果调用了一个函数，程序进入被调入的函数，并 创建一个新的执行环境并将其雅茹执行栈顶部。 浏览器总会首先执行位于执行栈顶部的执行环境，运行结束后从栈顶弹出，把控制权返回给之前执行环境，依此类推，栈中的执行环境会被依次执行并弹出，直到返回至全局环境。 作用域 作用域就是变量于函数可访问范围。即控制着变量和函数的可见性和生命周期。 全局作用域：在代码中任何对方都能访问到的变量或函数拥有全局作用域 局部作用域/函数作用域：只在固定代码片段内可访问到，而在其外部是无法访问的。 作用域链作用域链的本质是一个指向变量对象的指针列表，它只引用但不实际包含变量对象 作用域链的一个作用就是完成标识符解析，其是沿着作用域链一级一级的搜素标识符的过程。搜素过程始终从作用域链的前端开始，然后逐级向后回溯，直到找到标识符为止。 当某个函数被调用时，就回创建一个执行环境以及相应的作用域链，并把作用域链赋值给一个特殊的内部属性**[[Scopes]]**,然后用 this，arguments 和其他命名参数的值来初始化函数的活动对象，当前执行环境的变量对象始终在作用域链的第 0 位。 123456789function outer() &#123; var scope = &quot;outer&quot;; function inner() &#123; return scope; &#125; return inner;&#125;var fn = outer();fn(); 在 outer()函数内部返回了 inner()函数，所以在调用 outer()函数时，inner()函数的作用域链就已经被初始化了，即复制父函数（outer()）的作用域链，再在最前端插入自己的活动对象，如下图：当 outer()函数执行结束，执行环境被销毁，但是其关联的活动对象并没有随之销毁，而是一直存在于内存中，因为该活动对象被其内部函数的作用域链所引用。向上面这种内部函数的作用域链任然保持着对父函数活动对象的引用，就是闭包(closure) 垃圾收集垃圾收集机制：找出那些不在继续使用的变量，然后释放器占用的内存。按固定的时间间隔周期性的执行该操作。 标记清除垃圾收集器咋运行时给内存中所有的变量都加上要清除的标记，然后，去掉环境中的变量以及被环境中的变量所引用的变量的标记，剩下还有标记的变量将被视为要删除的变量，原因是环境中的变量已经无法访问到这些变量了。最后，垃圾收集器销毁那些带标记的变量。 引用计数跟踪每 一个值被引用的次数，但声明一个变量并将一个引用类型值赋给该变量时，则这个值的引用次数加 1，如果同一个值又被赋值给另一个变量 ，则该值的引用加 1.相反，如果包含对该 值引用的变量又取得了另一个值，则该值的 引用次数减 1.当 该值的引用次数变成 0 时，则说明没法访问该值了，从而可以收回其所占用的空间。 严重问题：循环引用","categories":[{"name":"技术总结","slug":"技术总结","permalink":"https://better-jiang.github.io/categories/%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%93/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://better-jiang.github.io/tags/javascript/"}]},{"title":"JS知识点梳理(1)-基本概念","slug":"JS知识点梳理-1-基本概念","date":"2020-03-22T20:04:00.000Z","updated":"2023-02-03T12:14:22.419Z","comments":true,"path":"2020/03/23/JS知识点梳理-1-基本概念/","link":"","permalink":"https://better-jiang.github.io/2020/03/23/JS%E7%9F%A5%E8%AF%86%E7%82%B9%E6%A2%B3%E7%90%86-1-%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/","excerpt":"","text":"语法区分大小写ECMAScript 中的一切（变量、函数名、操作符）都区分大小写 标识符标识符，指变量、函数、属性名，或函数的参数。它是按照以下规则组合起来的一个或多个字符： 第一个字符必须是一个字母、下划线(_)或者一个美元符号($) 其他字符可以是字母、下划线、美元符号、数字。 按照惯例，ECMAScript 标识符采用驼峰大小写格式，这是为了与 ECMAScript 内置的函数和对象命名格式保持一致 严格模式严格模式(strict mode)是为 JS 定义了一种不同的解析和执行模式，且对正常的 JS 语义做了些更改，消除 JS 语法中一些不合理，不严谨之处，减少一些怪异行为。 严格模式通过抛出错误来消除一些原有静默错误 严格模式修复了一些导致 JS 引擎难以执行优化的缺陷，提高了运行效率 严格模式禁用了在 ECMAScript 的未来版本中可能会定义的一些语法 如何开启严格模式 将&quot;use strict&quot;;语句放在 JS 文件的开头，为整个 JS 文件开启严格模式 将&quot;use strict&quot;;语句放在函数体所有语句之前，为函数开启严格模式 严格模式中的变化将过失错误转成异常JS 起初被设计为能使新人开发更易于上手，所以有时候会给本来错误操作赋予新的不报错的语义（non-error semantics）。 严格模式下,无法意外创建全局对象,抛出ReferenceError 12&quot;use strict&quot;;a = 12; // ReferenceError: a is not defined 严格模式下,引起静默失败（silently fail,即不报错也无任何效果）的赋值操作抛出异常。引起静默失败的赋值操作： 给不可写的属性赋值 给只读属性赋值 给不可扩展对象的新属性赋值 1234567891011121314151617181920&quot;use strict&quot;;// 给不可写的属性赋值var obj = &#123;&#125;;Object.defineProperty(obj, &quot;x&quot;, &#123; value: 20, writable: false &#125;);obj.x = 12; // TypeError: Cannot assign to read only property &#x27;x&#x27; of object &#x27;#&lt;Object&gt;&#x27;// 给只读属性赋值var obj1 = &#123;get x() &#123; return 12;&#125;,// set x(value) &#123;&#125;&#125;;obj1.x = 32; // TypeError: Cannot set property x of #&lt;Object&gt; which has only a getter// 给不可扩张对象的新属性赋值var obj2 = &#123;&#125;;Object.preventExtensions(obj2);obj2.x = 22; // TypeError: Cannot add property x, object is not extensible 严格模式下，试图删除不可删除的属性时会抛出异常 1234&quot;use strict&quot;;delete Object.prototype; // TypeError: Cannot delete property &#x27;prototype&#x27; of function Object() &#123; [native code] &#125;delete c; // SyntaxError: Delete of an unqualified identifier in strict mode. 严格模式下，函数中重命名参数被认为时语法错误 123456&quot;use strict&quot;;function sum(a,a,b) &#123; return a + a + b;&#125;// SyntaxError: Duplicate parameter name not allowed in this context 严格模式下，以0开头的八进制语法被认为语法错误,可以使用0o前缀来表示八进制数 123&quot;use strict&quot;;var b = 012; // SyntaxError: Octal literals are not allowed in strict mode.var c = 0o12; // 10 严格模式下，禁止给基本数据类型值设置属性，抛出 TypeError 1234&quot;use strict&quot;;false.age = 12; // TypeError: Cannot create property &#x27;age&#x27; on boolean &#x27;false&#x27;(15).age = 12; // TypeError: Cannot create property &#x27;age&#x27; on number &#x27;15&#x27;&quot;jiang&quot;.age = 12; // TypeError: Cannot create property &#x27;age&#x27; on string &#x27;jiang&#x27; 简化变量的使用严格模式简化了代码中变量名字映射到变量定义的方式。JS 有些情况使得代码中名字到变量定义的基本映射只有在运行时才产生，严格模式移除了大多数这种情况的发生，所以编译器可以更好的优化严格模式的代码。 严格模式下，禁用with.使用with所引起的问题是：块内的名称可以映射到with传进的对象属性，也可以映射到包含该块的作用域内变量，甚至全局变量。这一切都在运行时决定的，在代码运行之前无法得知。 12345678910&quot;use strict&quot;;var obj =&#123; x: 12;&#125;var x = 17;with(obj) &#123; // // SyntaxError: Strict mode code may not include a with statement cosole.log(x);&#125; // 如果没有开启严格模式，with中的x会执行全局的那个x,还是obj.x？ // 如果不运行代码，则无法得知，因此，这样的代码让引擎无法进行优化，速度也就会变慢 严格模式下，eval不在为上层范围引入新变量。 1234(function doSomething() &#123; eval(&#x27;var x = 20&#x27;); console.log(x); // ReferenceError: x is not defined&#125;)(); 让arguments变的简单 严格模式下，参数的值不会随arguments对象的改变而变化。arguments对象会保存函数被调用时的原始参数，arguments[i]的值不会随着与之相应的参数的值的改变而变化123456function f(a) &#123; &quot;use strict&quot;; a = 42; return [a, arguments[0]];&#125;console.log(f(17)); // [42, 17] 严格模式下，不再支持arguments.callee.正常模式下，arguments.callee指向当前正在执行的函数。1234(function abc() &#123; &quot;use strict&quot;;return arguments.callee; // TypeError: &#x27;caller&#x27;, &#x27;callee&#x27;, and &#x27;arguments&#x27; properties may not be accessed on strict mode functions or the arguments objects for calls to them&#125;)(); 更”安全的”JavaScript 对于一个严格模式下的函数，指定的this不再被强制转换为一个对象，this值始终是指定的值,无论指定的是什么值.在非严格模式 下，使用call,apply,bind方法时，用undefined或者null指定this,其this值将自动转换为全局对象window或者global 12345678910111213141516171819202122// 没有开启严格function func() &#123;return this;&#125;function func2() &#123; &quot;use strict&quot;; return this;&#125;// 未开启严格模式console.log(func.call()); // global &#123;...&#125;console.log(func.call(2)); // Number &#123;[[PrimitiveValue]]: 2&#125;console.log(func.call(undefined)); // global &#123;...&#125;console.log(func.apply(null)); // global &#123;...&#125;console.log(func.bind(true)()); // Boolean &#123;[[PrimitiveValue]]: true&#125;// 开启严格模式console.log(func2.call()); // undefinedconsole.log(func2.call(2)); // 2console.log(func2.call(undefined)); // undefinedconsole.log(func2.apply(null)); // nullconsole.log(func2.bind(true)()); // true 语句ECMAScript 中的语句是以一个分号结尾;如果省略分号，则由解析器确定语句的结尾，但建议在任何时候都不要省略分号。它可以避免很多错误，如不完整的输入，更放心的通过删除多余空格来压缩代码。另外，加上分号也会在某些情况下提高代码性能，省去了解析器推测应该在哪添加分号的时间。 关键字和保留字关键字用于表示控制语句的开始、结束，或者用于执行特定操作等。保留字表示将来有可能被用作关键字。二者都不能用作标识符。 变量 ECMAScript 的变量是松散类型的，即可以用来保存任何类型的数据。 每个变量仅仅是一个用于保存值的占位符而已。 省略var,let,const操作符，定义的变量，会成为全局变量。 数据类型5 种基本数据类型： Undefined,Null,Boolean,Number,String1 种复杂数据类型： Object ,包含Data、function、Array等。ES6 新增数据类型： Symbol,表示独一无二的值,可以用作对象的属性名，保证不会与其他属性名产生冲突。 typeof操作符typeof操作符的操作数可以是变量，也可以是数值字面量，是一种用来检测给定变量的数据类型的手段,可能返回以下字符串： “undefined” —- 未定义 “boolean” —- 布尔值 “string” —- 字符串 “number” —- 数值 “object” —- 对象或null（因为null被认为是一个空的对象引用，所以返回”object”） “function” —- 函数 Undefined 类型 Undefined 类型只有一个值，即undefined，表示未经初始化的变量的值。 另外需要注意，包含undefined值的变量和尚未声明的变量是不一样的，即使使用typeof操作符检测都会返回undefined。但传递给函数尚未声明的变量会报错。 Null 类型 Null 类型也只有一个特殊的值null. null值表示一个空对象指针，这也是typeof null返回”object”的原因 只要意在保存对象的变量还没有真正的保存对接，就应该明确的将该变量初始化为null null和undefined之间的相等操作符(==)返回true Boolean 类型 对于任何数据类型的值 调用Boolean()函数，总会返回一个 Boolean 值。具体转化规则 数据类型 转化为 true 的值 转化为 false 的值 Boolean true false String 任何非空字符串 “”(空字符串) Number 任何非零数值 0 和 NaN Object 任何对象 null Undefined 无 undefined Number 类型各进制表示1234var decimalNum = 10;var octalNum = 0o12;var hexNum = 0xA;var binaryNum = 0b1010; 数值范围 ECMAScript 表示的数值范围，Number.MIN_VALUE,Number.MAX_VALUE之间.超出范围的值被自动转化为-Infinity和Infinity isFinite()函数，判断参数是否位于最小和最大的数值之间。 数值转换3 个函数可以将非数值转换为数值：Number(),parseInt(),parseFloat() Number()函数可应用与任何数据类型，具体转换规则： Boolean 值，true，flase 分别转换为 1，0 数字值，返回值不变 null 值，返回 0 字符串，则按以下规则： 如果字符串只包含数字，则将其转换为十进制数值，忽略前导的零 如果字符串包含有效的浮点格式，则转换为对应的浮点数值 如果字符串包含有效的十六进制格式，”0xf”,转换为相同大小的十进制数值 如果字符串是空的，转换为 0 如果字符串中包含除上述格式之外的字符，则转换为 NaN 对象，调用对象的 valueOf(),然后按照以上规则转换返回的值，如果结果为 NaN,则调用对象的toString()方法，然后按照以上规则转换返回的字符串值。 parseInt()函数，仅用于将字符串转换为数值。 忽略字符串前面的空格，直到找到第一个非空格字符。如果第一个字符不是数字字符或负号，则返回 NaN。 如果第一个字符是数字字符，会继续解析第二个字符，直到解析完所有后续字符或遇到一个非数字字符 为了消除 ECMAScript 3 和 5 之间，解析八进制字面量的字符串时存在的分歧，可以为paeseInt()提供第二个参数：转换时使用的基数（多少进制）：例如：parseInt(&quot;0fAF&quot;,16) parseFloat()函数只解析十进制值，因此没有第二参数指定基数。 NaN NaN，即非数值（Not a Number),表示一个本来要返回数值的操作数，但未返回数值的情况。 任何涉及NaN的操作都会返回NaN NaN与任何值都不相等，包含NaN本身 isNaN()函数，确定参数是否”不是数值” String 类型 String 类型用于表示 0 或多个 16位Unicode字符组成的字符序列，即字符串 String 数据类型也包含一些特殊的字符字面量，也叫转义序列。 \\xnn,以十六进制代码 nn 表示一个字符，（n 为 0-F）。\\x41表示”A” \\unnnn,以十六进制代码 nnnn 表示一个 Unicode 字符，（n 为 0-F），\\u0061表表示”a” 字符串特点ECMAScript 中字符串是不可变的，字符串一旦创建，它们的值就不能改变。要改变莫格变量保存的字符串，首先要先销毁原来的字符串，然后再用另一个包含新字符串填充该变量。 字符串转换 数值，布尔值，对象，字符串值都有toString()方法，null和undefined值没有该方法 如果不知道要转换的值是不是null或undefined情况下，可以使用转型函数String(),按以下规则： 如果值有toString()方法，则调用该方法并返回结果 如果值是 null,则返回”null” 如果值是 undefined,则返回”undefined” Object 类型Object 类型是所有它的实例的基础，JS 中的所有对象都来自Object。即所有的对象从Object.prototype继承属性和方法。 constructor:保存着用于创建当前对象的函数(构造函数)的引用 hasOwnProperty(propertyName):返回一个布尔值，表示某个对象实例是否包含指定的属性，而且此属性非原型链继承的。其参数的属性名必须以字符串形式指定。 isPrototypeOf(object):返回一个布尔值，表示指定的对象是否在当前对象的原型链中 propertyIsEnumerable(propertyName):返回一个布尔值，表示指定的属性是否可枚举，能否使用for-in语句枚举，但是通过原型链继承的属性除外。 toString():返回对象的字符串表达 toLocaleString():根据执行环境的地区，返回对应的字符串表示 valueOf():返回指定对象的原始值。每个内置的核心对象都会覆盖此方法以返回适当的值。例如Date对象的valueOf()方法，返回自 1970/01/01 开始计的毫秒数 函数 可以向 ECMAScript 函数传递任意数量的参数，在函数体内可以通过arguments对象来访问。 arguments对象是一个类数组对象，它不是 Array 的实例 由于不存在函数签名的特性，ECMAScript 函数不能重载。","categories":[{"name":"技术总结","slug":"技术总结","permalink":"https://better-jiang.github.io/categories/%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%93/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://better-jiang.github.io/tags/javascript/"}]},{"title":"疫情中，内看自己","slug":"疫情中，内看自己","date":"2020-03-22T12:34:47.000Z","updated":"2023-02-03T12:14:22.419Z","comments":true,"path":"2020/03/22/疫情中，内看自己/","link":"","permalink":"https://better-jiang.github.io/2020/03/22/%E7%96%AB%E6%83%85%E4%B8%AD%EF%BC%8C%E5%86%85%E7%9C%8B%E8%87%AA%E5%B7%B1/","excerpt":"","text":"年前离职，就早些时间回了新疆过年。本计划年后回深圳，找个靠谱的公司，深耕工作，积累技能，能长久稳定，三五年内不会再换工作。同时希望自己能因此有番作为，毕竟早已成年，建功立业之心急切，真没有时间再拖延了。无奈，疫情爆发，一切也毫不意外的，没有挣扎与还手的被打乱。但从在此时此刻回看，其实计划泡汤与疫情爆发之间并无决定性的关联，是强行甩锅给疫情。虽然能以此为由，隐瞒安抚了父母，从而安心的在家长待近一个月，还要演戏给父母、姐姐看，我特想回去上班。为了更真实，我将实情告诉了弟弟，并请他配合。其实，早在回新疆过年之前，家里就有很多烦心之事，需要在过年时一家人共同探讨解决，相互劝说。弟弟对父母花心思和脸面给其找的党建工作不满，要离职，再年前就闹到不可开交之地步，父母不得已找我帮忙劝说，最总弟弟同意先工作到过年，等过年时，一家人能好好聊聊后，再做打算。姐姐，则因前份工作以及自身对生活偏享乐之态，早已离职。本计划能好好休息调整一段时间后，找到自己兴趣所向，做到轻松工作，快乐生活。可事以愿违，在没工作的日子里，她受困于手机，沉迷于抖音等短视频，难以自拔。所以，我没有将以离职之事告知父母，不想再给他们添烦加忧。另外，打小父母对我期望就比姐弟高，到进入大学前也从未令他们失望过。大学之后，我报喜不报优，也就慢慢稳住了对我的这份高期望。正值新春佳节，要当面感受到因此带给父母的担心与失落，我不敢。不告知父母，不敢面对父母，其实不也就是代表不敢面对自己吗？对自己能迅速找到心仪工作没有自信吗？对自己之前未能努力学习，提升能力而内疚吗？对之前浪费的时间的自己的可惜与憎恨吗？对此我选择了逃避，拿疫情为借口拖延。疫情时期，公司招聘更少，拿 offer 难上加难，只好等疫情结束后再准备、投简历。当然这无非是自欺欺人罢了，理由站不住脚。因为，早在疫情之前，我就有准备，并制定复习，面试准备计划。如按原先计划，疫情是大利好，我会有更多的时间复习，准备了。可事情发展远偏计划，在新疆家里浪费近一个月，回深圳后，又报复性的放纵 10 日之久。现在，深感时间的紧迫与不足，太多的事未做，太多的知识点需要梳理。 自律与时间价值深究缘由，为何自己一步一步的走至绝境般地步？是不自律，从小如此。无数次深受因无法自律而懊恼悔恨后，为何依旧不能自律呢？归根结底，就是没有真正意识到时间的价值。很多时候我们认为时间是廉价的，自己还年轻，有的是时间，“明日复明日，明日何其多”。甚至，有时还要绞尽脑汁的，用无意义的哈哈哈，更无聊的娱乐活动，去打发无聊时光。如今被提及的“碎片化时间”，被定义是无意义的，正可以拿来娱乐放松。“碎片时间”真的是无意义的吗？“我生待明日，万事成蹉跎”，“世人皆被明日累，明日无穷老降至”，终将有一天，我也将不可避免的老去，而且肯定会老去。那时，行动迟缓，无法自理，即将离世，才会去渴求时间，意识到时间的价值吗？人世间所有的美好与成就，都是需要大量时间的积累和沉淀，没有足够的时间投入，就一定不会有了不起的成果与和产出。而这大量的时间，就是在平时的每一天里积累而来，是上厕所玩手机的时间，是玩英雄联盟的时间，是找乐，哈哈哈，呵呵的的时间，是看无聊，土味视频的时间，是夜里不认真睡觉，胡思乱想的时间，是空想，幻想的时间。日积月累后，会产生巨大的复利效应，也就拉开； 于他人之间的差距。逃避现实，短视的选择沉溺于当下各种娱乐活动中，最多仅能得到片刻解脱。欢愉过后还得重新面对生活中处处难题，种种烦恼。久而久之，梦想不断破灭，而愿望越来越小，终日被生活中各种无力感和对自己的失望 打击 生活中真正的暴击？它不是当场被打脸的挫败，是那漫长时间和一无起色的现实，在一分一秒的凌迟着你的自尊，它一点一点的磨灭你的热情，一次一次的浇灭你的希望，让你的付出和汗水想挥打在空气中的拳头，虽满带着不甘愤怒，却得不到任何的反馈与收获。同时，生活又很难出现奇迹，从而更加残忍。时间是无情的，当我们在欺骗自己，欺骗他人，欺骗生活时，其实我们一定会心虚和不安的，可生活不会突然跳出一个魔鬼或天使，来教训你，惩罚你，扇你几耳光，呵斥你几句。而我又是多么希望，能如读书时一样，每当不认真学习时，分数就会下降，每当做错事，老师会批评，父母会打骂，自己能看到，意识到，感受到错了，并必须改正。但现在一切都由自己了，时间它什么也不说，什么也不做，任由你尽情表演，任由你发展，任由你自我欺骗，然后也任由你在漫长的生命里充满绝望和痛苦中挣扎。那些在往日里耍了的滑，偷了的懒，终将被时间慢慢的清算，一个都不会放过 改变几乎所有的动物都可以遵守本能和欲望的渡过每一天，饿了就吃，渴了就喝，累了就睡，怕了就跑，但人就是不能如此的生活，这是人最可悲的地方，活着就要忍受一种“存在”的痛苦；这也是人最幸福的地方，能按自我意愿，把时间和精力投入到成就自我目标之上。所有，想改变，要眼睛向内看，始终关注自己的成长，开始种自家的地。另外，要意识到大脑仅仅是一个人的器官而已，它累了，抵触运转，想去放松寻乐，其实大可不必在意，直接拒绝即可。大脑必须无条件的服从于更高层次的那个自我，服务于成就自我，实现自我价值的目标。放弃自己时间的人，注定要活在漫长的痛苦之中，而这种痛苦远比“改变自己”的痛苦更强烈，更持久。 其实难走的路，反而并不拥挤","categories":[{"name":"随笔感悟","slug":"随笔感悟","permalink":"https://better-jiang.github.io/categories/%E9%9A%8F%E7%AC%94%E6%84%9F%E6%82%9F/"}],"tags":[]},{"title":"CSS知识点梳理(18)-动画（Animation）","slug":"CSS知识点梳理-18-动画（Animation）","date":"2020-03-21T08:41:40.000Z","updated":"2023-02-03T12:14:22.419Z","comments":true,"path":"2020/03/21/CSS知识点梳理-18-动画（Animation）/","link":"","permalink":"https://better-jiang.github.io/2020/03/21/CSS%E7%9F%A5%E8%AF%86%E7%82%B9%E6%A2%B3%E7%90%86-18-%E5%8A%A8%E7%94%BB%EF%BC%88Animation%EF%BC%89/","excerpt":"","text":"使用 CSS 过渡，属性值的开始和结束状态由现有的属性值控制，且几乎无法控制事物随时间的变化。CSS 动画类似于 CSS 过渡，其 CSS 属性的值也会随时间变化，但对于这些变化如何发生提供了更多的控制。具体地说，CSS 关键帧（keyframe）动画让我们决定一个动画是否和如何重复，并给我们颗粒级的控制什么发生在整个动画，甚至更多。CSS 过渡触发隐式属性值改变，动画则在应用keyframe属性时显性执行。 定义关键帧要使一个元素产生动画效果，我们需要设置关键帧动画的名称。为此，我们需要一个命名的关键帧动画.第一步，使用@keyframes 规则定义可重用的 CSS 关键帧动画命名。然后，将动画附加 到元素或伪元素上。一个@keyframes 规则包含动画标识符或名称，以及一个或多个关键帧块(keyframe blocks)。每一个关键帧块包含一个或多个关键帧选择器，并带有属性-值对的声明块。整个@keyframes 规则指定了动画的单次完整的重复行为。动画可重复 0 次或多次，这取决于animation-iteration-count属性值。关键帧选择器（keyframe selectors）是整个动画持续时间的时间百分比位置。它们声明为百分比，或者使用关键字from和to 12345678910111213141516171819202122232425262728293031323334/* 一般结构 */@keyframes animation_identifier &#123; keyframe_selector &#123; property: value; &#125; keyframe_selector &#123; property: value; &#125;&#125;/* 实例 */@keyframes fadeout &#123; from &#123; opacity: 1; &#125; to &#123; opacity: 0; &#125;&#125;@keyframes color-pop &#123; 0% &#123; color: black; background-color: white; &#125; 33%, 75% &#123; color: gray; background-color: yellow; &#125; 100% &#123; color: white; background-color: orange; &#125;&#125; 可动画属性并非所有的属性都是可动画化的。在动画关键帧中，如果给出一个不能被动画化的属性，它就会并忽略。只要在至少一个块中包含一个动画属性，并且该属性的值与非动画属性值不同，且在这两个值之间有一个可计算的中点，那么该属性就会被动画化。 动画元素一旦创建了关键帧动画，就可以将该动画应用于元素或伪元素。CSS 提供了许多动画属性来将关键帧动画附加到元素并控制其进度。至少，你需要包含动画名称和动画的持续时间（如果希望动画实际上是可见的，否则，动画将在 0 秒时间内发生）有 2 种方法可以将动画属性附加到元素上：1.分别的包含所有的动画属性；2.使用animation的速记属性在一行内声明所有的动画属性。 animation-name animation-name属性以逗号分隔的 关键帧动画名称列表作为其值。 如果其中一个关键帧名称不存在，该动画系列不会失败。仅仅是失败的动画被忽略，有效的动画被应用。 如果对一个元素应用多个动画，并且这些动画具有重复的属性，则后面的动画将覆盖前面动画中的属性值。 animation-duration animation-duration属性定义了一个动画循环需要多长时间，以秒或毫秒为单位。 如果不声明animation-duration,动画任然会以 0s 持续时间运行。并且anmationstart和animationend事件会被触发。 此属性不允许使用负的时间值。 如果有一个以上的动画，则使用逗号分隔1234div &#123; animation-name: change_bgcolor, round, W; animation-duration: 200ms, 100ms, 0.5s;&#125; 在指定持续时间时，必须包含秒(s)或毫秒(ms)单位。 如果在以逗号分隔的时间列表中提供了无效的值，如animation-duration: 200ms, 0, 0.5s，则整个声明将失败。 在逗号分隔的属性值列表中，使用比animation-name值更少的animation-duration值，不会失败，相反，这些值将作为一个组进行重复123animation-name: a, b, c, d, e;animation-duration:200ms, 5s;/*相当于 animation-duration: 200ms, 5s, 200ms, 5s, 200ms; */ 如果animation-duration的值的数量超出，超出的值会被忽略。 如果animation-name其中的一个值不存在，则该值会被忽略，那么animation-duration相对应的值也会被忽略，但整个动画系列和动画持续时间依然有效。 animation-iteration-count 默认值是1 如果animation-iteration-count的值不是整数，动画任然运行，但是会在重复时等比例的位置中断。例如，如果一个 8 秒的动画，其animation-iteration-count值为0.25，则动画将播放2s(0.25 * 8)的时间，在 2s 后结束。 负数是不允许的，如果指定的值无效，则会取默认值:1. 0值是有效值，动画任然运行，但次数为 0，类似于animation-duration: 0s。会触发animationstart和animationend事件。 使用逗号分隔的列表值，额外的值将被忽略，缺少的值会导致重复现有的值。 无效的值将使整个声明无效，导致每个动画仅播放一次。 animation-direction animation-direction属性定义了动画通过关键帧的进行方向，有 4 种可能的值： normal: 设置normal或省略（被默认设置为 normal）.动画的每一次重复都从 0%关键帧进行到 100%关键帧 reverse: 动画的每次重复按反向的关键帧的顺序，从 100%关键帧进行到 0%关键帧。反转动画方向，也反转了animation-timing-function alternate: 动画在第一次和之后的奇数次重复时，从 0%关键帧进行到 100%关键帧。在第二次和之后的偶数次重复时，从 100%关键帧进行到 0%关键帧 alternate-reverse: 同alternate值相似，但是它是反向的。以下是一个球弹跳(球是从 将它仍下去开始，而不是把它抛向空中开始)的动画例子1234567891011121314.ball &#123; animation-name: bouncing; animation-duration: 2500ms; animation-iteration-count: infinite; animation-direction: alternate-reverse;&#125;@keyframes bouncing &#123; from &#123; transform: translateY(500px); &#125; to &#123; transform: translateY(0); &#125;&#125; animation-delay 默认情况下，动画一应用到元素就开始重复动画，延迟 0 秒。 负值会导致动画立即开始，且在动画的中途开始。例如，如果一个动画animation-delay: -4s，animation-duration: 10s，动画会立即开始，在第一个动画的40%处开始，并将在6s后结束。 如果一个动画被设置重复 10 次，延迟为-600ms,单次动画持续时间为200ms，那么元素将在第 4 次重复时立即开始动画，且动画 1400ms。（200ms x 10 = 2000ms） 123456789.ball &#123; animation-name: bounce; animation-duration: 200ms; animation-delay: -600ms; animation-iteration-count: 10; animation-timing-function: ease-in; animation-direction: alternate;&#125; 以上动画，重复 7 次，3 因为负值的animation-delay，有 3 次没有发生。animationiteration事件触发了 6 次，最后一次重复同animationend事件相同。因为animationiteration和animationend事件不能同时触发，所以animationiteration事件不会触发 动画事件有三种不同类型的动画事件：animationstart,animationiteration,animationend。每个事件都有三个只读的属性：animationName,elapsedTime,pseudoElement.elapsedTime的值是animation-delay值的绝对值。 animationstart事件，在动画开始时触发，如果有动画延迟，则在延迟之后触发。如果延迟值为负值，则立即触发。 animationend事件在动画完成时触发。如果animation-iteration-count设置为infinite，并且animation-duration设置的时间大于 0，animationend事件就永远不会触发。如果animation-duration值为 0，即使animation-iteration-count值为infinite，那么animationstart和animationend几乎会同时触发。 animationiteration事件在动画重复之间触发，并且它与animationend不会同时触发。注意，当动画延迟为负值时，可能不会触发animationiteration事件。例如:123456.noAnimationIteration &#123; animation-name: change_color; animation-duration: 1s; animation-iteration-count: 4; animation-delay: -3s;&#125; animation-timing-functionanimation-timing-function属性描述了动画将如何在其持续时间或一个重复周期内进行。其值可以是step() 阶跃函数和贝塞尔曲线 step(),它不是线性渐变的，它是一种跳跃式的，主要用在sprite动画中。 第一个参数，必须正整数，表示动画过程被平均分成的步骤数 第二个参数，可选，接受start和end,默认end.指定在每个间隔的起点或终点发生阶跃变化。 animation-play-stateanimation-play-state属性定义动画是运行(runing)还是暂停(paused)。 如果在重复中停止，则动画过程中的属性将保持在重复中的值，当设置为runing或返回到默认运行时，从停止的地方重新启动。 animation-fill-modeanimation-fill-mode属性定义了动画时如何影响元素的，是在animationstart触发之前，animationend事件触发之后 设置元素的属性值。 none:默认值，即动画中的更改仅在动画执行期间，在不执行时没有效果。一旦动画完成，这些值都将恢复到动画之前的值。如果animation-delay值为正数，则动画不会立即影响元素的属性值，而是在过了延迟时间后，animationstart事件触发时。 backwards: 0%或from关键帧的属性值立即应用到元素，不需要等待动画延迟的时间 forwards: 动画执行完成后，元素依旧使用动画完成时的属性值。 both:集合了backwards和forwards. 如果animation-iteration-count是一个浮点数，不是一个整数。最后重复将不会在0%或100%关键帧上结束，动画将在中途结束执行。如果此时animation-fill-mode的值为both或forwards,则元素将维持animationend事件触发时的属性值。12345678910111213141516@keyframes move &#123; 0% &#123; transform: translateX(0); &#125; 100% &#123; transform: translateX(1000px); &#125;&#125;.moved &#123; transform: translateX(0); animation-name: move; animation-duration: 10s; animation-timing-function: linear; animation-iteration-count: 0.6; animation-fill-mode: forwards;&#125; 此动画重复 0.6 次，作为一个线性过渡的 10s 动画，它将在 60%处停止，即在进入动画 6s，元素被向右平移 600px 时。因为animation-fill-mode: forwards，所以该元素属性值保持不变,transform: translateX(600px) 综合范例1234Values: [ animation-name || animation-duration || animation-timing-function || animation-delay || animation-iteration-count || animation-direction || animation-fill-mode || animation-play-state ]Initial valueL &#x27;name&#x27; 0s ease 0s 1 normal none running","categories":[{"name":"技术总结","slug":"技术总结","permalink":"https://better-jiang.github.io/categories/%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%93/"}],"tags":[{"name":"css","slug":"css","permalink":"https://better-jiang.github.io/tags/css/"}]},{"title":"CSS知识点梳理(17)-过渡（Transition）","slug":"CSS知识点梳理-17-过渡（Transition）","date":"2020-01-06T02:46:11.000Z","updated":"2023-02-03T12:14:22.419Z","comments":true,"path":"2020/01/06/CSS知识点梳理-17-过渡（Transition）/","link":"","permalink":"https://better-jiang.github.io/2020/01/06/CSS%E7%9F%A5%E8%AF%86%E7%82%B9%E6%A2%B3%E7%90%86-17-%E8%BF%87%E6%B8%A1%EF%BC%88Transition%EF%BC%89/","excerpt":"","text":"通常，当一个 CSS 属性值改变时，改变是瞬间发生的。新的属性在重绘、或必要时回流+重绘受影响内容所需要的毫秒内（似乎时瞬间，渲染时间小于 16 毫秒）替换旧属性。CSS 中transition提供了一种方法来控制属性在一段时间内的改变，可以使属性值逐渐 变化。 过渡属性在 CSS 中，transition有四个属性：transition-property,transition-duration,transition-timing-function,transition-delay.元素上的transition与常规样式一起声明。每当目标属性更改时，如果在该属性上设置了transition，则浏览器使用transition使更改逐步进行。 transition-property transition-property指定要过渡的 CSS 属性名称。默认值all，即过渡所有可动画的属性。 all在transition-property值列表的第一项，其后再跟需要特殊过渡的属性列表。可有大部分属性相同过渡效果+少数属性特殊过渡效果的组合。 123456789101112div &#123; color: #f00; border: 1px solid #00ff00; border-radius: 0; transform: scale(1) rotate(0deg); opacity: 1; box-shadow: 3px 3px rgba(0, 0, 0, 0.1); width: 50px; padding: 100px; transition-property: all, border-radius, opacity; transition-duration: 1s, 2s, 3s;&#125; border-radius过渡持续时间 2s,opacity过渡持续时间 3s,其他 CSS 属性过渡持续时间 1s. transitionend事件，在每次过渡结束时触发。无论属性是单独声明，还是作为all声明的一部分，都会触发transitionend.简写属性中的每一个过渡属性都有自己的transitionend事件。例如border简写属性，会产生 8 个transitionend事件(border-width（4 个），border-color（4 个）,border-style不是可动画的属性，没有该事件)： border-left-width border-right-width border-top-width border-bottom-width border-top-color border-left-color border-right-color border-bottom-color transitionend事件，包含 3 个特殊的事件属性 propertyName,发生过渡的 CSS 属性名称 pseudoElement,发生过渡的伪元素（2 个分号） elapsedTime,运行过渡所需的时间，以秒为单位；transition-duration属性定义的时间。 transition-duration transiton-duration必须数正值，且带单位s,ms，默认值0s。负值无效，则整个属性值都无效。 transiton-duration使用逗号分隔的时间值同transition-property属性列出的 CSS 属性值声明相对应。 如果transition-duration数量大于transiton-property,则忽略多余transition-duration的值 如果transition-duration数量小于transiton-property,则重复transition-duration的值 12345div &#123; ... transition-property: color, border, border-radius, transform, opacity, box-shadow, width, padding; transiion-duration: 100ms, 200ms;&#125; 基数属性的过渡持续时间是 100ms,偶数属性的过渡持续时间是 200ms。 transition-timing-functiontransiton-timing-function可以控制过渡变化的速度。一种是平滑的曲线折线（cubic-bezier()），一种是跳跃的折线形式（steps(n, start)） cubic-bezier() 贝塞尔曲线绘制工具 Timeing function Description Cubic Bezier value cubic-bezier() 指定一个三次贝塞尔曲线 cubic-bezier (x1,y1,x2,y2) ease 开始缓慢，然后加速，然后缓慢 cubic-bezier(0.25,0.1,0.25,1) linear 整个过程以相同的速度运行 cubic-bezier(0,0,1,1) ease-in 开始缓慢，然后加速 cubic-bezier(0.42,0,1,1) ease-out 开始很快，然后慢下来 cubic-bezier(0,0,0.58,1) ease-in-out 开始和结束快一些，中间慢一些 cubic-bezier(0.42,0,0.58,1) Steps()steps(n, start/end),参数一，把过渡分成几段，即在时间上分成几段去显示执行。参数二，表示分成几段后，在start还是end去执行动画，默认值end. Timing funcion Definition step-start 在过渡过程中始终停留在最后 的关键帧，等于 steps(1, start) step-end 在过渡过程中始终停留在最初的关键帧， 等于 steps(1, end) steps(n, start) ,steps(n, end) 过渡分成 n 个阶段，是在每个阶段的 start 或 end 去执行动画 transition-delay transition-delay默认值为 0s。可以为负值。 同transition-duration和transition-timing-function一样，当逗号分隔的transition-delay值的数量超过 逗号分隔的transition-property值的数量时，额外的transition-delay值被忽略 。当transition-delay数量少于transition-property的值时，transition-delay值会重复。 当transition-delay的负值的绝对值小于transition-duration时，则会立即开始过渡；如果大于，CSS 属性值改变时立即的，就如同没有应用transition，也不会有transitionend事件触发。 1234567891011div &#123; transform: translateX(0); transition-property: transform; transition-duration: 200ms; transition-timing-function: linear; transition-delay: -150ms;&#125;div:hover &#123; transform: translateX(200px);&#125; 200ms 过渡，延时为-150ms,则过渡效果将在过渡过程的 3/4 处开始，并持续 50ms.即鼠标悬停时立即沿 x 轴移动到 150px，然后再 50ms 内从 150px 过渡到 200px。 当从悬停 状态回到原始状态时，**默认情况下，会应用相同的transition-delay**。即当鼠标移走时，它将跳至沿 x 轴 50px 位置，然后花费 50ms 返回到 x 轴的 0px 的初始位置。 transiton 简写 transition简写表示transiton:&lt;transition-property&gt; &lt;transition-duration&gt; &lt;transiton-timing-function&gt; &lt;transition-delay&gt;,默认值:transiton: all 0s ease 0s. 如果省略transition-property，则其值为all。如果只有一个&lt;time&gt;值 ，它代表transition-duration，那个transition-delay被省略，默认为 0s. 反向:过渡 由于过渡声明仅处于全局状态，所以鼠标悬停和鼠标离开都会使用相同的transition声明。我们可以在多个状态中覆写transition属性。 过渡分为 2 个阶段：forward前进，reverse反向阶段。若前进阶段进行一段时间后进入反向阶段，则反向阶段的初始值是前进阶段结束的瞬时值。 反向过渡中断了正在进行的过渡 当过渡在完成之前被中断，属性值将重置为开始过渡之前的值，并且属性将过渡回那些值CSS 规范提供了式恢复过渡更短的方案 可动画属性和值某些 CSS 属性是可以使用transition和animation来是他们的值在给定的时间内逐渐改变。随着 CSS 的发展，可动画属性的列表也有新的补充。 判断一个属性是否是可动画属性的关键，它计算值（computed value）是否可以内插一个值。Interpolation 插值是在已知数据点的值之间构造新的数据点。 降级：过渡是一种 增强由于过渡通常是渐进的增强，所以没有针对老式浏览器的polyfill。如果浏览器不支持过渡，当样式发生改变时，则立即从初始状态过渡到最终状态罢了。","categories":[{"name":"技术总结","slug":"技术总结","permalink":"https://better-jiang.github.io/categories/%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%93/"}],"tags":[{"name":"css","slug":"css","permalink":"https://better-jiang.github.io/tags/css/"}]},{"title":"CSS知识点梳理(16)-转换（Transform）","slug":"CSS知识点梳理-16-转换（Transform）","date":"2020-01-04T13:13:25.000Z","updated":"2023-02-03T12:14:22.418Z","comments":true,"path":"2020/01/04/CSS知识点梳理-16-转换（Transform）/","link":"","permalink":"https://better-jiang.github.io/2020/01/04/CSS%E7%9F%A5%E8%AF%86%E7%82%B9%E6%A2%B3%E7%90%86-16-%E8%BD%AC%E6%8D%A2%EF%BC%88Transform%EF%BC%89/","excerpt":"","text":"坐标系统 笛卡尔坐标系统（Cartesian coordinate systems） 该系统就是常见x/y/z坐标系统，x代表水平轴，y代表垂直轴,z代表深度轴。x正值向右，负值向左,y正值向下，负值向上,z正值离你更近，负值离你更远。 每个元素都携带它自己的参照系，也就是说，如果旋转一个元素，那么它的轴也会随之旋转，之后的变换都是对那些旋转的轴进行计算的 球面坐标系统 (spherical coordinate systems)球面坐标系统描述了三维空间中的角度。对于 2D 中变换，只需要考虑一个单独的 360° 极坐标系统，它位于 x,y 轴描述的平面上。 对于 2D 旋转，实际上描述了绕z轴的旋转(在 xy 平面上旋转)。正度数，顺时针旋转，负度数，逆时针旋转 绕 x轴的旋转使元素向你倾斜或远离你,绕y轴的旋转使元素从一边转向另一边。 转换 百分比值相对于boundiing box,在 CSS 中，它就是border box，忽略轮廓和边距。 所有转换后的元素有自己的堆栈上下文。元素在页面上占用的实际空间与转换之前相同 转换函数是一个接一个的处理的，所有其顺利不同，结果可能有所不同。 在一系列转换函数中，必须所有的函数是正确格式，如果其中一个函数无效，则整个transform的值都无效。 转换通常不是累加的，但是动画转换，无论是使用过渡（transition）还是实际的动画(animation)，是可以叠加的。 在没有显示的指定过渡或动画，可以通过伪类(例如:hover)来创建可叠加的转换。·123456img#one &#123; transform: translateX(100px) scale(1,2);&#125;img#one:hover&#123; transform: rotate(-45deg);&#125; 转换不能应用到原子内联级的框中，例如span,a，可以通过display:block;,display:inline-block来改变显示角色。 translate 函数 Function Permitted value translateX(), translateY() &#60;length&#62; &#124; &#60;percentage&#62; translate() [&#60;length&#62; &#124; &#60;percentage&#62;][,&#60;length&#62; &#124; &#60;percentage&#62;]? translateZ() &#60;length&#62; translate3d() [&#60;length&#62; &#124; &#60;percentage&#62;],[&#60;length&#62; &#124; &#60;percentage&#62;],[&#60;length&#62;] 百分比的值，其距离计算是相对于元素自身大小。 translate(x,y)如果y值省略，则它被设置为0，translate(2em)等价于translate(2em, 0) translateZ()的值，仅接受长度值，不允许使用百分比值。 translate3d()必须包含 3 个值，translate3d(1em, -50px)视为无效，不会被认为是translate3d(1em, -50px, 0) scale 函数 Function Permitted value scaleX(), scaleY(), scaleZ() &#60;number&#62; scale() &#60;number&#62;[,&#60;number&#62;]? scale3d() &#60;number&#62;,&#60;number&#62;,&#60;number&#62; scale函数只接受数值，不接受百分比的值。 scale(),如果只提供一个数字，它将被用作两个轴的缩放值。scale(2)等价于scale(2, 2). rotate 函数 Function Permitted value rotate(), rotateX(), rotateY(), rotateZ() &#60;angle&#62; rotate3d() &#60;number&#62;,&#60;number&#62;,&#60;number&#62;,&#60;angle&#62; rotate()是一个 2D 旋转，等价于rotateZ()，围绕 z 轴旋转。 rotate3d(x,y,z,angle)是围绕所声明的三维向量旋转。 x,y,z 表示向量 在 x,y,z 轴的分量，angle 表示 旋转量。 rotate3d(1,1,0,45deg)的结果不等于rotateX(45deg) rotateY(45deg) rotateZ(0deg) skew 函数 Functions Permitted value skewX(), skewY() &#60;angle&#62; skew() &#60;angle&#62;[, &#60;angle&#62;]? skew(a,b)同skewX(a) skewY(b)的行为不同，它是用矩阵运算[ax,ay]来指定 2D 倾斜的。 skew(x,y)如果忽略了 y 值，那么 它就是 0. perspective 函数perspective(&lt;length&gt;)，用于指定观察点到 元素的距离。 观察点距元素越近，元素的变形越大。 此属性在舞台元素上设置，对进行 3D 变换的子元素生效。如果子元素非 3D 变换元素，则没有任何效果。 透视效果，近大远小 观察点/视点的位置可以结合perspective-origin属性进行调整。 matrix 函数关于矩阵，比较复杂，且现阶段较少用到，故跳过该节。 更多转换属性原点改变 所有的转换默认使用元素中心作为转换远点。 transform-origin，使用 2 或者 3 个关键字定义转换原点。水平的，垂直的，可选择的 Z 轴长度。 百分比值是根据元素大小计算的。 改变原点对旋转的影响 改变原点对倾斜的影响 3D 样式 transform-style属性指定了嵌套元素如何在 3D 空间中呈现。flat默认值，表示所有子元素在 2D 平面呈现，preserve-3d表示所有子元素在 3D 空间中呈现。 transform-style属性需要设置在父元素中，它可以被其他属性覆盖，这是因为其他属性的一些值需要元素及其子元素在平面上才能正常工作。因此，为了避免这种覆盖行为，以下属性必须设置为以下值 overflow: visible filter: none clip: auto clip-path: none mask-image: none mask-border-source: none mix-blend-mode: normal flat变换的效果 12div#outer &#123;transform: perspective(750px) rotateY(60deg) rotateX(-20deg);&#125;div#inner &#123;transform: perspective(750px) translateZ(60px) rotateX(45deg);&#125; preserve-3d变换的效果 12div#outer &#123;transform: perspective(750px) rotateY(60deg) rotateX(-20deg); transform-style: preserve-3d;&#125;div#inner &#123;transform: perspective(750px) translateZ(60px) rotateX(45deg);&#125; 视角转换 perspective属性，应用于父元素，规定其所有子元素的透视深度(Z 平面距离用户之间的距离)；perspective()函数，只定义了给定该函数的元素的透视深度。 12345678910div &#123;transform-style: preserve-3d; border:1px solid gray; width: 660px&#125;img &#123;margin: 10px;&#125;#one &#123;perspective: none&#125;;#one img &#123;transform: perspective(800px) rotateX(-50grad);&#125;#two &#123;perspective: 800px;&#125;#two img &#123;transform: rotateX(-50grad);&#125;&lt;div&gt;&lt;img src=&quot;rsq.gif&quot;&gt;&lt;img src=&quot;rsq.gif&quot;&gt;&lt;img src=&quot;rsq.gif&quot;&gt;&lt;/div&gt;&lt;div id=&quot;one&quot;&gt;&lt;img src=&quot;rsq.gif&quot;&gt;&lt;img src=&quot;rsq.gif&quot;&gt;&lt;img src=&quot;rsq.gif&quot;&gt;&lt;/div&gt;&lt;div id=&quot;two&quot;&gt;&lt;img src=&quot;rsq.gif&quot;&gt;&lt;img src=&quot;rsq.gif&quot;&gt;&lt;img src=&quot;rsq.gif&quot;&gt;&lt;/div&gt; perspective-origin定义了观察者视角相对于元素的位置（视线灭点），默认是元素的中心位置。其值同transform-origin相似。例如perspective-origin: left top;，即其视线灭点在左上角 背面处理backface-visibility属性指定当元素背面朝向观察者时是否可见(hidden,visible)。 在 3D 空间，旋转时，默认值，背面是可见的。 例子，[悬浮翻面] 1234567891011section &#123;position: relative;&#125;img, div &#123;position: absolute; top: 0; left: 0;&#125;div &#123;transform: rotateY(180deg); backface-visibility: hidden;background: rgba(255,255,255,0.85);&#125;section:hover &#123;transform: rotateY(180deg); transform-style: preserve-3d;&#125;&lt;section&gt;&lt;img src=&quot;photo.jpg&quot; alt=&quot;&quot;&gt;&lt;div class=&quot;info&quot;&gt;(…info goes here…)&lt;/div&gt;&lt;/section&gt;","categories":[{"name":"技术总结","slug":"技术总结","permalink":"https://better-jiang.github.io/categories/%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%93/"}],"tags":[{"name":"css","slug":"css","permalink":"https://better-jiang.github.io/tags/css/"}]},{"title":"CSS知识点梳理(15)-列表和生成内容","slug":"CSS知识点梳理-15-列表和生成内容","date":"2020-01-04T13:10:40.000Z","updated":"2023-02-03T12:14:22.418Z","comments":true,"path":"2020/01/04/CSS知识点梳理-15-列表和生成内容/","link":"","permalink":"https://better-jiang.github.io/2020/01/04/CSS%E7%9F%A5%E8%AF%86%E7%82%B9%E6%A2%B3%E7%90%86-15-%E5%88%97%E8%A1%A8%E5%92%8C%E7%94%9F%E6%88%90%E5%86%85%E5%AE%B9/","excerpt":"","text":"列表列表类型图片 列表样式列表标志的位置列表样式(list-style)的简写列表布局生成内容插入生成的内容内容计数器计数模式的定义固定计数模式循环计数模式符号计数模式字母计数模式数值计数模式加法计数模式扩展计数模式","categories":[{"name":"技术总结","slug":"技术总结","permalink":"https://better-jiang.github.io/categories/%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%93/"}],"tags":[{"name":"css","slug":"css","permalink":"https://better-jiang.github.io/tags/css/"}]},{"title":"CSS知识点梳理(14)-表格布局","slug":"CSS知识点梳理-14-表格布局","date":"2020-01-04T13:08:39.000Z","updated":"2023-02-03T12:14:22.418Z","comments":true,"path":"2020/01/04/CSS知识点梳理-14-表格布局/","link":"","permalink":"https://better-jiang.github.io/2020/01/04/CSS%E7%9F%A5%E8%AF%86%E7%82%B9%E6%A2%B3%E7%90%86-14-%E8%A1%A8%E6%A0%BC%E5%B8%83%E5%B1%80/","excerpt":"","text":"表的格式布置表格表格相关的显示（display）值匿名的表对象表格的图层表格标题单元格边框分离的单元格边框折叠的单元格边框表格尺寸宽度高度对齐","categories":[{"name":"技术总结","slug":"技术总结","permalink":"https://better-jiang.github.io/categories/%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%93/"}],"tags":[{"name":"css","slug":"css","permalink":"https://better-jiang.github.io/tags/css/"}]},{"title":"CSS知识点梳理(13)-网格布局","slug":"CSS知识点梳理-13-网格布局","date":"2020-01-03T01:56:18.000Z","updated":"2023-02-03T12:14:22.418Z","comments":true,"path":"2020/01/03/CSS知识点梳理-13-网格布局/","link":"","permalink":"https://better-jiang.github.io/2020/01/03/CSS%E7%9F%A5%E8%AF%86%E7%82%B9%E6%A2%B3%E7%90%86-13-%E7%BD%91%E6%A0%BC%E5%B8%83%E5%B1%80/","excerpt":"","text":"创建网格容器 网格容器（grid container）是一个为其内容定义网格格式上下文（grid formatting context）的元素。 网格又 2 种,dispaly:grid;和dispaly:inline-grid;。wang’g 被浮动的元素不会侵入网格容器，即网格不会滑动至浮动元素下 网格容器的边距不会与其后代元素（第一个或最后一个子元素）的边距 折叠。 基本网格术语 网格容器（grid container）是一个建立网格格式上下文的盒子，并根据网格布局规则布局元素的区域。 网格项（grid item）是 在网格格式上下文中参与网格布局的内容。通常是网格容器的子元素，也可以是匿名的文本。 网格轨道（grid track）是两个相邻网格线之间的空间。换句话说，就是一个网格行(grid row)或网格列（grid column） 网格单元格（grid cell）是由四条网格线限定的空间，类似于表格单元格。网格单元格不能直接用 CSS 网格属性来控制。 网格区域（grid area）是由一个或多个网格单元格组成的一个矩形区域。网格区域可以通过 CSS 网格属性直接控制。 网格轨道，网格单元格，网格区域完全由网格线构成，它不必与网格项对应，不需要在每一个网格区域都填入一个网格项 网格线的布局网格线的控制，先从两个密切相关的属性开始grid-template-rows,grid-template-columns 网格线可以通过编号、命名或将它们混合在一起来引用。 固定宽度的网格轨道 12345678#grid &#123; display: grid; grid-template-columns: 200px 50% 100%;&#125;#grid &#123; display: grid; grid-template-columns: [start col-a] 200px [col-b] 50% [col-c] 100px [stop end last];&#125; 弹性网格轨道 fr单位，在一系列长度值周分配剩余空间，如果指定了多个部分，则剩余空间根据各自的系数按比例分配。例如grid-template-columns: 1fr 1fr 1fr,则网格容器的宽度 3 等分,每个列的宽度各占 1 份。 minmax(min,max)定义了一个长宽的闭区间，与网格布局一起使用。 每个参数，可以是&lt;length&gt;(非负长度)、&lt;percentage&gt;、&lt;flex&gt;、max-content（网格轨道长度自适应内容最大的那个单元格）、min-content（网格轨道长度自适应内容最小的那个单元格）、auto之一。 如果最大值小于最小值，则最大值被忽略，其被看成最小值 &lt;flex&gt;值最为最小值无效。单位为fr,指定网格轨道弹性布局的系数值，并按其系数值比例均匀分配剩余空间 auto作为最大值，等价于max-content，作为最小值，表示网格轨道中单元格最小长宽（min-width, min-height）的最大值。 fit-content(argument)类似于minmax(min-content, max-content)，只是参数的值设置了一个上限。等价于min(max-content, max(min-content, argument)) 12345#fit-content &#123; dislay: grid; grid-template-columns: fit-content(50ch) fit-content(50ch) fit-content(50ch); font-family: monospace;&#125; 第二列中图片宽 500px,比 50ch 更宽。max(min-content,50ch)的结果是min-content,500px，min(max-content,500px)结果是 500px。所有第二列500px 宽。 repeat(n,width1,width2, ... windthN )，重复网格线 1234#grid &#123; display: grid; grid-template-columns: repeat(4, 10px [col-start] 250px [col-end]) 10px;&#125; auto-fill,创建一个简单模式并重复，直到填满网格容器 1234#grid &#123; display: grid; grid-template-columns: repeat(3,20em) repeat(auto-fill,2em);&#125; 一个也可以编写grid-template-columns: repeat(auto-fill,2em) repeat(3,20em);,因为网格布局算法首先将空间分配给固定轨道，然后再用自动重复轨道填充剩余空间。 网格区域（grid-template-areas）1234567891011121314#grid &#123; display: grid; grid-template-areas: &quot;h h h h&quot; &quot;l c c r&quot; &quot;l f f f&quot;&#125;#grid &#123; display: grid; grid-template-areas: &quot;header header header header&quot; &quot;leftside content content rightside&quot; &quot;leftside footer footer footer&quot;&#125; grid-template-areas值中的每一个网格标识符对应于一个网格单元格，具有相同名称的单元格会合并到一个单独区域，**且该区域必须是矩形，如果是其他形状，则整个样式template无效，例如grid-template-areas: &quot;h h h h&quot; &quot;l c c r&quot; &quot;l l f f&quot;,l区域的形状不是矩形，像一个L 形**。 如果只希望定义一些网格单元格作为网格区域，而不标记其他单元格，则使用.字符来填充那些未命名的单元格。1234567#grid &#123; display: grid; grid-template-areas: &quot;header header header header&quot; &quot;left ... ... right&quot; &quot;footer footer footer footer&quot;&#125; 将元素附加到网格 使用列线、行线 grid-row-start,grid-row-end,grid-column-start,grid-column-end,即“把元素的边缘依附于网格线” 使用网格线编号12345678910111213141516171819202122.grid &#123; display: grid; width: 50em; grid-template-rows: repeat(5,5em); grid-template-columns: repeat(10,5em);&#125;.one &#123; grid-row-start:2; grid-row-end: 4; grid-column-start: 2; grid-column-end: 4;&#125;.two &#123; grid-row-start:1; grid-row-end: 3; grid-column-start: 5; grid-column-end: 10;&#125;.three &#123; grid-row-start:4; grid-column-start: 6;&#125; 使用span关键字，表示跨越多少网格轨道,例如上例123456789101112131415161718.one &#123; grid-row-start: 2; grid-row-end: span 2; grid-column-start: 2; grid-column-end: span 2;&#125;.two &#123; grid-row-start: 1; grid-row-end: span 2; grid-column-start: 5; grid-column-end: span 5;&#125;.three &#123; grid-row-start: 4; grid-row-end: span 1; grid-column-start: 6; grid-column-end: span; // span 后缺少数字，默认为 1&#125; 使用网格线名称123456789101112131415161718192021222324252627282930313233#grid &#123; display: grid; grid-template-areas: &quot;header header header header&quot; &quot;leftside content content rightside&quot; &quot;leftside footer footer footer&quot;&#125;#masthead &#123; grid-row-start: header; grid-column-start: header; grid-row-end: header;&#125;#sidebar &#123; grid-row-start: 2; grid-row-end: 4; grid-column-start: leftside / span 1;&#125;#main &#123; grid-row-start: content; grid-row-end: content; grid-column-start: content;&#125;#navbar &#123; grid-row-start: rightside; grid-row-end:3; grid-column-start: rightside;&#125;#footer &#123; grid-row-start: 3; grid-row-end: span 1; grid-column-start: footer; grid-column-end: footer;&#125; 在定义网格区域时，浏览器会根据单元格名称，会使用name-start或name-end给 其两边的网格线命名。所以grid-column-start: header;是等价于grid-column-start: header-start; grid-column，grid-column简写属性.grid-column: start / end是grid-column-start和grid-column-end的简写属性. 使用网格区域 grid-area,将元素分配到 先前定义的网格区域 123456789101112#grid &#123; display: grid; grid-template-areas: &quot;header header header header&quot; &quot;leftside content content rightside&quot; &quot;leftside footer footer footer&quot;&#125;#masthead &#123;grid-area: header;&#125;#sidebar &#123;grid-area: leftside;&#125;#main &#123;grid-area: content;&#125;#navbar &#123;grid-area: rightside;&#125;#footer &#123;grid-area: footer;&#125; grid-area属性是grid-row-start, grid-column-start, grid-row-end,grid-column-end的简写属性。例如： 123item8 &#123; grid-area: 1 / 2 / 5 / 6;&#125; item8开始于 row-line 1,column-line 2,结束于row-line 5,column-line 6 网格流如果没有显示的放置网格项，则自动将它们放置到网格中。在有效的网格流中,网格项被放置在第一个适合它的区域。最简单的情况就是按顺序填充一个网格轨道，一个网格项接着一个。如果有显示的和自动放置的网格项混合，后者必须围绕着前者工作。 grid-auto-flow定义了网格流模式，行优先 或 列优先 12345678910#grid &#123; display: grid; width: 45em; height: 8em; grid-auto-flow: row;&#125;#grid li &#123; grid-row: auto; grid-column: auto;&#125; 当网络流中的元素大小超出网格项。 123456789101112131415161718#grid &#123; display: grid; grid-template-rows: repeat(3, 50px); grid-template-columns: repeat(4, 50px); grid-auto-rows: 50px; grid-auto-columns: 50px;&#125;img &#123; grid-row: auto; grid-column: auto;&#125;img.wide &#123; grid-column: auto / span 2;&#125;img.tall &#123; grid-column: auto / span 2;&#125; 在网格流中，如果一个网格单元格的空间不足放置下一个网格项，则网格项会跨域多个网格单元格。 在行的网格流中，其工作方式是，从左到右遍历每一行，如果有单元格空中，就把网格项放在那里。所以，item 13 在 item 11 的右边 dense关键字会让网格流中网格项放置的更加紧密，grid-auto-flow: row dense;,grid-auto-flow: column dense 自动的网格线当一个网格项脱离边缘时，会根据需求添加行或列，以满足相关项的布局。一般情况下，自动添加的行或列的是需要的最小大小(即内容大小)。如果想对它们的大小施加更多控制,可以使用grid-auto-rows和grid-auto-columns。如下图左边设置了grid-auto-row大小，右边没有。 grid 属性简写该语法比较复杂，不建议使用。 123456789101112131415#grid &#123; grid: &quot;header header header header&quot; 3em &quot;. content sidebar .&quot; 1fr &quot;footer footer footer footer &quot; 5em / 2em 3fr minmax(10em, 1fr) 2dm;&#125;// 等价于#grid &#123; grid-template-areas: &quot;header header header header&quot; &quot;. content sidebar .&quot; &quot;footer footer footer footer&quot;; grid-template-rows: 3em 1fr 5em; grid-template-columns: 2em 4fr minmax(10em, 1fr) 2em;&#125; 网格项（网格轨道）之间间隔gutter就是两个网格轨道之间的空间，就像通过扩展网格线之间的实际宽度。通过grid-row-gap或grid-column-gap grid-gap属性简写&lt;grid-row-gap&gt; &lt;grid-column-gap&gt;123456#grid &#123; display: grid; grid-template-rows: 5em 5em; grid-template-columns: 15% 1fr 1fr; grid-gap: 12px 2em;&#125; 网格项与盒模型 基本工作原理：元素通过它的 margin 边缘来与网格连接。正边距将元素的可见部分从其占用的网格区域内推，负边距相反。 1234567891011#grid &#123; display: grid; grid-template-rows: repeat(2,100px); grid-template-columns: repeat(2, 200px);&#125;.box02 &#123; margin: 25px;&#125;.box03 &#123; margin: -25px 0;&#125; 同块级布局相似，在网格布局中，也可以使用margin的auto来将元素居中。 123456.i01 &#123;margin: 10px;&#125;.i02 &#123;margin: 10px; margin-left: auto&#125;;.i03 &#123;margin: auto 10px auto auto&#125;;.i04 &#123;margin: auto&#125;;.i05 &#123;margin: auto auto 0 0&#125;;.i06 &#123;margin: 0 auto&#125;; 网格项是绝对定位；如果已经定义了网格线的开始和结束，则该网格区域被用作为包含块和定位上下文，而网格项将定位在该上下文中。这意味着偏移量属性是根据网格区域计算的 123456789.exel &#123; grid-row: 2 / 4; grid-column: 2 / 5; position: absolute; top: 1em; bottom: 15%; left: 35px; right: 1rem;&#125; 对齐控制网格布局的对齐方式同弹性盒子布局很相似。 Property Aligins Applied to justify-content The entire grid in the inline(horizontal) direction Grid container justify-items All grid items in the inline direction Grid container justify-self A grid item in the inline direction Grid items align-self A grid item in the block(vertical) direction Grid items align-items All grid items in the block direction Grid container align-content The entire grid in the block direction Grid container 单个 item 的 对齐方式,justify-self, align-self 所有items的对齐方式，justify-items,align-items 整个grid的对齐方式，justify-content,align-content 层级与顺序 网格项在视觉上的重叠顺序，就是在文档源中的顺序。 同定位一样，可以使用z-index来调整元素在 z 轴上的位置。 网格项的order属性也会影响其重叠顺序。","categories":[{"name":"技术总结","slug":"技术总结","permalink":"https://better-jiang.github.io/categories/%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%93/"}],"tags":[{"name":"css","slug":"css","permalink":"https://better-jiang.github.io/tags/css/"}]},{"title":"2019年回顾与2020年展望","slug":"2019年回顾与2020年展望","date":"2019-12-31T12:49:37.000Z","updated":"2023-02-03T12:14:22.418Z","comments":true,"path":"2019/12/31/2019年回顾与2020年展望/","link":"","permalink":"https://better-jiang.github.io/2019/12/31/2019%E5%B9%B4%E5%9B%9E%E9%A1%BE%E4%B8%8E2020%E5%B9%B4%E5%B1%95%E6%9C%9B/","excerpt":"","text":"回顾 2019 年，自认为过的还不错，虽说没啥好值得狂喜得瑟的，但也无至暗时刻，总之如平淡无奇，不知不觉的过去也挺好。工作上，按需求计划，保质保量完成，没出大错，小有成就感。身体没坏无恙，且全年达到了经常参加体育锻炼的评定标准。心理上也算健康,除了偶尔佛系一下，平时心中都充满着理想与抱负，也时常怀有怜悯与感恩。 另外，在 2019 年，摩拜单车总里程破万，达到 10384 km,19 年骑了 2600km; Forest App 上 专注于学习的时间 有 22077 分钟，两倍于 18 年的 10083 分钟。个人博客写了 50 篇，其中随笔感悟 4 篇，技术总结 46 篇；读书 10+本，杂志 40+本； 熬夜（4 点后未睡）天数有 20+,晚睡（2:30 后未睡）天数有 100+;吃外卖次数 120+,自己做饭不超过 30 次,吃“陕西凉皮+汽水”套餐超过 100 次；喝可乐、雪碧等碳素饮料 20+瓶，运动功能饮料 50+瓶，纯牛奶 35 升左右，奶茶 3、4 杯，啤酒 2 瓶。玩，去海边 3 次，梧桐山 1 次，东门 1 次，莲花山山脚 4 次，观澜 2 次，东莞 1 次，广州 0 次，看电影 0 次，KTV 0 次，朋友聚餐 4 次。游戏玩的少了，仅在非工作日玩《英雄联盟》大乱斗，有 100+场次，喜欢使用像瑞文，剑魔，压缩，赵信，易大师，VN，寒冰，轮子妈等刚的英雄，硬刚无脑上。 当然，在 2019 年，我也有遗憾和不甘。遗憾有些事没早做准备，遗憾自己太怂，不够主动积极，更遗憾自己本有热情和计划，却不曾付之于行动，最终不了了之。我不甘于在公司默默无闻，不甘于理想计划落空，也不甘于被看低和无视。 所以，在 2020 年，我还有机会扳回一城，且摈弃一步到位，一蹴而就的幼稚念头。做好以下的 10 个小目标（排名就分先后）： 上厕所 少看手机，时长小于 12 分钟。 尽量用笔手写日记，随笔，50 篇。现今提笔忘字频繁，令我深感恐惧，一来让我联想起儿时语文课上听写字、词，默写古诗文不会时的紧张害怕，二来这似乎证明人老了，记忆力正减退。 工作上，认真仔细，先计划，在准备，再动手做；公司考核前 20%。 熬夜少于 5 天，晚睡少于 30 天。 每周运动 3 次，时长不小于 40 分钟。 个人博客，50 篇，包括但不限于工作总结、学习笔记、国外博客翻译、读书心得等。如产生稿费，1 篇抵 3 篇。 提高飞盘传盘水平，每周扔盘 2-3 次，参加 2-3 次比赛，尝试 handler 位置。 上线”青云飞盘”小程序（初版 4 月份），内容包括: 比赛规则/手势，国内外站点导航，盘友/飞盘组织注册统计,飞盘视频 有空而且无聊时，诵读古诗词，并背诵喜欢诗篇。 有空多看房子，了解政府 、银行、公司相关买房政策。首选深圳，次选新疆。（据已买房朋友讲，买房前，线下每看一个楼盘的房子，相当于节省 1000 元） 以上 10 个小目标，皆有 20%的活动余地。若 在 2020 年，本人遭受重伤（肉体和心灵）、大病 、致残，死亡，则算完成。广阔天地，大有作为，祝大家的 2020 年都顺顺当当，健健康康，喜乐安好！","categories":[{"name":"随笔感悟","slug":"随笔感悟","permalink":"https://better-jiang.github.io/categories/%E9%9A%8F%E7%AC%94%E6%84%9F%E6%82%9F/"}],"tags":[]},{"title":"CSS知识点梳理(12)-弹性盒子布局","slug":"CSS知识点梳理-12-弹性盒子布局","date":"2019-12-30T02:24:28.000Z","updated":"2023-02-03T12:14:22.418Z","comments":true,"path":"2019/12/30/CSS知识点梳理-12-弹性盒子布局/","link":"","permalink":"https://better-jiang.github.io/2019/12/30/CSS%E7%9F%A5%E8%AF%86%E7%82%B9%E6%A2%B3%E7%90%86-12-%E5%BC%B9%E6%80%A7%E7%9B%92%E5%AD%90%E5%B8%83%E5%B1%80/","excerpt":"","text":"基础（Flexbox Fundamental） 弹性/伸缩盒子布局是一种简单而强大的 布局页面组件的方法，它规定了空间是如何分配的，内容是如何对齐的，元素在视觉上是如何排序的。 在元素声明display: flex，此元素成为一个伸缩容器（flex container），在所提供的 空间内安排其子元素并控制它们的布局。伸缩容器的子元素变成伸缩项（flex items） 一旦设置一个元素成为伸缩容器，那么它只会flex其直接子代，而不会flex其进一步的后代。 在flex容器中，flex项在主轴（main axis）上排成一行。 伸缩容器（Flex Container） flex-direction: 控制主轴，flex项沿着主轴放置的。即指定如何在flex容器中放置flex 项。默认 row,是主轴方向，也即是当前写入模式的方向（writing mode） 12345Value: row|row-reverse|column|column-reverseInitial value: rowApplies to: flex containerInherited: NoAnimatable: No 写入模式的方向（Writing Direction）,由 CSS 中的writing-mode，direction属性控制，或者由 HTML 中的dir属性控制。 flex-wrap，控制flex 容器是否被限制为单行容器，或者在需要时允许成为多行容器。 12345Value: nowrap|wrap|wrap-reverseInitial value； nowrapApplies to: Flex contaierInherited: NoAnimatable: No flex-flow,flex-direction和flex-wrap的简写形式。 、 12345Vlaue: &lt;flex-direction&gt;||&lt;flex-wrap&gt;Initial value: row nowrapApplies to: Flex containerInherited: NoAnimatable: No 理解弹性盒子中的轴(axes) main axis：主轴，沿着 内容流动的轴，是flex 项流动的方向 main size：内容腌主轴的总长度 main start: 主轴上内容开始流动的一端 main end: 内容流向的主轴的末端 cross axis：沿着块堆叠的轴，是flex 项需要换行，放置 flex 项目 行的方向 Flex direction in LTR writing modes row row-reverse column colum-reverse main axis left to right right to left top to bottom bottom to top main-start left right top bottom main-end right left bottom top main size width width height height main dimension horizontal horizontal vertical vertical cross axis top to bottom top to bottom left to right left to right cross-start top top left left cross-end bottom bottom right right cross size height height width width cross dimension vertical vertical horizontal horizontal 排列 Flex 项（Arranging Flex Items）justify-contentjustify-content属性定义了flex项在主轴flex 行上的如何对齐，一根轴线（flex line）上flex 项是如何分布的 12345Value: flex-start|flex-end|center|space-between|space-around|space-evenlyInitial value: flex-startApplies to: Flex containersInherited: NoAnimatable: No flex-start flex-end center space-betweenspace-between将flex 行中的第一个flex 项与main-start对齐，最后一个flex 项与main-end对齐，然后在每个flex 项周围放置相同的空间，直到flex 行被填满。 space-aroundspace-around均匀的把额外空间分配在每一flex 项周围，就好像每个flex 项周围都有大小相同的非折叠边距。因此，首项和第二项，尾项和倒数第二项之间的空间是其他中间项之间的 2 倍(项之间的空间是项与边框之间的 2 倍)。 space-evenlyspace-evenly，项与项之间，项与边框之间的空间相同。 align-itemsalign-items属性定义每一个flex 行中flex项在交叉轴上如何对齐 123Value: flex-start|flex-end|center|baseline|stretchInitial value: stretchApplies to: Flex containers align-contentalign-content属性定义了多个flex 行的如何沿着交叉轴对齐。 该属性仅适用于多flex 行的flex 容器 flex 项(Flex 项) flex 容器的子元素被称为flex 项，包括子元素，子元素之间的非空文本节点，或者生成的内容。 当flex 容器包含文本节点时，且文本节点不是空的，它被包装在一个**匿名的flex 项**中，就像其它的flex 项的兄弟一样，并继承了flex 容器设置的所以 flex 属性。 空白的文本节点在flex 容器中会被忽略。 flex 项的边距（margin）不会折叠。 float,clear属性对flex 项没有影响，会被忽略。 vertical-align对flex 项没有影响，除非它影响到flex 项内容文本的对齐。 决定定位 flex 容器内的子元素，与其他任何决定定位元素一样，从文档流中移除。但是它会受到flex 容器的justify-content和align-self值的影响。 flex属性虽然通过在flex 容器上设置属性，可以在一定程度上控制flex 项的对齐、顺序、伸缩性，但是也有几个属性（flex-grow,flex-shrink,flex-basis）可以应用到单个flex 项上，以实现更细粒度的控制 123Value: [&lt;flex-grow&gt;&lt;flex-shrink&gt;?|| &lt;flex-basis&gt;]|noneInitial value: 0 1 autoAllpies to: Flex items(children of flex containers) flex-basis是指每个flex 项的初始大小，可以通过指定grow和shrink因子为 0 来限定为特定的大小。 1234.flexItem &#123; width: 50%; flex 0 0 200px;&#125; 以上 CSS,flex 项在主轴尺寸正好是 200px,其尺寸既不能增长也不能收缩。假若主轴是水平的，那么宽度值（50%）将被忽略。并且这种覆盖发生在 CSS 层叠之外，甚至不能通过添加！important来再覆盖掉 flex-grow flex-grow不能是负值，可使用小数。它决定了当flex 容器有额外空间被分配时，**flex 项相对于其它felx 项**的增长幅度。 额外空间根据增长因子的不同值按比例分配给具有非零正增长因子的子元素。 如果flex 项没有设置width或flex-basis，则flex-basis默认为auto,这意味着每个flex-basis是其非换行内容的宽度。即如果flex 项没有设置宽度，此时flex-basis将成为该宽度。 如果flex-basis被设置为0%或者默认值auto,且增长因子为 0 时，非增长的flex 项的主轴长度将收缩到内容允许的最小长度（即 最宽字母序列的宽度），或更小。 如果所有的flex 项都允许增长，并且每个flex 项的flex-basis都时0%,那么所有的空间，而不仅仅时额外空间，将根据增长因子按比例分配。 flex-shrink 如果flex 项中包含一个固定像素（300px）图像，则该flex 项不会收缩。 flex 项是与收缩因子和其宽度成比例的收缩的。 12345678910ShrinkPercent(收缩百分比) = NegativeSpace(缺少空间) / ((Width1 * ShrinkF1) + ... + (WidthN * ShrinkFN))// 例如 缺少空间：250px， flex项宽度： 250px 500px 250px; flex-shrink： 1 1 3收缩百分比 = 250px / ((250px * 1) + (500px *1 ) + (250px * 3)) = 250px / 1500px = 0.1666666667 (16.67%)item1 = 250px - (250px * 16.67% * 1) = 208.33pxitem2 = 500px - (500px * 16.67% * 1) = 416.67pxitem3 = 250px - (250px * 17.67% * 3) = 125px flex-basis1234Value: content|[&lt;length&gt; | &lt;percentage&gt;]Initial value: autoApplies to: Flex itemPercentage： Relative to flex container&#x27;s inner main-axis size 当没有其他属性（如：width,min-width）设置主轴上flex 项，flex-basis:auto或flex: 0 1 auto，则flex 项的宽度会尽可能的去适应其内容 flex 项上既设置了width，又设置了flex-basis，则flex-basis胜出。 flex 项上既设置了min-width，又设置了flex-basis，则min-width胜出。 flex-basis百分比数，是根据fkex 容器的主轴尺寸大小计算的。 flex-basis:auto，“可用”空间是基于 flex 项的 内容大小；flex-basis:0，那么”可用”空间就是整个flex 容器主轴的大小。 flex 简写（Flex Shorthand）切记，总是要使用flex简写，它接受 3 个全局属性值，initial,auto,none，和一个数值。 flex:initial 等同于flex: 0 1 auto; flex:auto等同于flex: 1 1 auto; flex:none 等同于flex: 0 0 auto; flex:&lt;number&gt;,flex:3 等同于flex:3 0 0; flex 项 顺序 默认，所有的flex 项的顺序都是 0. order属性指定flex 项所属的序号组，负值的flex 项出现在默认值为 0 的项之前，正值的flex 项出现在之后。 123456789101112ul &#123; display: inline-flex; background-color: rgba(0,0,0,0.1);&#125;li:nth-of-type(3n-1) &#123; order: 3; background-color: rgba(0,0,0,0.2);&#125;li:nth-of-type(3n+1) &#123; order: -1; background-color: rgba(0,0,0,0.4);&#125; item 2,5,8,11 的顺序组是 3 item 1，4，7，10 的顺序组是-1 item 3，6，9，12 的 顺序组是 0 按tab 键是按照源代码的顺序，而不是按布局的顺序。order属性仅改变布局的顺序，源代码顺序不变。","categories":[{"name":"技术总结","slug":"技术总结","permalink":"https://better-jiang.github.io/categories/%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%93/"}],"tags":[{"name":"css","slug":"css","permalink":"https://better-jiang.github.io/tags/css/"}]},{"title":"CSS知识点梳理(11)-定位","slug":"CSS知识点梳理-11-定位","date":"2019-12-30T02:21:48.000Z","updated":"2023-02-03T12:14:22.418Z","comments":true,"path":"2019/12/30/CSS知识点梳理-11-定位/","link":"","permalink":"https://better-jiang.github.io/2019/12/30/CSS%E7%9F%A5%E8%AF%86%E7%82%B9%E6%A2%B3%E7%90%86-11-%E5%AE%9A%E4%BD%8D/","excerpt":"","text":"定位可以准确地定义元素框相对于其正常位置，或相对于其父元素、另一个元素，甚至是浏览器窗口本身(视口，viewport)的位置，应该出现在哪里。 12345Value: static|relative|sticky|absolute|fixedInitial value: staticApplies to: All elementsInherited: NoAnimatable: No static: 元素框正常生成。块级元素生成一个矩形框，作为文档流的一部分。行内元素创建一个或多个在其父元素中流动的行框。 relative: 元素框偏移一段距离（相对于其自身偏移）。元素仍保持其为定位前的形状，并且它原本所占的空间仍保留。 absolute: 元素框从文档流完全删除，并相对于其包含块定位。元素原先在正常文档流中占据的空间会关闭，就好像元素不存在一样。定位元素生成块级框，而不论原来它在正常流中生成的框的类型 fixed: 元素框的表现类似于将position设置为absolute，但是其保护块是视口本身（viewport）。 sticky: 元素留在正常流中，直到处罚它的粘贴的条件出现，这时它从正常流中移除，其行为同absolate相同，但它在正常流中的原始空间被保留下来。一旦不在满足粘贴条件，元素将回到其原始空间中的正常流。stick元素是根据滚动位置在relative和fixed之间切换。它的位置是relative，直到一个给定的偏移位置在视口被满足，然后切换至fixed,就好像它“粘”在那个位置。 包含块一般来讲，包含块就是包含另一个元素的方框。在正常流中，html根元素是body元素的包含块。当涉及到定位时，包含块完全取决去定位的类型。 “根元素”的的包含块，也称初始包含块，，在大多数浏览器中，是一个视口大小的矩形。 对于一个非根元素，如果其position值是relative或static，包含块有最近的块级框、表单元格或行内块祖先框的内容边界构成。 对于一个非根元素，如果其position值是absolute，包含块设置为最近的position值不是static的祖先元素（可以是任何类型）。具体如下： 如果祖先是块级元素，包含块设置为该元素的填充边界，即有其边框界定的区域。 如果这个祖先是行内元素，包含块设置为该元素的内容边界。 如果没有祖先，则元素包含块定义为初始包含块。 定位元素的宽、高 relative,absolute,fixed使用了 4 个属性（top,bottom,right,left）来描述定位元素个各边相对于其包含块的偏移，那么元素的宽、高将由这些偏移隐含确定。 可以是使用max-width,min-height来为定位元素设置最小/最大 宽/高。 内容溢出12345Value: visible|hidden|scroll|autoInitial value: visibleApplies to: Block-level, replaced elementsInherited: NoAnimatable: No visible,默认值，元素内容在元素框之外也可见，但不会改变元素框的形状。 scroll,元素内容在元素框的边界处剪裁，会提供滚动机条。 hidden,元素内容在元素框的边界处剪裁，也不会提供滚条，使用户访问超出剪裁区的内容 auto,只在必要时提供滚动条。 元素可见性（visibility）12345Value: visible|hidden|collapseInitial value: visibleApplies to: All elementsInherited: YesAnimatable: No visible，默认值，元素设置为可见 hidden, 元素设置为“不可见”.但元素还会影响文档的布局，就好像声明opacity: 0;。换句话说，元素还在那里，只不过你看不到它。这与display: none有区别，对于后者，元素不仅不显示，还会从文档中删除，且对文档布局没有任何影响 collapse，用于表格元素。 绝对定位包含块和绝对定位元素元素绝对定位时，会从文档流中完全删除。相对于其包含块定位，其边距的边界根据偏移属性放置。定位元素不会围绕其他元素内容流动，反之亦然。这就意味着，一个绝对定位元素可能与其他元素重叠或被它们重叠。绝对定位的元素的包含块是最近的position值不为static的祖先元素。元素绝对定位时，也会为其后代元素建立一个包含块 （自动偏移）Auto-edges 非替换元素水平方向：left + margin-left + border-left-width + +padding-left+ width + padding-rgiht + border-right-width + margin-right + right = 包含块的width 如果left,width,right都设置auto。结果：左边界置于静态位置（元素在正常流中的原本位置，即在从左向右读的语言中，要把auto替换为静态位置），元素的width设置为“刚好只能包含其内容”，right的计算值就是从元素的右边界到包含块的右边界之间的距离。 如果left,width,right不是auto，左右外边距（margin： 0 auto;）都设置为 auto。这实际上回让元素居中。 如果定位元素个宽度相加还小于包含块的宽度，在这种情况下，浏览器会忽略right的值，并重置right的值 一般来讲，如果只有一个属性设置auto,就会修改这个属性来满足等式。元素会延伸到必要的宽度，而不是“收缩”内容 替换元素 如果width设置为auto,width的实际值有由元素内容的固有宽度决定。如果声明了width则使用该值 在从左向右读的语言中，如果left值为auto,要把auto替换为静态位置。 如果left或right仍为auto，则将margin-left或margin-right的auto值替换为 0. 如果此时margin-left和margin-right的值还定义为auto,则把它们设置为相等的值，从而将元素在其包含块中居中 在此之后，如果只剩一个auto,则将其修改为等于等式的余下部分 如果值过度受限，则浏览器会忽略 right 的值，并被新计算值覆盖。 Z 轴上的放置 利用z-index可以改变元素相互的覆盖顺序，较高z-index值覆盖较低z-index值的元素。 一旦给一个元素指定了z-index值（不是auto），该元素就会建立自己的局部叠放上下文，这意味着，相对于该祖先元素，所以元素的后代都有自己的堆叠顺序。 如果一个元素为其后代建立了叠放上下文，并且该元素位于此上下文 z 轴的 0 位置上。 123456789101112p &#123;border: 1px solid; background: #DDD; margin: 0;&#125;#one &#123;position: absolute; top: 1em; left: 0;width: 40%; height: 10em; z-index: 3;&#125;#two &#123;position: absolute; top: -0.75em; left: 15%;width: 60%; height: 5.5em; z-index: 10;&#125;#three &#123;position: absolute; top: 10%; left: 30%;width: 30%; height: 10em; z-index: 8;&#125;p[id] em &#123;position: absolute; top: -1em; left: -1em;width: 10em; height: 5em;&#125;#one em &#123;z-index: 100; background: hsla(0,50%,70%,0.9);&#125;#two em &#123;z-index: 10; background: hsla(120,50%,70%,0.9);&#125;#three em &#123;z-index: -343; background: hsla(240,50%,70%,0.9);&#125; 上述元素的叠放顺序: 123456p#one 3p#two 10P#three 8P#one em 3 100p#two em 10 10p+three em 8 -343 固定定位 固定定位与绝对定位很类似，只不过固定定位元素的包含块是视窗。固定定位时，元素会完全从文档流中移除，不会有任何相对于文档中任何部分的位置。 固定定位的用途在屏幕上放置一个“永久性”元素，例如，购买链接、版权信息 相对定位 使用偏移属性移动定位元素，不过，原来所占据的空间不会从文档流中移除 如果相对定位一个元素，它会立即为其所有子元素建立一个姓的包含块，这个包含块对应于该元素原本所在的位置，元素偏移是相对于其自身位置 如果遇到过度受限的相对定位，一个值会重置为另一个值的相反数。例如:12345strong &#123; position: relative; top: 10px; bottom: 20px;&#125; 因此： bottom的值总等于-top，即bottom: -10px; 粘性定位 偏移量用于定义与包含块相关的粘性定位矩形（sticky-positioning retangle） 粘性地位元素在正常流中，直到它的“粘性边缘”接触到矩形的粘性边缘，它就会脱离文档流，固定在那个位置。 使用overflow: scroll也可以为元素创建包含块，这中情况下，包含块不是有定位创建的。 如果定义多个偏移量属性，且都是auto以外的值，那么所以这些属性都成为“粘性边缘”。 显示的指定z-index的值，来决定粘性元素的叠放顺序","categories":[{"name":"技术总结","slug":"技术总结","permalink":"https://better-jiang.github.io/categories/%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%93/"}],"tags":[{"name":"css","slug":"css","permalink":"https://better-jiang.github.io/tags/css/"}]},{"title":"CSS知识点梳理(10)-浮动和形状","slug":"CSS知识点梳理-10-浮动和形状","date":"2019-12-27T01:05:10.000Z","updated":"2023-02-03T12:14:22.418Z","comments":true,"path":"2019/12/27/CSS知识点梳理-10-浮动和形状/","link":"","permalink":"https://better-jiang.github.io/2019/12/27/CSS%E7%9F%A5%E8%AF%86%E7%82%B9%E6%A2%B3%E7%90%86-10-%E6%B5%AE%E5%8A%A8%E5%92%8C%E5%BD%A2%E7%8A%B6/","excerpt":"","text":"浮动（Floating） 在某种程度上，被浮动的元素被从文档的正常流中移除，尽管它仍影响布局。一个元素被浮动时，其他内容会“环绕”该元素。 浮动元素周围的边距不会发生边距塌陷/折叠 如果要浮动一个不可替换元素，则必须声明该元素的宽度，否则，根据 CSS 规范，元素的宽度趋于 0. 浮动是详情浮动元素的包含块（containing block）是其最近的块级祖先元素浮动元素会生成一个块级框，而不论这个元素本身是什么。它就会像块级元素一样摆放和表现。控制浮动元素的摆放规则： 浮动元素的左（或右）内边界不能超过其包含块的左（或右）内边界 浮动元素的左（或右）外边界必须是在源文档中之前出现的左浮动（或右浮动）元素的右（或左）外边界，除非出现的浮动元素的顶端在先出现浮动元素的底端下面。 左浮动元素的右外边界不会在其右边右浮动元素的左外边界的右边。同理，右浮动元素的左外边界不会在其左边任何左浮动元素的右外边界的左边。防止浮动元素的重叠。 一个浮动元素的顶端不能比其父元素的内顶端更高。如果一个浮动元素在两个折叠外边距之间，放置这个浮动元素时就好像在两个元素之间有一个块级父元素。 浮动元素的顶端不能比之前所有的浮动元素或块级元素的顶端更高。 浮动元素的顶端不能高于任何行框的顶端，也包括源文档中较早出现的元素生成的框。该规则京一部限制了元素的向上浮动，不允许元素浮动到包含该浮动元素之前内容的行的顶端之上。 左浮动元素的左边有另一个浮动元素，其右外边界不能在其包含块的右边界的右边。同理，右浮动元素的右边右另一个浮动元素，其左外边界不能在其包含块的左边界的左边。即，浮动元素不能超过其包含块元素的边界，如果超出，则这个浮动元素会向下浮动 在满足其他约束条件的前提下，浮动元素必须尽可能的高地放置 左浮动元素必须向左尽可能的远，右浮动元素必须向右尽可能的远。位置越高，就会向左，向右浮动的越远。 应用行为 浮动元素会延申，从而包含其所有的后代浮动元素。因此，通过将父元素也设置为浮动元素，就可以把其后代浮元素包含在其父元素内123&lt;div style=&quot;float: left; width: 100%;&quot;&gt; &lt;img src=&quot;jiang.gif&quot; style=&quot;float: left;&quot;&gt; The &#x27;div&#x27; will stretch around the floated image, becasue the &#x27;div&#x27; has been floated.&lt;/div&gt; 负外边距可能导致浮动元素移动到其父元素的外面。 浮动元素与正常内容发生重叠时，显示规则 行内框与一个浮动元素重叠时，其边框、背景和内容都在该浮动元素“之上”显示 块级框与一个浮动元素重叠时，其边距、背景在该浮动元素“之下”显示，但内容在浮动元素“之上”显示。即，行内元素完全覆盖浮动元素（包括其背景、边框、内容），而块级元素仅内容显示在浮动元素之上，但其背景、边框放在浮动元素之下 这里所描述的重叠行为与源文档中的顺序无关。元素在浮动元素之前还是之后出现并不重要，都会有相同的行为。 清除（Clearing）12345Vlaue: left|right|both|noneInitial value: noneApplies to: Block-level elementsInherited: NoAnimatable: No h3 &#123;clear: left;&#125;解释为“确保h3的左边没有浮动元素” 在 CSS2.1 中，引入了一个清除区域（clearance）,它是在元素的上外边距之上增加的额外间隔，且不允许任何浮动元素进入这个范围内。这就意味着，元素设置clear属性时，它的外边距不会改变，之所以会向下移动是清除区域造成的 大多数情况下，无法知道一个元素周围多大范围内不允许有浮动元素。要确保清除元素的顶端与浮动元素的底端之间有一定的空间，可以为浮动元素本身设置一个下边距。12345678img &#123; float: left; margin: 0 0 15px;&#125;h3 &#123; border: 1px solid gray; clear: left;&#125; 浮动元素的外边距边界定义了浮动框的边界，清除元素必须下移到浮动框以下 浮动形状（Float Shapes）","categories":[{"name":"技术总结","slug":"技术总结","permalink":"https://better-jiang.github.io/categories/%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%93/"}],"tags":[{"name":"css","slug":"css","permalink":"https://better-jiang.github.io/tags/css/"}]},{"title":"CSS知识点梳理(9)-颜色、背景色、渐变","slug":"CSS知识点梳理-9-颜色、背景色、渐变","date":"2019-12-26T13:00:34.000Z","updated":"2023-02-03T12:14:22.418Z","comments":true,"path":"2019/12/26/CSS知识点梳理-9-颜色、背景色、渐变/","link":"","permalink":"https://better-jiang.github.io/2019/12/26/CSS%E7%9F%A5%E8%AF%86%E7%82%B9%E6%A2%B3%E7%90%86-9-%E9%A2%9C%E8%89%B2%E3%80%81%E8%83%8C%E6%99%AF%E8%89%B2%E3%80%81%E6%B8%90%E5%8F%98/","excerpt":"","text":"颜色 (Colors) 使用color属性设置的是元素的前景色，通常指文本的颜色 color属性也影响元素的边框颜色，如果没有border-color属性，边框颜色默认前景色，也就是color属性的值.如下所示，元素&lt;p class=&quot;aside&quot;&gt;灰色文本，灰色的中等宽度的实线的边框。1234p.aside &#123; color: gray; border-style: solid;&#125; color属性也影响表单元素，但表单元素，就像图像一样，是可替换元素。它们实际上并不是 HTML 文档的内容，CSS 不会对可替换元素的内容进行样式设置的。不同浏览器之间表单样式是不一致的，所以，表单元素是非常棘手的，应谨慎处理。 背景色 (Backgrounds) 默认情况下，元素的背景色区域包含内容区，填充，边框则绘制在背景色之上。 background-color默认值transparent,背景色不可继承。 background-clip12345Value: [border-box|padding-box|content-box|text]Initial value: border-boxApplies to: All elementsInherited: NoAnimatable: No background-clip定义了背景绘制区域，背景同时绘制在边框可见区域的后面。 一些注意事项 background-clip不能作用于根元素（html） 如果元素有圆角(border-radius)，则背景区域也会相应的精确减少。 background-clip与background-repeat交互效果很差 background-clip只定义了背景的裁剪区域，它不会影响到其他背景属性，比如background-image background-position123456789Value： &lt;length&gt; || &lt;length&gt; &lt;positon&gt; || &lt;positon&gt;Values： 0% 0%Percentages： 参考元素背景区域和图像上对应的点（top-left）Inherited： NoAnimatable: Yes&lt;length&gt;: 百分比，长度值&lt;position&gt;: top, center, bottom, left, right background-position如何确定图像在元素背景区域中的位置。 background-position指定两个值，一个定义 x 坐标，一个定义 y 坐标。指定一个值，则第二个值默认为center。 background-position: 0% 0%;：图像的左上角与元素背景区域的左上角对齐。等同于background-positon: left top; background-position: -50px -50px;: 图像以元素背景区域左上角为参考，向左偏移 50px，向上偏移 50px。 background-position: 50% 50%;: 图像的 50%，50%点同元素背景区域 50%，50%的点对齐。等同于background-position: center center偏移量计算：x 方向：(背景区域宽度 - 图像宽度) - x 方向百分比y 方向：(背景区域高度 - 图像高度) - y 方向百分比假如 图像 300px，300px, 元素背景区域 500px,500px, 计算偏移量：x 方向：100px; y 方向：100px; 百分比值，偏移量计算 123(container width - image width) * (position x%) = (x offset value)(container height - image height) * (position y%) = (y offset value) background-repeat 指定两个值，第一个应用于水平方向，第二个应用于垂直方向。指定一个值，则水平，垂直方向都应用，除了repeat-x,repeat-y。 Single Keyword Equivalent Keywords repeat-x repeat-x no-repeat repeat-y no-repeat no-repeat repeat repeat repeat no-repeat no-repeat no-repeat space space space round round round 当指定background-position时，图像的重复从指定位置向两边重复的。 space,它计算出一个给定轴上可以重复图像多少次，然后按一定的间隔将它们分开，这就重复的图像就可以从背景区域的一边重复到另一边。保证图像在边缘处不被裁剪，是完整的。如果图像重复超过一次，就会忽略/覆盖掉background-position指定的位置 round,最有可能导致图像的缩放,使图像重复适合的整数次数。而且它不会忽略/覆盖掉background-position指定的位置。 所以，确保重复模式合适且不会裁剪图像的唯一方法将图像放在角落。 background-attachmentbackground-attachment属性决定了背景图像的位置是在视口（viewport）内固定，还是随着包含它的区域滚动。 scroll，默认值，表示背景相对于元素本身固定，不随着它的内容滚动 fixed, 表示背景相对于视口固定。即使元素有滚动，背景也会随着元素、或元素内容滚动 local, 表示背景相对于元素的内容固定，并且背景的绘制区域和地位区域是相对于可滚动的区域而不是包含它的边框。 参考 MDN background-attachment background-size12345Value: [&lt;length&gt;|&lt;percentage&gt;|auto]&#123;1,2&#125;|cover|containInitial value: autoApplies to: All elementsInherited: NoAnimatable: Yes background-size设置图片大小，可拉伸到新尺寸，也可保持原有比例的同时缩放到元素的可用空间尺寸。 指定两个值，第一个指定图片的宽度，第二个指定图片的高度；一个值，这个值指定图片的宽度，图片的高度默认为auto &lt;length&gt;值，不能为负值;&lt;percentage&gt;值，相对于背景区域（background positioning area）的百分比。背景区域由background-origin设置，默认为盒模型的内容区于填充。如果background-attachment为fixed，背景区域为浏览器可视区（视口）,不包含滚动条。 auto，以背景图片的比例缩放。 cover,缩放背景图片以能完全覆盖背景区域。尽可能大的缩放背景图片，并保持图片的宽高比例。 contain，缩放背景图片以完全装入背景区域，背景区域可能有部分空白。 一个auto，另一个不是auto,如果图像有固有比例，则指定的长度使用指定值，未指定的长度由指定值和固有比例计算。如果没有固有比例，则指定长度使用指定值，未指定的长度使用图像相应的固有长度，若还没有固有长度，则使用背景区域相应的长度。 位图一定有固有尺寸和固有比例；矢量图可能二者都有，也可能只有一个。渐变视为只有固有尺寸或只有固有比例的图片 background123456Value: [&lt;bg-layer&gt;,]* &lt;final-bg-layer&gt;Initial value: Refer to individual propertiesApplies to ； All elementsInherited: No&lt;bg-layer&gt;: &lt;bg-image&gt;||&lt;position&gt;[/&lt;bg-size&gt;]?||&lt;repeat-style&gt;||&lt;attachment&gt;||&lt;box&gt;||&lt;box&gt; 1234567891011121314body &#123; background-color: white; background-image: url(jiang.png); background-position: top left; background-size: 50% 50%; background-repeat: repeat-y; background-attachment: fixed; background-origin: border-box; background-clip: padding-box;&#125;body &#123; background: white url(jiang.png) top left/50% 50% repeat-y fixed border-box padding-box;&#125; 简写语法需要注意地方如下： 在每一层中，下列的值可以出现 0 次或 1 次： &lt;attachment&gt; &lt;bg-image&gt; &lt;position&gt; &lt;bg-size&gt; &lt;repeat-style&gt; &lt;bg-size&gt;只能紧跟着&lt;position&gt;后面出现，并且以/分割，如:top left/50% 50% &lt;box&gt;可能出现 0 次，1 次，2 次。如果出现 1 次，它同时设定background-origin和background-clip。如果出现 2 次，第一次设定background-origin，第二次设定background-clip background是一个简写属性，它有其默认值，所以它的默认值可以覆盖之前给定的值。如下，h2的其它background属性被默认值覆盖。 12345678h1, h2 &#123;background: gray url(thetrees.jpg) center/contain repeat-x;&#125;// 错误h2 &#123;background: silver;&#125;// 正确h2 &#123; background-color: silver;&#125; 渐变 （Gradients）阴影（Box Shadows）1box-shadow: none|h-offset v-offset blur spread color | inset; box-shadow由,分割的列表来描述一个或多个阴影效果。如果设置了border-radius，阴影也会有圆角效果。 blur，阴影模糊半径，值越大，模糊面积就越大，阴影就越大越淡。 spread,阴影大小，正值，阴影扩大，负值，阴影收缩。默认为 0. inset，变为内部阴影。","categories":[{"name":"技术总结","slug":"技术总结","permalink":"https://better-jiang.github.io/categories/%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%93/"}],"tags":[{"name":"css","slug":"css","permalink":"https://better-jiang.github.io/tags/css/"}]},{"title":"CSS知识点梳理(8)-填充、边框、轮廓、边距","slug":"CSS知识点梳理-8-填充、边框、轮廓、边距","date":"2019-12-25T09:13:23.000Z","updated":"2023-02-03T12:14:22.417Z","comments":true,"path":"2019/12/25/CSS知识点梳理-8-填充、边框、轮廓、边距/","link":"","permalink":"https://better-jiang.github.io/2019/12/25/CSS%E7%9F%A5%E8%AF%86%E7%82%B9%E6%A2%B3%E7%90%86-8-%E5%A1%AB%E5%85%85%E3%80%81%E8%BE%B9%E6%A1%86%E3%80%81%E8%BD%AE%E5%BB%93%E3%80%81%E8%BE%B9%E8%B7%9D/","excerpt":"","text":"基本元素框 所以文档元素都生成一个矩形框，称之为元素框（element box），它描述了元素在文档布局中所占的空间大小。 手动定位（position）元素框，它们可能会重叠；在正常流的元素上使用负边距，也会出现视觉重叠。 width,height属性不能应用于行内非替换元素。 正常流中的元素很少设定height，height是由元素内容决定的，而非创作者决定。 填充（Padding） 默认情况下，元素没有填充。如果没有填充 ，元素的边框会与元素本身的内容很接近，所以，给元素边框时，最好同时增加填充。 百分比值是相对于其父元素（包含块）的width计算的，所以父元素的width改变，其值也相应改变 对于行内元素，填充不会改变元素行高，但是对于有背景色和填充的行内元素，其背景色可以扩展到元素的上下padding（因为填充能延伸背景）。 对于替换元素，填充会影响元素行高；不论替换的元素是块级元素还是行内元素，填充都会包围其内容，背景色将填入到该填充中。 边框（Border） 边框的默认值：style：none,width: medium,color: 元素的前景色; border: [&lt;border-style&gt; || &lt;border-width&gt; || &lt;border-color&gt;] 对于行内元素，无论怎样设定边框宽度，元素的行高都不会改变。如果有背景色，上下边框会覆盖其它行内容，左右边框不会。 对于替换元素，例如图像，边框会影响文本行的行高。 border-radius border-radius: 2em;左上角，边框开始在距上边框 2em，距左边框 2em 的地方开始弯曲，曲线沿着半径为 2em 的圆走。 border-radius: 33% border-radius: 1em / 2em;(水平方向/垂直方向) Image Borderborder-image有 3 个参数： 图片（border-image-source），剪裁位置（border-image-slice），重复性（border-image-repeat） border-image-source同background-image属性一样，使用url()，默认值none. border-image-slice数值单位是 px,百分比值相对于边框图像大小；边框图片根据 4 个参数值进行“四刀切”，形成一个九宫格。比如border-image-slice: 30% 35% 40% 30%. border-image-repeat4 个关键字值：repeat(重复)，round(平铺),stretch(拉伸)，space。默认值为stretch;round会拉伸/压缩图片，以使图片能完全铺满;space不会改变图片大小，会将多余空间均匀分配。可有 2 个参数，第一个代表水平方向，第二个代表垂直方向 九宫格模型如上图所示，橙红色的四个边角区域称之为“角边框图片”，没有任何展示效果，固定在边框四角。橙黄色区域属于展示效果的作用区（也是边框宽度计算的剩余区），会被平铺，重复，拉伸。 border-image 绘制原理简述 调用边框图片，通过border-image-source链接图片 边框图片的剪裁，形成九宫格 剪裁图片填充到边框，9 部分，一一对应的放至元素边框的九宫格，然后再压缩/拉伸至同边框宽度大小 执行重复属性，四个角的边框图片不执行，上下执行水平方向，左右执行垂直方向，中间格子则水平、垂直都要执行。 完成绘制，实现效果 参考内容： border-image 详解 轮廓（Outline）轮廓往往是绘制在边框之外的。轮廓与边框有以下几个基本区别： 轮廓不占据空间，不会影响行高 轮廓可以是非矩形 元素通常在:focus状态下，呈现轮廓 轮廓是全有或全无的命题，不能像边框一样，仅独立的设定某一边的样式 边距（Margin）123456Value: [&lt;length&gt;|&lt;percentage&gt;|auto]&#123;1,4&#125;Initial value: Not defined (0)Applies to: All elementsPercentage: Refer to the width of the containing blockInherited: NoAnimatable: Yes 与padding一样，计算margin的百分比值是相对于父元素内容区的宽度，所以父元素宽度变化，其margin也随之改变。 与paddding一样，对于大多数定位元素，flex 项，grid 项，对于顶部和底部空白的百分比值的处理是不同的，它们是根据格式化上下文的高度计算的。 边距塌陷/折叠：块级框的顶部和底部边距经常发生边距塌陷/折叠，即两个或多个相互作用的边距折叠到最大边距的过程（多个边距，取最大边距，如果出现负边距，则最大的正边距中减去绝对值最大的负边距）。 边距塌陷/折叠 ，也能解释当一个元素在另一个元素内部出现的怪异现象。内部元素的margin好像从父元素跑出，并作用于父元素。（父元素和第一个或最后一个子元素之间，发生边距塌陷/折叠）123456789header &#123; background: goldenrod;&#125;h1 &#123; margin: 1em;&#125;&lt;header&gt; &lt;h1&gt;I love learning!&lt;/h1&gt;&lt;/header&gt; 边距塌陷/折叠可以被父元素上的填充和边框等因素打断 负边距，可能导致元素框突出其父元素或与其他元素重叠。 对于行内非替换元素，边距是透明的，不会影响行高，且仅作用于左右，不会作用于上下 对于行内替换元素，边距影响行高，且 作用于上下左右。","categories":[{"name":"技术总结","slug":"技术总结","permalink":"https://better-jiang.github.io/categories/%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%93/"}],"tags":[{"name":"css","slug":"css","permalink":"https://better-jiang.github.io/tags/css/"}]},{"title":"柳州飞盘hat赛有感","slug":"柳州飞盘hat赛有感","date":"2019-12-23T13:12:12.000Z","updated":"2023-02-03T12:14:22.417Z","comments":true,"path":"2019/12/23/柳州飞盘hat赛有感/","link":"","permalink":"https://better-jiang.github.io/2019/12/23/%E6%9F%B3%E5%B7%9E%E9%A3%9E%E7%9B%98hat%E8%B5%9B%E6%9C%89%E6%84%9F/","excerpt":"","text":"如果没有参加这次柳州 jumble 赛，我的 2019 年里也就没了飞盘，少了此次比赛带给我的激动与紧张，却又兴奋和快乐的时刻。毕竟这一年我过的无波无澜，平淡极了。所以我十分感谢此次飞盘赛举办方和前来参赛的飞盘爱好者们，让我在年末多快乐了几天。 虽然我们队（桂林米粉队）战绩不太理想，2 胜 4 负，但过程是精彩且开心的，队友们友善近人，有伤的队长给我们拍照，场边队友提醒场上队员如何站位，怎样防守。真希望以后有机会再一起并肩比赛，做对手也行。 对我个人而已，有些不足之处: a. 传盘质量不高，尤其是给跑动中的队友传盘时,无法做到既平且稳，又不易被断; b. 不够果断，在攻防转换时，如有机会应该果断捡盘进攻,或 go deep，而不需等远处的 handler 捡盘，站好位后再进攻。c. 赛前的准备不够充分，虽说自报名后的一个月里，有意的每周 2、3 次 6~10km 的跑步、拉伸，体能勉强够用，但因没有传盘、冲刺跑以及弹跳方面的练习，导致比赛中冲不起来，跳不高，失去了很多接/断盘的机会。 在柳州，吃了螺蛳粉，米粉，去了博物馆，参观了工业博物馆，也去柳侯公园溜达了一圈，晚上和盘友们逛了乌托邦音乐城。也一人做公交瞎逛，登东门城楼，俯瞰柳江，身临其境般的吟诵了柳宗元的《登柳州城楼寄漳汀封连四州刺史》一诗。隐约感觉这里的人都很瘦，3 天里未发现一个像样的胖纸，一查得知，中国肥胖率广西倒数第二。 最后，感谢顺子，晓歪姐在群里分享的分盘规则和手势资料！ 飞盘视频","categories":[{"name":"随笔感悟","slug":"随笔感悟","permalink":"https://better-jiang.github.io/categories/%E9%9A%8F%E7%AC%94%E6%84%9F%E6%82%9F/"}],"tags":[{"name":"飞盘","slug":"飞盘","permalink":"https://better-jiang.github.io/tags/%E9%A3%9E%E7%9B%98/"}]},{"title":"CSS知识点梳理(7)-基本视觉格式化","slug":"CSS知识点梳理-7-基本视觉格式化","date":"2019-12-16T07:13:25.000Z","updated":"2023-02-03T12:14:22.417Z","comments":true,"path":"2019/12/16/CSS知识点梳理-7-基本视觉格式化/","link":"","permalink":"https://better-jiang.github.io/2019/12/16/CSS%E7%9F%A5%E8%AF%86%E7%82%B9%E6%A2%B3%E7%90%86-7-%E5%9F%BA%E6%9C%AC%E8%A7%86%E8%A7%89%E6%A0%BC%E5%BC%8F%E5%8C%96/","excerpt":"","text":"基本框CSS 假设每个元素都会生成一个或多个矩形框，称之为元素框（element box）。每个元素框 中心有一个内容区（content area）。内容区周围有可选的padding,border,outline,margin,将它们的宽度设为 0，可以将它们从元素框去除。 内边距（padding）,不能为负值，内容的背景色会应用到内边距。 外边距（margin），通常是透明的，从中可以看到父元素的背景色，外边可以为负值。 边框（border），如果没有设置颜色，则取元素内容的前景色。如果边框样式有某中间隙，则可以通过间隙看到元素的背景色（换句话说，边框与内容和内边距具有相同的背景）。边框的宽度不能为负值。 轮廓（outline），轮廓不占据空间，它被描绘与内容之上。 快速复习 正常流（Normal flow）：在西方语言中从左到右，从上到下的文本渲染，也是传统 HTML 文档的文本布局。要注意，在非西方语言中，流向可能发生变化。大多数元素都在正常流中，唯一让一个元素脱离正常流的方法就是让其成为浮动元素、定位元素、或者是弹性盒子、网格布局元素。本章讨论的元素都在正常流中。 不可替换元素（Nonreplaced element）： 其内容包含在文档中的元素。例如，p段落是不可替换的元素，因为其文本内容位于该元素本身内。 可替换元素（Replaced element）：这是充当其他内容占位符的元素。一个典型的例子就是img元素，它只是指向一个图像文件，这个文件将插入到文档流中该img元素本身所在的位置。大多数表单元素也是可替换的。 根元素（Root element）： 文档树顶端的元素。在 HTML 文档中，根元素是html元素。 块级盒子/框（Block box）: 这是一个由元素（如p,div）生成的框。这些块级框在正常流中，会在其框之前和之后生成“换行”，所有处于正常流中的块级框会一个一个垂直摆放的。通过声明display:block,任何元素都能生成一个块级框。 行内框（Inline box）：这是一个由诸如strong,span之类元素生成的框。这些框不会在它之前、之后生成“换行”。通过声明display:inline，任何元素都能生成一个行内框。 行内-块框（Inline-block box）：这是一个内部类似于块级框，但外部类似于行内框的框。它的行为与可替换元素相似，但不完全相同。想象一下，把一个div粘贴到一行文本中，就好像它是嵌入图像一样。 包含块（the containing block） 每一个元素的框都是相对于其包含块进行布局；实际上，包含块是盒子/框的“布局上下文”。 对于正常的西式文本流中的元素，包含块是从生成列表项或块级框(list item or block box)的最近祖先的内容边缘开始形成的。 html元素所在的包含块是初始包含块(initial containing block) 改变元素显示方式通过给dispaly属性设置显示的值来改变样式的显示方式。 12345678910111213Values: [&lt;display-outside&gt; || &lt;display-inside&gt;] | &lt;display-listitem&gt; | &lt;display-internal&gt; | &lt;display-box&gt; |&lt;display-legacy&gt;Initial value: inlineInherited: NoAnimatable: No&lt;display-outside&gt;: block | inline | run-in&lt;display-inside&gt;: flow | flow-root | table | flex | grid |ruby&lt;display-listitem&gt;: list-item&lt;display-internal&gt;: table-row-group | table-column-group | table-row-group | ...&lt;display-box&gt;: contents | none&lt;display-legacy&gt;: inline-block | inline-list-item | inline-table | inline-flex | inline-grid 使用display属性只是改变元素的显示角色，而不是改变它们的固有性质。内联元素可以是块元素的后代，但反过来不行。 123&lt;span style=&quot;display: block;&quot;&gt; &lt;p style=&quot;display: inline;&quot;&gt;this is wrong!&lt;/p&gt;&lt;/span&gt; 块级框（Block Box）块级框的行为有时是可预测的，有时是令人惊讶的。比如，沿水平轴和垂直轴放置框的处理可能不一样。详细如下图（盒模型）： box-sizingbox-sizing属性可以改变上述盒模型的width和height值的实际包含的区域。默认的区域是(内容框)content-box。box-sizing属性，适用于”接受宽度和高度值的所有元素”，所以它也适用于替换的行内元素（如img）和行内块元素。12345Values: content-box | padding-box | border-boxInitial value: content-boxApplies to: All elements that accept width or height valuesInherited: NoAnimatable； No 水平格式化 box-sizing的默认值是content-box，则宽度的指定值将影响内容区域的宽度，而不是整个可见元素框的宽度。 正常流中块级框的水平宽度的总和等于包含块的宽度。 水平属性 有 7 个属性，margin-left,border-left,padding-left,width,padding-right,border-right,margin-right. 这 7 个属性的值相加等于该元素包含块宽度，即块元素的父元素的width值。 3 个属性，width,margin-left,margin-right可以设置为auto，其余属性必须设置为特定值或默认的 0. 使用auto总之上述 7 个属性相加等于包含块的宽度 1 个 auto: auto = 父元素宽度-其余6个属性值之和 2 个 auto: margin-left,margin-righ为auto，auto: (父元素宽度 - width) / 2; width,其中1个外边距为auto,则外边距减为0。width = 父元素宽度 - 给定的外边距的值 3 个 auto: 2 个外边距为 0. 负值 外边距请记住，7 个水平属性的总和总是等于父元素的宽度。 123456789div &#123; width: 500px; border: 3px solid black;&#125;p.wide &#123; margin-left: 10px; width: auto; margin-right: -50px;&#125; 10px + 0 + auto + 0 + 0 - 50px = 500px，auto = 540px, 则width:540px; 12345678910div &#123; width: 500px; border: 5px solid black;&#125;p.wide &#123; margin-left: 10px; width: 600px; margin-right: auto; border: 3px solid gray;&#125; 10px + 3px + 0 + 600px + 0 + 3px + auto = 500px,auto = -116px, 则margin-right: -116px. 请记住：填充（padding）、边框（border）、内容宽/高（width/height）不可能是负值。只有外边距（margin）可以是负值。 百分比 边框（border）的值只接受长度值，不接受百分比值。 百分比值是相对于包含块（containing block）的宽度值（也就是其父元素的宽度） 12345678&lt;p style=&quot;width: 67%; padding-right: 5%; padding-left: 5%; margin-right: auto; margin-left: 5%&quot;&gt; playing percentages&lt;/p&gt;&lt;!-- 5% + 5% + 67% + 5% + auto = containing block width auto: 18% --&gt; 替换元素（Relpaced Elements）到目前为止，我们在处理正常文本流中不可替换的块框的水平格式。 块级替换元素也使用于以上规则。 块级替换元素如果width:auto,那么元素的宽度就是内容的固有宽度（例如，img元素，原始图像的宽度）。 img元素，width属性可以指定不同的宽度值。 当可替换元素的宽度从固有宽度更改时，其高度值也会等比例的缩放以匹配，除非高度也被设置。同理，高度也是如此。123&lt;img src=&quot;smile.svg&quot; style=&quot;display: block; width: 25px; margin: 0;&quot;&gt;&lt;img src=&quot;smile.svg&quot; style=&quot;display: block; width: 50px; margin: 0;&quot;&gt;&lt;img src=&quot;smile.svg&quot; style=&quot;display: block; width: 100px; margin: 0;&quot;&gt; 垂直格式化（Vertical Formatting） 元素的内容决定了元素的默认高度。内容的宽度也影响高度，一个块级元素宽度越小，为了包含所有的内联内容，它就必须越高。 当元素的内容比其块框的高度高时，其实际行为取决于属性overflow的值。 与width一样，height默认定义内容区域的高度，而不是可视元素框（visible element box）的高度，除非box-sizing的值不是content-box. 垂直 相关 属性（Vertical Properties） 同水平格式化一样，垂直相关的属性也涉及 7 个属性：margin-top,border-top,padding-top,height,padding-bottom,padding-border,margin-top. 上述 7 个属性的值的和必须等于其包含块的高度，通常是其父元素的高度值。 仅height,margin-top,margin-bottom3 个值可以设置为auto.padding,border相关的值必须设置具体的值或者默认值为 0。 margin-top,margin-bottom在正常流中块框中设置为 auto，二者都自动重设为 0.0 值会妨碍正常流盒在其包含块中的垂直居中。 百分比高度 正常流块框的高度设置成百分比，此值相对于包含块高度的。 子元素的百分比高度是根据父元素的高度来确定的，当父元素的高度为不确定值时，或者父元素高度未定义时，子元素的高度百分比将无用,将被重设为 auto123 &lt;div style=&quot;height: auto;&quot;&gt; &lt;p style=&quot;height: 50%&quot;&gt;Not Half as tall, height reset to auto&lt;/p&gt;&lt;/div&gt; auto 高度 如果一个正常流 块框设置height:auto，那么其高度值刚好可以将其内联内容的行框包裹起来。 如果一个正常流 块框设置height:auto,并且仅有块级的子元素，则其高度值等于最顶层的子元素的顶部外边框边缘的到最底层的子元素的底部外边框边缘的距离。 垂直边距 塌陷/折叠/重叠（Collapsing Vertical Margins） 垂直方向上相邻的 margin 会发生折叠行为。而padding和border不存在折叠行为。 margin 发生折叠/重叠（collapse / overlap）行为，较小的边距被较大的边距所取代。 在一个包含块中引入边框(border)或填充(padding)会导致其子元素的边距（margin）被包含在其中。 the introduction of a border or padding on a containing blokc would cause the margins of its child elements to be contained within it. 负边距和折叠（Negative Margins and Collapsing）如果设置了负的垂直边距，则折叠后的边距为正、负边距相加的值。 1234567891011p.neg &#123;margin-top: -50px; margin-right: 10px;margin-left: 10px; margin-bottom: 0;border: 3px solid gray;&#125;&lt;div style=&quot;width: 420px; background-color: silver; padding: 10px;margin-top: 50px; border: 1px solid;&quot;&gt;&lt;p class=&quot;neg&quot;&gt;A paragraph.&lt;/p&gt;A div.&lt;/div&gt; 上述示例，p段落，被负上边距向上拉了 50px，它后面的div内容也被向上拉了 50px。事实上，p段落后面的每一个正常流内容都被向上拉了 50px。 当div中的内容都被向上拉出，其高度为 0 行内元素行 布局（Line Layout） 为了理解如何生成行，首先要知道一个元素都包含一个很长的文本行。 当text-align: justify时，每一都必须与段落的内容区域一样宽，使得该行的边缘与段落的内容边缘相接触。行长度和段落之间的差异通过改变每行中字母和单词之间的间距来弥补。所以word-spacing被text-align:justify覆盖，如果letter-spacing的值不是长度值也会被覆盖。 基本术语和概念匿名文本（Anonymous text）所有未包含在行内元素的字符串。例如&lt;p&gt;I&#39;m &lt;em&gt;so&lt;/em&gt; happy!&lt;/p&gt;,”I’m “和” happy!”是匿名文本。注意，空格也是匿名文本，因为空格和其他字符一样都是正常的字符。 字符框（Em box）em 框是在字体中定义的，也称字符框。实际的字形（glyphs）可能比 em 框更高或者更矮。在 CSS 中，font-size的值决定了每个 em 框的高度。 内容区（Content area）在非替换元素中，内容区有 2 中，CSS 规范允许选择其中任意一种。内容区可以是元素中各字符的 em 框串在一起构成的框，也可以是有元素中字符字形描述的框。本书中，简单起见采用 em 框定义的。在替换元素中，内容区就是元素的固有高度+padding+border+margin。 行间距（Leading）行间距是font-size和line-height值之差。这个差被一分为二，分别应用到内容区的顶部和底部。内容区增加的这两部分分别称“半间距（half-leading）”。行间距只应用于非替换元素 行内框（inline box）这个框通过向内容区添加行间距来描述的。对应非替换元素，行内框的高度刚好等于line-height的值。对应可替换元素，行内框的高度刚好等于内容区高度，因为行间距不能应用于可替换元素。 行框（Line box）这是包含该行出现的行内框的最高点和最低的的最小框。换句话就，行框的上边界要位于最高行内框的上边界，而行框的下边界要位于最低行内框的下边界。 根据前面介绍的术语和定义，CSS 还提供了一组行为和有用的概念： 内容区类似于一个块级元素的内容框。 行内元素的背景应用于内容区+padding. 行内元素的边框包围着内容区以及任何 padding 和 border。 非替换元素的 padding、border、margin 对行内元素或其生成的框没有垂直影响。也就是说，它们不会影响元素行内框的高度，因此也就不会影响包含元素的行框高度。 替换元素的 margin、border 会影响该元素行内框的高度，从而也影响到包含该元素的行框的高度。需要注意，行内框根据vertical-align属性值 在行中垂直对齐 逐步构建一个行框？如何逐步构建一个行框，通过此过程了解一行的各个部分是如何组合在一起，共同确定其高度的？通过以下步骤确定行内每个元素的行内框的高度： 得到各行内非替换元素以及不属于后代行内元素的文本的font-size和line-height的值。line-height减去font-size，得到框的行间距。行间距 一分为二，将其分别应用到 em 框的顶部和底部。 得到各个非替换元素的heihgt,margin-top,margin-bottom,padding-top, paddding-bottom,border-top-width,border-bottom-width的值，并把它们加起来。 对于各内容区，确定有多少内容在整行基线之上和之下。这各任务并不容易：你必须知道每个元素和匿名文本段的基线的位置以及该行本身的基线位置，然后把它们对齐。另外，对于替换元素，要将其底部放在整个行的基线上。 对于指定了vertical-align的元素，要确定其垂直偏移量。它将告诉你元素的行内框向上或向下移动了多远，并且它将改变元素在基线之上或之下多少。 现在已经知道所有行内框的位置，接下来 计算最终的行框高度。为此，只需要将基线与最高行内框顶部之间的距离 与 基线与最低行内框底部之间的距离 相加即可。 行内格式化（Inline Formatting） 所有元素都有line-height,不管是否显示声明。这个值极大地影响了行内元素的的显示方式。 一行的高度（或行框的高度）是由其组成元素和其他内容（如文本）的高度决定的。 line-height实际上只影响行内元素和其他行内内容，而不影响块级元素，至少不是直接影响。 可以给一个块级元素设置line-height，并将该值用于到块中的所有内容，不论内容是否包含在行内元素中。但是只有在块级元素中有内联内容是才会由视觉效果。1&lt;p style=&quot;line-height: 2em;&quot;&gt;&lt;/p&gt; 由于没有内容去创建一个行框，段落也没有任何显示。 从某种意义上块级元素中包含的每一行文本都是行内元素，而不乱 它是否被标签包围其来。如果你喜欢，可以想象一个虚构的标签序列 ，如下：12345&lt;p&gt; &lt;line&gt;This is a paragraph with a number of&lt;/line&gt; &lt;line&gt;lines of text which make up the &lt;/line&gt; &lt;line&gt;conents.&lt;/line&gt;&lt;/p&gt; 尽管line标签实际并不存在，但段落行为就像它们存在一样。每一行文都从段落继承了其样式。所以，只需给块级元素创建line-height规则，就不必显示的为它们的所以行内元素声明line-height. 行内非替换元素（Inline Nonrepalced Elements）构建只包含 不可替换元素（或匿名文本）的行。这样可以很好的理解行内布局中不可替换元素和可替换元素之间的区别。 建立框 （Building the Boxes）对于行内非替换元素或匿名文本某一部分，font-size的值确定了内容区的高度。line-height确定了行内框的高度。 123456&lt;p style=&quot;font-size: 12px; line-height: 12px;&quot;&gt;This is text, &lt;em&gt;some of which is emphasized&lt;/em&gt;, plus other text&lt;br&gt;which is &lt;strong style=&quot;font-size: 24px;&quot;&gt;strongly emphasized&lt;/strong&gt;and which is&lt;br&gt;larger than the surrounding text.&lt;/p&gt; 上例中，大多数文本font-size都是 12px，只有一个行内非 替换元素font-size是 24px。因为line-heihgt是继承属性，所以strong元素的line-height也是 12px，则其行内框高度为 12px,即 12px 高的行内框在元素内容区(24px)中垂直居中，行内框实际小于内容区。到目前为至，似乎我们对每个文本都做了相同的处理，所有的行内框大小相同。但这并不完全正确。因为文本都是按基线对齐的，所以第二行虽然行内框大小相同，但排列的并不整齐。由于行内框的顶部位于元素的内容区内，因此元素的内容溢出到行框之外，并于其他行框重叠。 垂直对齐（Vertical Alignment）如果改变行内框的垂直对齐方式，会应用相同的高度确定原则。假设上例strong元素指定垂直对齐为 4px: 123456&lt;p style=&quot;font-size: 12px; line-height: 12px;&quot;&gt;This is text, &lt;em&gt;some of which is emphasized&lt;/em&gt;, plus other text&lt;br&gt;which is &lt;strong style=&quot;font-size: 24px; vertical-align: 4px;&quot;&gt;strongly emphasized&lt;/strong&gt;and which is&lt;br&gt;larger than the surrounding text.&lt;/p&gt; 此小改动会把strong元素上升 4px,会同时提升内容区和行内框。由于strong元素的行内框顶端已经是行中的最好点，垂直对齐这个修改会把整个行框的顶端也上移 4pxvertical-align各个关键字值的效果描述如下： top, 将元素行内框顶部与包含它的行框顶部对齐 bottom, 将元素行内框底部与包含它的行框底部对齐 text-top, 将元素行内框与父元素的内容区顶部对齐 text-bottom, 将元素行内框与父元素的内容区底部对齐 middle, 将元素行内框的垂直中点与父元素基线上 0.5ex 处对齐 super,将元素行内框和和内容区上移。具体距离，不同浏览器各部相同 sub，同super相同，元素行内框和内容区下移。 &lt;percentage&gt;,将元素上移或下移一定的距离，这个距离通过元素line-height值的声明百分比来确定。 管理行高（Managing line-height）改变一个行内元素的line-height可能导致文本行相互重叠，不过，在所有情况下，这种修改都是针对单个元素的。所有如何以一种更普遍的方式影响元素的line-heght而避免内容重叠呢？ 对 font-size有改变的元素结合使用em单位。 1234567891011121314p &#123; font-size: 14px; line-height: 1em;&#125;p big &#123; font-size: 250%; line-height: 1em;&#125;&lt;p&gt; Not only does this paragraph have &quot;normal&quot; text, but it also&lt;br&gt; contains a line in which &lt;big&gt;some big text&lt;/big&gt; is found.&lt;br&gt; This large text helps illustrate our point.&lt;/p&gt; 通过给big元素设置line-height，就提高了行框的总高度，从而提供足够的空间来显示big元素。line-height中的em是相对于元素本身的font-size设置的，而不是相对于父元素设置 line-height的值作为缩放因子，且是一个继承值而非计算值。它会在元素间逐层传递，在各层上，这个因子与各元素的font-size相乘，结果就是各元素的line-height. 1234567p &#123; font-size: 14px; line-height: 1.2;&#125;big &#123; font-size: 250%;&#125; 如果在增加边框，问题会更复杂,只需要足够大的line-height来容纳这个边框即可。 基线与行高每个行框的实际高度取决于其组成元素彼此之间如何对齐。这种对齐方式很大程度上依赖于基线在每个元素（或匿名文本）中的位置。，因为这个位置决定； 行内框的如何摆放。每个 em 框中基线的位置对于每种字体都是不同的。这各信息内置在字体文件中，除非直接编辑字体文件，否则不能通过任何方式更改。 增加边框属性（Adding Box Properties） padding,margin,border都可以应用于行内非替换元素，但这些方面不会影响到行内元素的行框高度。 行内元素的border边界由font-size控制，而不是line-height。换句话就，如果一个span元素font-size是 12px,line-height是 36px，其内容区就是 12px,border将包围这个内容区。 可以为行内元素指定padding,这会使border远离文本本身。注意，这个padding并没有改变内容区高度的具体形状，因此它也不会影响这个元素的行内框的高度，类似的，向行内元素添加border也不会影响行框的生成和布局 至于margin,实际上，它不应用于行内非替换元素的顶部和底部，也就不影响行框的高度，但是会影响行内元素的两端。 行内元素基本上会作为单行布局的，然后被分解成多个部分。所有，向一行内元素应用margin，这些margin只会出现在其开始和末尾，分别是margin-left,margin-right，padding也是如此。尽管padding,margin不影响行高，但是它们仍然能 影响一个元素的布局，通过将文本推、离其左右两端。实际上，负的margin，可能会把文本拉近，甚至导致重叠 CSS2.1 明确指出行框按文档属性绘制，“这会导致后续行的边框在前面行的边框和我文本上绘制/覆盖” 字形和内容区（Glyphs, Content Area）一个字体的 em 框与其字符字形之间可能存在差别，对于大多数字体，其 em 框的高度与字符字形的高度都不一致。一个行内非替换元素的“绘制区”由用户代理（浏览器）决定。如果一个用户代理使用 em 框的高度作为内容区的高度，那么行内非替换元素的背景就与 em 框的高度相同（即 font-size 的值）。如果用户代理使用字体的最大上升变形和下降变形，背景就可能比 em 框高或低。 行内替换元素 一般认为行内替换元素（如 img）有固有的高度和宽度。它可能导致行框比正常的要高，但这不会改变行中的任何元素的line-height值，包括替换元素本身。相反，只会让行框的高度恰好能包含替换元素（已经任何框属性）。换句话就，会用替换元素的整体（包括内容、padding、border、margin）来定义元素的行内框 行内替换元素有一个line-height的值，在垂直对齐时需要它来正确地地位元素，vertical-aline 的百分比值要相对于元素的line-height来计算的 增加框属性 padding，border像平常一眼样应用到行内替换元素：padding在具体内容外插入空间，border围绕着padding。**padding,border确实会影响行框的高度，因为它们是行内替换元素的行内框的一部分。** margin也包含在行框中，正margin使替换元素的行内框更高。负margin会减少行内框的大小，使行内替换元素挤入其他行 替换元素和基线（Relpaced Elements and the Baseline） 替换元素并没有自己的基线，相对来讲最好的办法就是将其行内框的底部与基线对齐，实际上，就是下外边距的边界与基线对齐 只要一个行内替换元素是 块级元素或表单元格元素中的唯一后代，替换元素都会生成行框，并且替换元素（如图像）放在基线上 负margin 会使行内替换元素向下拉 行内块元素（Inline-Block Elements） 行内块元素作为一个行内框与其他元素和内容相关，它就像一个图像一样放在一个文本行中，实际上，行内块元素会作为替换元素放在行中。这就意味着，行内块元素的底端默认地位于文本行的基线上，而且内部没有行分隔符。 在行内块元素的内部，其内容像块级元素一样被设置。就像所有块级元素和行内替换元素一样，行内块元素也有width,heihgt属性，如果其比周围的内容高，这些属性会使行高增加。 如果行内块元素的width未定义，或显式声明未auto，元素框将收缩以适应内容，即元素框的宽度刚好足够包含该内容，没有多余空间。行内框也是如此，不过行内框可以跨多个文本行（同其他行内容覆盖），但行内块元素不会 Flow DisplayContents Display计算值（Computed Values）如果元素是浮动元素或定位元素，display的计算值会改变。实际上，display,position,float值会相互影响。 小结（Summary）display属性指定了元素的显示类型，包含两类基础特征： 外部显示类型：用于指定元素怎样生成盒模型，定义了元素怎样参与流式布局/文档流的处理。例如block,inline,run-in 内部显示类型：定义了元素内子元素的布局方式。例如flow,table,flex,grid","categories":[{"name":"技术总结","slug":"技术总结","permalink":"https://better-jiang.github.io/categories/%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%93/"}],"tags":[{"name":"css","slug":"css","permalink":"https://better-jiang.github.io/tags/css/"}]},{"title":"CSS知识点梳理(6)-文本属性","slug":"CSS知识点梳理-6-文本属性","date":"2019-12-16T07:11:46.000Z","updated":"2023-02-03T12:14:22.417Z","comments":true,"path":"2019/12/16/CSS知识点梳理-6-文本属性/","link":"","permalink":"https://better-jiang.github.io/2019/12/16/CSS%E7%9F%A5%E8%AF%86%E7%82%B9%E6%A2%B3%E7%90%86-6-%E6%96%87%E6%9C%AC%E5%B1%9E%E6%80%A7/","excerpt":"","text":"缩进首先确定本章用的block direction,inline direction两个术语。 块方向(block direction): 是当前写入模式中默认放置块元素的方向，在英语中，从上到下 内联方向（inline direction）：在一个块中吸入内联元素的方向，在英语中，从左到右。 text-indent1234567values: &lt;length&gt; | &lt;percentage&gt;Initial value: 0Applies to: 块元素Precentages: 相对于包含块的宽度Computed value: 百分百的值，如所指定，也是百分百;长度单位，则是绝对长度Inherited： YesAnimatable： Yes 通常，可以text-index应用于生成块框的任何元素，并且在内联方向上缩进。不能将其应用于内联元素或替换元素，例如img,然而，如果在块级元素的第一行中有图像，则该图像与该行中的其余文本一起缩进。 如果想要‘缩进’ 内联元素的第一行，则可以是使用padding-left或margin-left来创建效果。 text-indent仅应用于元素的第一行，即使插入了换行符。 text-align12345Values: start|end|left|right|center|justify|match-parentInitial value: CSS3: start. CSS2.1: 用户代理指定Applies to: Block-level elementsComputed value: 给定的值Inherited： Yes 在 CSS3 中，left,right分别映射到start，end的边缘。 text-align不控制元素的对齐，它仅是控制块级元素内的内联内容.且是在水平方向上的。 内联对齐（Inline Alignment），“垂直对齐”上面我们介绍了沿内联方向（inline direction）的对齐方式，现在要介绍沿块级方向（block direction）进行内联元素的垂直对齐方式。 line-height123456Values: &lt;number&gt;|&lt;lenght&gt;|&lt;percentage&gt;|normalInitial Value: normalAllies to: All elements(常见于块级元素或替换元素的文本)Percentages: 相对于元素的字体大小Inherited： YesAnimatable； Yes line-height属性是指文本行的基线之间的距离（the distance between the baselines of lines of text），而不是字体的大小。它确定增加或减少每个元素框（element’s box）的高度的数值。 line-height控制着行间距（leading）.行距是超出字体大小的文本行之间多余的空间。换句话讲，就是line-height值和字体大小之间的差距。 line-height当应用于块级元素时，它指定了该元素内 文本基线之间的最小距离。文本基线是可变的。 行的组成 一行文字中的每一个元素都会生成一个内容区域（content area），它是由字体大小决定。 反过来，此内容区域会生成一个行内框（inline box）。行内框在没有任何其他因素的情况下，与内容区域完全相同。行间距（leading)是由line-height增加或减少了行内框的高度所产生的。 确定元素的行间距: line-height计算值 减去 font-size计算值。这个值可以是负数。然后将行间距一分为二，加在内容区域的顶部和底部,就是该元素的行内框了。 每一行都有一个隐藏的行框，行框的高度由行内框决定，行框的高度需要将最高行内框的底部和最低行内框的底部刚好包裹起来。 一些术语基本定义 line-height： 文本行基线之间的距离，而不是字体大小 content area(内容区): 非替换行内元素，内容区是由元素中字符生成的框；替换元素中，内容区的高度是元素的高度+内外边距+边框值 leading(行间距)：line-height与font-size值之差。这个值一分为二，分别添加到内容区的顶部和底部。行间距只应用于非替换元素。 inline box(行内框): 行内框是通过向内容区域增加行间距来描述的。非替换行内元素，行内框的高度刚好等于line-height的值；替换元素，元素的行内框高度恰好等于内容区的高度，因为行间距不应用到替换元素。 vertical-align相对于行框的“垂直”对齐方式，即沿块/垂直方向如何放置它们。在 CSS 中，vertical-align属性仅应用于行内元素和可替换元素（如，images, form inputs）. vertiacl-align是不可继承属性 1234567Values: baseline|sub|supper|top|text-top| middle|bottom|text-bottom|&lt;length&gt;|&lt;percentage&gt;Initial value: baselineApplies to: inline elelents, table cells, replaced elementsPercentages: 相对于该元素的`line-height`Inherited: NoAnimatable: &lt;length&gt;,&lt;percentage&gt; baseline: 元素基线与其父元素的基线对齐。如果元素没有基线，比如可替换元素 images，fomr input，那么该元素的底部与父元素的基线对齐。 sub/supper: 元素的基线（或底，如果是替换元素）位于父元素的基线下面/上面。 bottom: 将元素的底部与行框的底部对齐 bootom-text: 将元素的底部与文本框（text box：父元素的字体大小）的底部对齐 middle: 通常用于images。是内联元素的中间比父元素的基线高出0.5ex。ex：字母x的高度。 &lt;percentage&gt;: 元素的基线（或替换元素的底部）同父元素基线相比，升高/降低的百分百。该百分百是相对于元素的line-height，而不是父元素。 &lt;length&gt;: 将元素上移或下移声明的距离。重要点： 垂直对齐的文本不会成为另一行的一部分，也不会与其他行中的文本重叠。任何垂直对齐的元素都会影响到行框的高度，因为他是最高行内框的顶部与最低行内框的底部之间的间距 单词间距（word Spacing）/ 字母间距（Leter Spacing）1234567 word-spacing / letter-spacingValues: &lt;length&gt;|normalInitial value: normal (0)Applies to: All elementsInherited: YesAnimatable: Yes 间距和对齐 （Spacing and Alignment）需要注意的，-spacing空间的计算值是继承的，因此具有较大或较小文本的子元素和其父元素的间距一致，看起来很不协调 text-transform123456Values: uppercase|lowercase|capitalize|noneInitial value: noneApplies to: All elementsComputed value: As specifiedInherited: YesAnimatable: No capitalize,CSS 仅要求浏览器确保每个单词的首字母大写，忽略单词其余部分。 text-decoration12345Values: none|[underline||overline||line-through||blink]Initial value: noneApplies to: All elementsInherited: NoAnimatable: No 一些怪异情况： text-decoration是不可继承的。文本的装饰线与父元素具有相同的颜色，即使子元素设置了不同的颜色。所以也要在子元素设置text-decoration: none来清除。 text-decoration与vertical-align一起使用时，也经常出现怪异情况。例如，sup 元素本身没有装饰线，但由于在有上划线的元素升高，因此上划线也’切入‘了 sup 元素中间。 text-shadow12345values: h-showdow v-showdow blur-radius color | noneInitial vlaue: noneApplies to: All elementsInherited: NoAnimatable: Yes 默认情况下文本没有阴影。但可以定义一个或多个阴影。阴影定义：水平阴影位置，垂直阴影位置，模糊半径，阴影颜色。前 2 个必须，后 2 个可选。模糊半径默认值为 0，阴影颜色默认值为文本颜色。 **注意：大量的文本阴影或具有非常大的模糊半径的文本，会导致性能下降，特别是在低功耗和 CPU 受限的情况下（如移动设备）。 white-space12345Values: normal|nowrap|pre|pre-wrap|pre-lineInitial value: normalApplies to: All elementsInherited: NoAnimatble: No white-space属性，影响浏览器如何处理单词和文本行之间的空白。 normal: 丢弃额外的空格。换行符被转换为空格，多个空格被转换为单个空格。 nowrap: 阻止文本在元素中换行，除非使用&lt;br&gt;。 pre：同在pre元素中一样，保留空格和换行符。 pre-wrap: 保留空白符序列，但正常的进行换行。 pre-line： 合并空白符序列，但是保留换行符。 Value Whitespace(空白符序列) Line feeds(换行符) Auto line wrapping(自动换行) normal Collapsed Ignored Allowed nowrap Collapsed Ignored Prevented pre Preserved Honored Prevented pre-wrap Preserved Honored Allowed pre-line Collapsed Honored Allowed 换行与连字符hyphens12345Values: manual|auto|noneInitial value: manualApplies to: All elementsInherited: YesAnimatabale: No hyphens告知浏览器在换行时如何使用连字符连接单词。可以完全阻止使用连字符，也可以控制浏览器如何使用。 word-break12345Values: normal|break-all|keep-allInitial value: normalApplies to: All elementsInherited: YesAnimatable: Yes 当文本太长而不能放在一行时，会自动换行（soft warpped）。换行符、&lt;br&gt;则是硬换行（hard wraps）。 normal: 文本正常换行，在单词之间（英文中，有空格）断行。 break-all: 在任何 2 个字符之间都可以断行，即使在一个单词中间 keep-all： 阻止换行。同white-space:pre类似.对于 CJK(中文、日文、韩文)文本不断行。Non-CJK 文本表现同normal。 Value Non-CJK CJK Hyphenation permitted normal As usual As usual Yes break-all After any character After any character No keep-all As usual Around sequences Yes line-breakoverflow-wrapwriting Modeswriting-modetext-orientationdirection / unicode-bididirection,inicode-bidi这一对属性可以通过改变内联基线的方向来改变文本的方向。CSS 规范警告在 HTML 文档中不要使用direction，unicode-bidi属性，因为用户可以关闭 CSS 样式，建议使用 HTML&lt;bdo&gt;标签，dir属性。 12&lt;!-- bod stands fo Bi-Directional Override --&gt;&lt;bdo dir=&quot;rtl&quot;&gt;This text will go right-to-left&lt;/bdo&gt;","categories":[{"name":"技术总结","slug":"技术总结","permalink":"https://better-jiang.github.io/categories/%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%93/"}],"tags":[{"name":"css","slug":"css","permalink":"https://better-jiang.github.io/tags/css/"}]},{"title":"webpack梳理","slug":"webpack梳理","date":"2019-12-13T03:17:26.000Z","updated":"2023-02-03T12:14:22.417Z","comments":true,"path":"2019/12/13/webpack梳理/","link":"","permalink":"https://better-jiang.github.io/2019/12/13/webpack%E6%A2%B3%E7%90%86/","excerpt":"","text":"核心概念本质上,webpack 是一个 JavaScipt 应用程序的静态模块打包器,它递归地构建一个依赖关系图,其中包含应用程序需要的每个模块,然后将所有这些模块根据配置打包成一个或多个包（bundle）. 模块(modules)在模块化编程中,将程序分解成离散功能的块,称之为模块.每个模块比完整程序更小的接触面,使得校验,调测,测试更容易.在 webpack 中,模块可是是 js 文件,npm 包,图片,css/sass/less 文件.以如下方式方式表达它们的依赖关系: ES2015 import 语句 CommonJS require() 语句 AMD define 和 require 语句 css/sass/less 文件中的 @import 语句 css 样式中url()或 HTML 中&lt;img src=&quot;&quot;&gt;中的图片链接 包(bundle)：包由许多不同的模块生成，是已经加载和编译过的源文件的最终版本，用于代码合并和分隔。 依赖关系图(dependency graph)当一个文件依赖另一个文件时,webpack 就认为该文件之间有依赖关系.这使得 webpack 可以接收非代码资源(如图像或自定义字体),并把它们当作依赖提供给应用程序.webpack 从入口起点开始,递归的构建一个依赖图,其包含着所需的每个模块,然后将这些模块打包为 bundle,可由浏览器加载. 配置(configuration)webpack 配置文件，是导出一个对象的 JavaScript 文件。由 webpack 根据该对象定义的属性进行解析。因为 webpack 配置是标准的 Node.js CommonJS 模块，所以： 通过 require() 导入其他文件 通过 require() 使用 npm 的工具函数 使用 JavaScript 控制流表达式 对常用值使用常量或变量 编写并执行函数来生成部分配置 块 (chunk)：是 webpack 中特定术语，在内部用于管理打包过程。包由块组成，块有几种类型（如 entry 和 child），通常块直接输出对应的包，但是有些配置不会产生一对一的关系。 入口起点(entry points)在 wepack 配置中定义的 entry 属性。 简单语法 entry: string|Array&lt;string&gt; 对象语法 entry:&#123;[entryChunkNume:string]: string|Array&lt;string&gt;&#125; 输出(output)在配置中定义的 output 属性，它控制 webpack 像硬盘写入编译文件。多个入口起点，可以只指定一个输出配置。output 属性的最低要求，将它设置为一个对象，包含filename,输出文件名和path,输出目录，绝对路径。如果配置了多个入口起点，创建了多个单独的“chunk”,则应该使用占位符来确保每个文件具有唯一的名称. 1234567891011&#123; entry: &#123; app: &#x27;./src/app.js&#x27;, search: &#x27;./src/search.js&#x27; &#125;, output: &#123; filename: &#x27;[name].js&#x27;, path: _dirname + &#x27;/dist&#x27; &#125;&#125;// 输入: ./dist/app.js ./dist/search.js 模块转换器(loader)loader 可以将所有类型的文件转化为 webpack 能够处理的有效模块（JavaScript），然后打包处理。本质上，就是将所有类型的文件，转化为应用程序的依赖图（和最终的 bundle）可以直接引用的模块。配置中 loader 有两个目标： test 属性，标识出某个或某些文件要被 loader 进行转换 use 属性，进行转换时，应该使用哪个 loaderloader 要定义在module.rules中，而不是rules中。123456789&#123; entry:&#123;&#125;, output:&#123;&#125;, module: &#123; rules: [ &#123;test:/\\.txt$/, use:&#x27;raw-loader&#x27;&#125; ] &#125;&#125; webpack 编译器，当碰到[require(),import 语句中被解析为’.txt’的路径]时，在打包之前，先用raw-loader转换。 扩展插件(plugin)webpack 插件是一个具有apply属性的 JavaScript 对象，apply 属性会被 webpack commpiler 调用，并且 compiler 对象可在整个编译生命周期访问。在 webpack 运行时的生命周期中会广播许多事件，plugin 可以监听这些事件，并在合适的时机通过 webpack 提供的 API 改变输出结果。 模式（mode）webpack4 默认不需要配置文件，可以通过 mode 选项为 webpack 指定一些默认的配置。mode 分为development/production compiler/compilation compiler 对象，包含了 webpack 环境所有的配置信息（options,loader,plugins），这个对象在 webpack 启动时被实例化，且是全局唯一的，可简单立理解为 webpack 实例。代表整个 webpack 从启动到关闭的生命周期 compliation 对象包含了当前的模块资源、编译生成资源、变化的文件等，当 webpack 以开发模式运行时，每当检测到一个文件变化，就有一次新的 compilation 被创建。compilation 对象也提供了许多事件回调供插件做扩展，通过 compilation 也能读取到 compiler 对象。只代表一次新的编译 webpack 构建流程webpack 的构建流程可分三大阶段： 初始化： 启动构建，读取于合并配置参数，加载 plugin，实例化 compiler。 编译：从 entry 出发，针对每一个 module串行调用对应的 loader 取转换文件，再找到该 module 依赖的 modular，递归地进行编译处理 输出：对编译后的 module 组合成 chunk,把 chunk 转换成文件，输出到文件系统 具体流程概况webpack 的运行流程是一个串行过程 初始化参数：从配置文件或者命令行中读取、合并参数，得出最终配置的参数。 开始编译：用最终的配置参数初始化 compiler 对象，加载所有配置的插件，执行对象的run方法开始编译。 确定入口：根据配置中的 entry 找出所有的入口文件。 模块编译：从入口文件出发，调用所有配置的 loader 模块进行转换，再找出该模块依赖的模块，再递归本步骤直到所有入口依赖的文件都经过处理。 完成模块编译：在经过第四步使用 loader 转换完成所有模块后，得到每个模块转换后的最终内容和它们之间的依赖关系。 输出资源：根据入口和模块之间的依赖关系，组装成一个个包含多个模块的 chunk，再把每个 chunk 转换成一个单独的文件加入到输出列表。 输出完成：在确定好输出内容后，根据配置确定输出的路径和文件名，把文件内容写入到文件系统。 在以上过程中，webpack 会在特定的事件点广播出特定的事件，plugin 在监听到事件后会执行特定的逻辑，且可以调用 webpack 提供的 api 改变 webpack 运行结果 参考文章webpack 原理解读webpack 原理，实现 loader、plugin","categories":[{"name":"技术总结","slug":"技术总结","permalink":"https://better-jiang.github.io/categories/%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%93/"}],"tags":[{"name":"webpack","slug":"webpack","permalink":"https://better-jiang.github.io/tags/webpack/"}]},{"title":"CSS知识点梳理(5)-字体","slug":"CSS知识点梳理-5-字体","date":"2019-12-12T08:06:17.000Z","updated":"2023-02-03T12:14:22.417Z","comments":true,"path":"2019/12/12/CSS知识点梳理-5-字体/","link":"","permalink":"https://better-jiang.github.io/2019/12/12/CSS%E7%9F%A5%E8%AF%86%E7%82%B9%E6%A2%B3%E7%90%86-5-%E5%AD%97%E4%BD%93/","excerpt":"","text":"字体系列（Font Families）5 种通用字体系列 Serif fonts：字体成比例（即，所有的字符由于大小不同而具有不同的宽度）且有衬线（即，字符笔画末端的描边修饰）。Times,Gergia,New Century Schoolbook. Sans-serif fonts: 字体成比例但没有衬线。Helvetica,Geneva,``Arial,Univers`. Monospace fonts: 字体不成比例，等宽。通常用于显示编程代码和表格数据。Courier,Courier New,Consolas. Cursive fonts: 模拟人手写或书写。通常有流动的曲线组成，具有超过衬线的描边修饰。Zapf Chancery,Comic Sans. Fantasy fonts： 不属于以上 4 类的字体。 使用通用字体系列如果想使用sans-serif无衬线字体，但并不在乎具体哪一个，可以这样声明： 123456789101112body &#123; font-family: sans-serif;&#125;h1, h2, h3 &#123; font-family: serif;&#125;code, pre, tt, kbd &#123; font-family: monospace;&#125;p.signature &#123; font-family: cursive;&#125; 指定字体系列123h1 &#123; font-family: Georgia, serif;&#125; 使用Georgia字体（如果可用），如果不可用，则使用serif通用字体。 123p &#123; font-family: Times, &#x27;Times New Roman&#x27;,&#x27;New Century Schoolbook&#x27;, serif;&#125; 浏览器将按字体的列出的顺序查找字体，如果列出的字体不可用，则使用serif通用字体。 如果指定的字体名称包含空格或者#,$等符号，或者名称同通用字体相同时，需要使用引号包裹。 使用@font-face@font-face允许我们自定义特定的字体。 1234567891011@font-face &#123; font-family: &quot;jiangjiang&quot;; src: local(&quot;jiangjiang&quot;), /* 在本地安装的字体寻找 */ url(&quot;jiangjiang.eot&quot;), /*浏览器支持EOT文件，IE6-IE9 兼容模式下 */ url(&quot;jiangjiang.eot?#iefix&quot;) format(&quot;embedded-opentype&quot;), /* IE6-IE8 */ url(&quot;jiangjiang.woff&quot;) format(&quot;woff&quot;), /* wpff文件，大部分现在浏览器都支持，桌面用户 */ url(&quot;jiangjiang.ttf&quot;) format(&quot;turetype&quot;), /* 大部分IOS和安卓设备 */ url(&quot;jiangjiang.svg#jiangjiang&quot;) format(&quot;svg&quot;); /* 老旧的IOS设备 */&#125;p &#123; font-family: jiangjiang, Helvetica, sans-serif;&#125; 以上示例：自定义字体名称jiangjiang,先在本地安装的字体寻找.如果没有，则使用url()按顺序尝试下载远端的字体。定义好之后就可以使用该字体了。format()告诉浏览器所使用的字体类型，跳过不支持的格式文件的下载，从而降低带宽提高加载速度。src()中的 URL 是有同源策略限制，不能跨域下载字体文件。解决方法:1.将字体文件拷贝到自己的服务器 2.使用同时提供样式表和字体文件的字体托管服务。 识别的字体格式值(format()) Value Format opentype OTF(OpenType) embedded-opentype ETO(Embedded OpenType) svg SVG(Scalable Vetor Graphics) truetype TTF(TrueType Format) woff WOFF(Web Open Font Format) font-weight12345Values: normal|bold|bolder|lighter|100-900Initial value: normalApplies to: All elementsInherited: YesAnimatable: No 常见的字重数值大致对应的自重描述词，有些字体可能有差别 font-weight Description 100 Thin 200 Extra Light(Ultra Light) 300 Light 400 Regular(Normal) 500 Medium 600 Semi Bold(Demi Bold) 700 Bold 800 Extra Bold(Ultra Bold) 900 Black(Heavy) 通常字体至少必备 400(normal)和 700(bold)这两个字重值。如果出现指定的字重值在字体中找不到直接对应的字重，则按一些规则： 指定字重小于 400,首先降序查找小于指定字重的各个字重，之后升序查找大于指定字重的各个字重，直到找到匹配的字重。 指定字重大于 500，首先升序查找大于指定字重的各个字重，之后降序查找小于指定字重的各个字重，直到找到匹配的字重。 指定字重等于 400，先匹配 500 对应的字重，若没有，则执行第一条小于 400 的规则。 指定字重等于 500，先匹配 400 对应的字重，若没有，则执行第一条小于 400 的规则。 假设某字体库内字重分 3 阶(400,700,900) 字体库内直接匹配的字重 通过规则计算间接匹配的字重 400 300,200,100,500 700 600 900 800 举例font-weight:300，字体库没有直接匹配的字重，且小于 400，根据第一条规则，先降序查找匹配，都没有，在升序查找到 400，则可以匹配。 lighter,bolder,与从父元素继承而来的font-weight值进行比较。 font-size绝对大小 keyword CSS1 CSS2 CSS3 xx-small 5px 9px 10px x-small 7px 11px 12px small 11px 13px 14px medium 16px 16px 16px large 24px 19px 19px x-large 36px 23px 24px xx-large 54px 28px 32px 相对大小larger,smaller，相对于父元素，使用相同的比例因子（通常 1.2）来计算绝对大小，并在绝对大小范围内向上或向下移动 百分比根据从父元素继承的大小来计算 继承font-size继承的是计算值，不是百分比。字体的相对大小、百分比在继承时是累加的。 1234567891011121314151617181920212223242526272829303132333435&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot; /&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot; /&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot; /&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; .one &#123; font-size: 20px; &#125; .two &#123; font-size: larger; &#125; .three &#123; font-size: 200%; &#125; .four &#123; font-size: 25%; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div class=&quot;one&quot;&gt; 1 &lt;div class=&quot;two&quot;&gt; 2 &lt;div class=&quot;three&quot;&gt; 3 &lt;div class=&quot;four&quot;&gt;4&lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt; one： 20px; two: 20px 的在 CSS3 中绝对大小的更大一级 是x-larger，24px three: 24px * 200% = 48px four: 48px * 25% = 12px font-style1234Values: italic | oblique | normalInitial value: normalInherited: YesAnimatable: No font-stretch123456Values: normal | ultra-condensed | extra-condensed | condensed | semicondensed | semi-expanded | expanded | extra-expanded | ultraexpandedInitial value: normalInherited: YesAnimatable: No 只要在使用的字体系列定义了更宽或更窄的字体时，这个属性才会其作用，但大多数情况下并不是。 font variant字体变体，对应的 CSS 属性font-variation-*,包括链接（ligatures）,大写（caps）,数字（numerals）,替代字形（alternate glyphs）。使用@supports特性查询来判断浏览器是否支持。使用font-feature-settings来兼容低版本。 font-variant-ligatures:字母的连接样式，防止难看的字母碰撞 common-ligatures， 激活连接 no-common-ligatures，禁用连接 font-variant-positon: 实现 sub 和 sup 效果。 sub, 下标 supper,上标 font-variant-caps: 控制字母大写 small-caps, 替换小写字母为小的大写字母，原来的大写字母不变。 all-small-caps，将所有字母都变成小的大写字母。 font-variant-numeric: 对数字类型的处理。 lining-nums，默认值。数字近似大写字母，高度一致。用于标题或表格中的数字。 oldstyle-nums,更类似于小写字母,有不同的高度和对其方式 tabular-nums,在数据表格中使用，以允许数字垂直对齐 proportional-nums,数字具有可变的间距，并于水平文本融合。 diagonal-fractions,分数以小数的形式显示 ordinal，像1st,2nd,3rd,4th一样，以序号显示，标准的小写字母 slashed-zero,用带斜线的 0，来替换 0 字符","categories":[{"name":"技术总结","slug":"技术总结","permalink":"https://better-jiang.github.io/categories/%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%93/"}],"tags":[{"name":"css","slug":"css","permalink":"https://better-jiang.github.io/tags/css/"}]},{"title":"CSS知识点梳理(4)-值和单位","slug":"CSS知识点梳理-4-值和单位","date":"2019-12-10T06:53:50.000Z","updated":"2023-02-03T12:14:22.417Z","comments":true,"path":"2019/12/10/CSS知识点梳理-4-值和单位/","link":"","permalink":"https://better-jiang.github.io/2019/12/10/CSS%E7%9F%A5%E8%AF%86%E7%82%B9%E6%A2%B3%E7%90%86-4-%E5%80%BC%E5%92%8C%E5%8D%95%E4%BD%8D/","excerpt":"","text":"关键字、字符串、其他文本值关键字在需要用某种类型的单词来描述值的时候，那个单词就是关键字。例如none 全局关键字CSS 定义了每个属性都给以接受的三个全局关键字:inherit、initial、unset. inherit: 使元素上的属性值与其父元素上的属性值相同。 1234567&lt;div id=&quot;toolbar&quot;&gt; &lt;a href=&quot;one.html&quot;&gt;One&lt;/a&gt; | &lt;a href=&quot;two.html&quot;&gt;Two&lt;/a&gt; | &lt;a href=&quot;three.html&quot;&gt;Three&lt;/a&gt; &lt;/div&gt;#toolbar &#123;background: blue; color:white;&#125; // a链接 颜色，默认样式#toolbar a &#123;color: inherit;&#125; // a链接，颜色 继承自父元素 initial: 重置元素的属性值为默认值。 unset: 是inherit和iniital的通用替身。如果属性可继承，则unset效果与使用inherit相同。如果属性不可继承，则效果与使用initial相同。 all一个特殊的属性，它的值只接受全局关键字 (inherit | initial | unset )all是所有属性的替代，除了direction和unicode-bidi.如果一个元素声明了all: inherit, 则其所有属性的值都从其父元素继承，除了direction和unicode-bidi 。 123&lt;section&gt; &lt;div id=&quot;example&quot;&gt;This is a div&lt;/div&gt;&lt;/section&gt; Strings字符串值用单引号或双引号包装的任意字符序列，用&lt;string&gt;的值来表示 URLs在@import声明中，导入外部样式表是用到。注意：在 CSS 中，相对 url 是相当样式表本身的，而不是相当于使用样式表的 HTML 文档 12@import url(protocol://server/pathname); /* 绝对路径 */@import url(pathname) /* 相对路径 */ Imagesimage 值是对图像的引用 &lt;url&gt;: 外部资源标识符，在本例中，就是图像的 url &lt;image-set&gt;: 一组图像，根据嵌入值中的条件来选择。例如image-set()可以指定大的突图像应用于桌面布局，小的图像应用于移动设计。类似于图像元素的 srcset 属性。 1234567891011121314151617181920 // 1x 2x 表示：像素密度 .imageSet &#123; width: 300px; height: 400px; background: -webkit-image-set(url(https://mat1.gtimg.com/www/images/qq2012/qqlogo_1x.png) 1x, url(https://mat1.gtimg.com/www/images/qq2012/qqlogo_2x.png) 2x); background-repeat: repeat-y;&#125; &lt;img src=&quot;https://mat1.gtimg.com/www/images/qq2012/qqlogo_1x.png&quot; srcset=&quot; https://mat1.gtimg.com/www/images/qq2012/qqlogo_1x.png 1x, https://mat1.gtimg.com/www/images/qq2012/qqlogo_2x.png 2x &quot; /&gt; &lt;img src=&quot;https://mat1.gtimg.com/www/images/qq2012/qqlogo_1x.png&quot; srcset=&quot; https://mat1.gtimg.com/www/images/qq2012/qqlogo_1x.png 325W, https://mat1.gtimg.com/www/images/qq2012/qqlogo_2x.png 375W &quot; /&gt; &lt;gradient&gt;: 指一个线性或经向的梯度图像。 分数值（弹性值）（Fractions）分数值（弹性值）是一个后跟标签fr。这是在网格布局中引入的概念，用于划分布局中无约束空间的部分。 距离绝对长度单位 Inche (in)英寸，1in = 2.54cm；1cm = 0.394in Centimeter(cm) Millimeter(mm) Point(pt)点，72pt = 1in； p &#123;font-size:18pt&#125;相当于p &#123;font-size: 0.25in;&#125; Pixel(px)像素，是屏幕上的一个小格子。但在 CSS 中像素比较抽象，像素被定义为每英寸产生 96 像素所需要的大小。在 CSS 规范建议，如果显示器的分辨率密度明显不同于每英寸 96 像素（ppi，96 pixels per inch）,则用户代理应将像素缩放到“参考像素”，CSS2.1 和 CSS3 建议是 96ppi。如果一个显示器的分辨率是宽：1024px，高：768px，则其屏幕的尺寸是宽：10 2/3 英寸，高：8 英寸，它完全由显示像素填充，每个像素宽、高是 1/96 英寸。一些显示器的 ppi 高于 96，如视网膜显示屏，iPhone 4S 是 326ppi，iPad 是 264ppi 相对长度单位 em/ex，em:小写 m 的宽度；ex:小写 x 的高度。 rem, rem总是使用根元素（html 元素）字体大小来计算；em使用它所应用的元素的字体大小来计算； ch, “one character”,等于0字符的宽度或高度。(文字本身的宽度+两边内置间距)。 可保证每一行最大 80 个字符宽度 可给图片宽度设置 25 个字符的宽度1234567.contanier &#123; width: 80ch;&#125;img &#123; height: 1rem; width: 25ch;&#125; 视口相对大小单位CSS3 中新增的特性，相对于视口进行计算的单位。如浏览器窗口、可打印区域、移动设备显示 Viewport width unit(vm)：由视口宽度/100 计算而来，如果视口宽度 937px，1vm=9.37px,如果视口改变，vm 值也随之改变。 Viewport height unit(vh): 由视口高度/100 计算而来 Viewport minimum unit(vmin): 取 vm 和 vh 中较小的，如果视口宽 937px，高 640px，则 1vmin = 6.4px Viewport maximum unit(vmax): 取 vm 和 vh 中较大的 分辨率单位随着媒体查询和响应设计的出现，为了能够描述显示分辨率，引入了三种新的单位 Dots per inch(dpi)：线性上每英寸的显示点数。可以指打印机输出的点，设备的物理像素，或电子墨显示屏中的电子像素。 Dots per centimeter(dpcm)：每厘米的显示点数。 Dops per pixel unit(dppx)：每个 CSS 像素单位的显示点数。CSS3 中。1dppx 相当于 96dpi,因为 CSS 以该比率定义像素单位。截止 2017 年末，这些分辨率单位仅用于媒体查询中， 123@media (min-resolution: 500dpi) &#123;&#125; 计算的值（Calculation Values, calc()）calc(),可以在任何允许使用以下数值类型的地方。&lt;length&gt;,&lt;frequency&gt;, &lt;angle&gt;,&lt;time&gt;,&lt;percentage&gt;, &lt;number&gt;, &lt;integer&gt;，也可以使用它们的单位类型。单需要注意以下限制： +,-符号两边的值必须相同单位类型或&lt;number&gt;和&lt;integer&gt;.如5em + 2.7是非法的,因为一个是长度单位（em），另一个不是。5em + 20px是合法的，两个都是长度单位。 +,-符号两边需要空格，*,/不需要。 属性值 （Attribute Values, attr()）在一些 CSS 属性中，可以填入该元素定义的 HTML 属性的值，还可以指定表达式中的值类型。通过attr()表达式完成。 123456789 .say::before &#123; content: &quot;[&quot; attr(class) &quot;]&quot;; &#125; .say::after &#123; content: attr(data-after); &#125;&lt;div class=&quot;jiangjiang say&quot; data-height=&quot;10&quot; data-after=&quot;after&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&quot;&gt;&lt;/div&gt; 颜色 type description name colors 148 color keywords RGB/RGBa rgb(255,255,255) rgba(100%,100%,100%,0.5) hexadecimal RGB color #FF3BC0 #0F0 #00FF00 hexadecimal RGBa color #000000FF 第 7-8 位表示透明度，FF~00,透明度递减 HSL/HSLa H:hue(色调,色相角度,0-360);S:saturation(饱和度,0-100%);L:lightness(亮度,0-100%) color keywords transparent：透明色 rgba(0,0,0,0),是背景色的默认值; currentColor： 当前元素的颜色的计算值 角度 deg : Degrees, 一圈 360 度 rad : Radians,一圈 2&pi;(近似 6.28) turn : Turns，一整圈，常用在动画、旋转，10turn代表 10 圈 Degrees Radians Turns 0deg orad 0turn 45deg 0.785rad 0.125turn 90deg 1.571rad 0.25turn 180deg 3.142rad 0.5turn 270deg 4.712rad 0.75turn 360deg 6.283rad 1turn 位置&lt;position&gt;值是如何指定背景区域中原始图像的位置 1 个 值: 第 2 值默认center; 25%-&gt; 25% center 2 个 值：第 1 个是长度或百分比，则代表水平方向上的值。25% 35px，水平方向:25%,竖直方向:35px; 3 个 值: 最后一个 默认0，right 20px top-&gt;right 20px top 0 4 个 值: top 50% left 35px，表示 距离 top 的偏移量为 50%，距离 left 的偏移量是 35px。 自定义值(Custom Values) 自定义标识符以两个连字符开头--base--color,之后使用val()值类型调用它 可使用特性查询（@supports）判断是否支持该特性 自定义值有限定的，仅在给定的上下文中可以 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot; /&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot; /&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot; /&gt; &lt;title&gt;Custom Values&lt;/title&gt; &lt;style&gt; @supports (color: var(--custom)) &#123; html &#123; --base-color: #639; &#125; aside &#123; --base-color: #f60; &#125; h1 &#123; color: var(--base-color); &#125; .box &#123; --gutter: 3ch; --offset: 1; &#125; ul li &#123; margin-left: calc(var(--gutter) * var(--offset)); &#125; ul ul li &#123; --offset: 2; &#125; ul ul ul li &#123; --offset: 3; &#125; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;Main H1&lt;/h1&gt; &lt;aside&gt; &lt;h1&gt;aside H1&lt;/h1&gt; &lt;/aside&gt; &lt;h1&gt;Main H1&lt;/h1&gt; &lt;h1&gt;Main H1&lt;/h1&gt; &lt;br /&gt; &lt;div class=&quot;box&quot;&gt; &lt;h2&gt;a regular set of indents for unordered lists&lt;/h2&gt; &lt;ul&gt; &lt;li&gt;1111&lt;/li&gt; &lt;li&gt;1111&lt;/li&gt; &lt;ul&gt; &lt;li&gt;2222&lt;/li&gt; &lt;li&gt;2222&lt;/li&gt; &lt;ul&gt; &lt;li&gt;3333&lt;/li&gt; &lt;li&gt;3333&lt;/li&gt; &lt;li&gt;3333&lt;/li&gt; &lt;/ul&gt; &lt;/ul&gt; &lt;/ul&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt;","categories":[{"name":"技术总结","slug":"技术总结","permalink":"https://better-jiang.github.io/categories/%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%93/"}],"tags":[{"name":"css","slug":"css","permalink":"https://better-jiang.github.io/tags/css/"}]},{"title":"CSS知识点梳理(3)","slug":"CSS知识点梳理-3","date":"2019-12-10T01:30:24.000Z","updated":"2023-02-03T12:14:22.417Z","comments":true,"path":"2019/12/10/CSS知识点梳理-3/","link":"","permalink":"https://better-jiang.github.io/2019/12/10/CSS%E7%9F%A5%E8%AF%86%E7%82%B9%E6%A2%B3%E7%90%86-3/","excerpt":"","text":"选择器的特异性（Specificity）当一个元素有两个或多个相互冲突的属性声明时，具有最高特异性的属性声明将胜出。选择器的特异性值可以表示为四个部分0,0,0,0，实际如何确定 如下 每一个内联声明， 1,0,0,0 每一个 ID 选择器，加0,1,0,0 每一个类选择器、属性选择器、伪类选择器，加0,0,1,0 每一个元素选择器、伪元素选择器，加0,0,0,1 组合符和通配选择器不影响特异性值 1234567h1 &#123;color: red;&#125; /*specificity = 0,0,0,1 */p em &#123;color: purple&#125;; /*specificity = 0,0,0,2 */.grape &#123;color: purple&#125;; /*specificity = 0,0,1,0 */*.bright &#123;color: yellow;&#125; /*specificity = 0,0,1, */p.bright em.dark &#123;color: maroon;&#125; /*specificity = 0,0,2,2 */#id216 &#123;color: blue;&#125; /*specificity = 0,1,0,0 */div#sidebar *[href] &#123;color: silver;&#125; /*specificity = 0,1,1,1 */ 一旦选择器的特异性被确定，特异性值将付给它所有的相关声明。 1234567h1, h2.section &#123;color: silver; background: black;&#125;h1 &#123;color:silver;&#125; /* 0,0,0,1 */h2 &#123;background:black;&#125; /* 0,0,0,1 */h1.section &#123;color:silver;&#125; /* 0,0,1,1 */h2.section &#123;background: black;&#125; /*0,0,1,1*/ !important声明比所有的特异性值都高 继承（Inheritance）当元素的一个继承属性没有指定值时，则取父元素的同属性的计算值. 许多属性不具继承性；例如：border,盒模型属性包括margin,padding, background, border。 继承属性的值完全没有特异性。 1234* &#123;color: gray;&#125;h1#page-title &#123;color: black;&#125;&lt;h1 id=&quot;page-title&quot;&gt; Meerkat &lt;em&gt;Central&lt;/em&gt; &lt;/h1&gt; 由于通配选择器适用于所有元素，并且具有特异性0,0,0,0,因此颜色声明的灰色胜过了继承的黑色值。后者根本没有特异性。 通配选择器具有短路继承的效果 层叠/级联（Cascade）层叠样式表(Cascading Style Sheets)：CSS 基于一种使样式层叠在一起的方法，它是通过将继承和特异性与一些规则相结合而实现的。 层叠规则 查找包含与给定元素匹配的选择器的所有规则 按显示权重对声明排序，!import比其它无!important规则权重高。 按来源对声明排序，三个基本来源：作者、读者、用户代理。通常情况下，作者的样式胜过读者，当读者!important样式比其它都强，包括作者的!important样式。 （以下权重由大至小） 读者 important 声明 作者 important 声明 作者 正常 声明 读者 正常 声明 用户代理（浏览器） 默认 声明 按特异性值排序 按声明的顺序排序 @import引入的外部样式，排在文档内部样式的前面.可视为在@import的地方，把外部样式表粘贴于此。12@import url(basic.css);h1 &#123;color: blue;&#125; a链接样式的顺序 link-visited-focus-hover-active.为什么？一个链可能同时处于多个状态，即同时匹配多个伪类。:link和visited是常态效果，:hover和:active是瞬时效果 未点击链接前，匹配:link伪类，鼠标悬停/点击时，链接同时匹配:link和:hover/:active。在同时匹配多个伪类时，后出现的伪类样式会覆盖前面的，所有:link必须写在:hover、:active之前，才能展示链接悬浮、激活样式。 :hover和:active顺序？假若:hover放在:active后面，当点击链接的一瞬间，实际长匹配了:active同时也匹配了:hover伪类，:hover在后面就覆盖了:active样式，所有就无法展示:active样式了。故:active在:hover之后。 :link和:visited两个伪类之间顺序无所谓，因为它们不能同时匹配。","categories":[{"name":"技术总结","slug":"技术总结","permalink":"https://better-jiang.github.io/categories/%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%93/"}],"tags":[{"name":"css","slug":"css","permalink":"https://better-jiang.github.io/tags/css/"}]},{"title":"CSS知识点梳理(2)","slug":"CSS知识点梳理-2","date":"2019-12-09T01:13:38.000Z","updated":"2023-02-03T12:14:22.417Z","comments":true,"path":"2019/12/09/CSS知识点梳理-2/","link":"","permalink":"https://better-jiang.github.io/2019/12/09/CSS%E7%9F%A5%E8%AF%86%E7%82%B9%E6%A2%B3%E7%90%86-2/","excerpt":"","text":"Chapter 2 基本样式规则 每个规则都由两部分组成：选择器 和声明块；声明块由一个或多个声明组成；每个声明则是一个属性-值对；值可以是单个关键字，也可以是多个关键字的空格（有些情况为 反斜杠 /）分割列表；每个样式表由一系列规则组成。 1234p &#123; font: 15px/15px sans-serif; /* font-size/line-height */ color: red;&#125; 分组 选择器分组，规则左侧可以放多个选择器，并用逗号,分割。1h2, h3, p &#123; color: gray;&#125; 通配选择器：*表示；相当于一个分组选择器，它列出文档中包含的没个元素。 声明分组，需在在每个声明的末尾是使用分号;12345h1 &#123; font: 18px HElvetica; color: purple; background: aqua;&#125; Class 和 ID 选择器 隐含的通配选择器：当写 ID、类、属性、伪类、伪元素选择器而不附加到元素选择器时，将隐含有*通配选择器。 123456.waring &#123;font-weight: bold;&#125;p.waring &#123;font-weight: bold;&#125;*.waring &#123;font-weight: bold;&#125;#first-para &#123;font-weight: bold&#125;*#first-para &#123;font-weight: bold;&#125; 类选择器：前用点号.标记，元素的 class 属性指定一个合适的值；可应用到多个元素。 多类选择器：元素的 class 值可以是一个词列表，使用空格分割。将多个类选择器链接在一起，表示仅可以选择同时包含这些类名的元素（类名顺序不限） 123456&lt;p class=&quot;urgent waring&quot;&gt;warning and urgent&lt;/p&gt;.waring.urgent &#123; font-weight: bold; color: red;&#125; ID 选择器：ID 选择器前用井号#标记。元素的 id 属性指定一个合适的值，不允许是用空格分割的单词列表。一个 HTML 文档中，仅使用一次。 属性选择器：根据元素的属性和属性值来选择元素。分四种：简单属性选择器、精确属性值选择器、部分匹配属性值选择器、前导值属性选择器 简单选择器：选择具有某个属性的那些元素，不管该属性的值如何 12345678910111213141516h1[class] &#123; /* 有class属性的所用h1元素 */ color:silver;&#125;img[alt] &#123; border: 3px solid red;&#125;*[title] &#123; /* 加粗 任何含titile信息的元素 */ font-weight: bold;&#125;&lt;a href=&quot;http://www.w3.org/&quot; title=&quot;W3C Home&quot;&gt;W3C&lt;/a&gt;a[href][title] &#123; /* 同时具有href和title属性的任何a元素*/ font-weight: bold;&#125; 精确属性值选择器：选择包含属性为某个精确值的那些元素 1234567a[href=&quot;http://www.w3.org&quot;] &#123; font-weight: bold;&#125;a[href=&quot;http://www.w3.org&quot;][title=&quot;W3C Home&quot;] &#123; font-weight: bold;&#125; 部分属性值选择器： 如果属性能接受用空格分割的词列表（class 属性）,可根据元素的部分属性值而不是全部值来选择元素。 Type Description [foo~=”bar”] foo 属性的值（以空格分割的单词列表）包含”bar” [foo*=”bar”] foo 属性的值包含子串”bar” [foo^=”bar”] foo 属性的值以”bar”开头 [foo$=”bar”] foo 属性的值以”bar”结尾 [foo&#124;=”bar”] foo 属性的值等于”bar”,或者以”bar-“开头 前导值属性选择器：特定的属性选择类型,比如[len|&quot;en&quot;]123*[lang|=&quot;en&quot;] &#123; color: black;&#125; 文档结构HTML 文档是基于元素的层次结构，该层次结构可以用“树”视图来表示。在树视图中，如果一个元素恰好位于另一个元素之上或之下的层次，则它们有父-子关系（parent-child）。如果从一个元素到另一个元素的路径经过了两个或多个层次，则它们具有祖先-后代关系（ancestor-descendant），而不是父-子关系。 后代选择器（Descendant Selectors）在后代选择器中，规则的选择器端由两个或多个以空格分隔的选择器组成。选择器之间的空格是一种结合符（combinator）。每一个空格结合符都可以翻译：“…在…内部找到”、“…作为…的一部分”、“…作为…的后代”，但必须是从右向左阅读选择器。所以h1 em &#123;color: gray;&#125;可以解释为：“作为 h1 元素后代的任何 em 元素”。 后代选择器没有元素接近的概念，换句话说，文档树中的两个元素的紧密程度与规则是否适用无关。1234567891011div:not(.help) span &#123; color: gray;&#125;div.help span &#123; color: red;&#125;&lt;div class=&quot;help&quot;&gt; &lt;div class=&quot;aside&quot;&gt; This text contains &lt;span&gt;a span element &lt;/span&gt; within. &lt;div/&gt;&lt;/div&gt; 因为红色的规则写在后面，所以 span 元素显示红色。但实际上：div class=&quot;aside&quot;比 div class=&quot;help&quot;更靠近span元素。 选择子元素： 选择一个元素的子元素。h1 &gt; stong,选择作为 h1 元素子元素的所有 strong 元素。 选择相邻兄弟元素：选择一个紧跟（二者相邻）在另一个元素后的元素。且二者具有相同父元素。 h1+p,选择紧跟在 h1 元素后面的所有 p 元素，且 h1 和 p 元素有共同的父元素。另外，两个元素之间的文本内容不会阻止相邻兄弟结合符起作用。 选择跟随兄弟元素： 选择一个跟随（二者可以不相邻）在另一个元素后的元素，且二者具有相同的父元素。 h1 ~ p,选择 h1 元素后面的所有 p 元素（二者之间可以有其它元素，也可以是相邻的），h1 和 p 元素有相同的父元素。 伪类选择器 组合伪类： 伪类是可以链/组合在一起的,但不能是相互排斥的。比如a:link:visited，一个连接不能既是未访问，又是访问后的。 123456a:link:hover &#123; color: red; &#125;a:visited:hover &#123; color: maroon;&#125; 结构化的伪类注意： 伪类始终指向它们所附加的元素，而没有其它元素，比如后代元素 123/* CSS 玩笑，假如我结婚生子 */#liuzhenjiang &gt; :first-child &#123;&#125; /* 刘振江 的 第一个孩子 */#liuzhenjiang:first-child &#123;&#125; /* 刘振江且是父母的第一个孩子 */ 根元素： :root，匹配根元素。在 HTML 中，它总是html元素 空元素： :empty,匹配空元素，没有子元素，没有任何文本节点（包括文本、空白（空格、换行符等））。:empty &#123;display: none;&#125;,其实等同于*:empty:&#123;display: none;&#125;。但有个陷阱：在 HTML 的元素中，img、input,没有插入默认文本的textarea,都与之匹配。就匹配而已，img与img:empty实际上是相同的。 唯一子元素： :only-child,某类型元素是另一个元素的唯一子元素。 12345678a[href] img:only-child &#123; border: 5px solid black;&#125;/* 以下3个都匹配，匹配有父元素且子元素只是img类型元素的img */&lt;a href=&quot;http://w3.org/&quot;&gt;&lt;img src=&quot;w3.png&quot; alt=&quot;W3C&quot;&gt;W3C&lt;/a&gt;&lt;a href=&quot;http://w3.org/&quot;&gt;&lt;span&gt;&lt;img src=&quot;w3.png&quot; alt=&quot;W3C&quot;&gt;&lt;/span&gt;W3C&lt;/a&gt;&lt;a href=&quot;http://w3.org/&quot;&gt;A link to &lt;span&gt;The &lt;img src=&quot;w3.png&quot; alt=&quot;W3C&quot;&gt;&lt;/span&gt;W3C&lt;/a&gt; 同类型元素： :only-of-type,同级中唯一个某类型的元素。（该类型元素在父元素中仅有一个） 123456a[href] img:only-of-type &#123; border: 5px solid black;&#125;&lt;a href=&quot;http://w3.org/&quot;&gt;&lt;b&gt;.&lt;/b&gt;&lt;img src=&quot;w3.png&quot; alt=&quot;W3C&quot;&gt;W3C&lt;/a&gt;&lt;a href=&quot;http://w3.org/&quot;&gt;&lt;span&gt;&lt;b&gt;.&lt;/b&gt;&lt;img src=&quot;w3.png&quot; alt=&quot;W3C&quot;&gt;&lt;span&gt;W3C&lt;/a&gt; 第一个/最后一个 子元素： :first-child,选择作为其他元素的第一个子元素的元素。以下是第一个子元素： 第一个 p 元素、第一个 li 元素、第一个 strong 元素、第一个 em 元素。123456789&lt;div&gt; &lt;p&gt;These are the necessary steps:&lt;/p&gt; &lt;ul&gt; &lt;Li&gt;Insert key&lt;/li&gt; &lt;Li&gt;Turn key &lt;strong&gt;clockwise&lt;/strong&gt;&lt;/li&gt; &lt;Li&gt;Push accelerator&lt;/li&gt; &lt;/ul&gt; &lt;p&gt;Do &lt;em&gt;not&lt;/em&gt; push the brake at the same times as the accelerator&lt;/p&gt;&lt;/div&gt; 最后一个子元素： :last-child,选择作为其他元素的最后一个子元素的元素。123456789p:first-child &#123; font-weight: bold;&#125;li:last-child &#123; text-transform: uppercase;&#125;p:last-child em &#123; /* 最后一个p元素内的em元素 */ color: red;&#125; p:only-child等同于p:first-child:last-child 类型的第一个、最后一个：在另一个元素中选择元素类型的第一个或最后一个。 类型的第一个: table:first-of-type,选择在每个包含表元素的元素中，选择第一个表元素，并跳过它后面的所有同级的表元素。 类型的最后一个: table:last-of-type,选择在每个包含表元素的元素最后，选择最后一个表元素。 table:only-of-type等同于table:first-of-type:last-of-type 选择等 n 个子元素： :nth-child(n)，在另一个元素中选择等 n 个子元素。 123456p:nth-child(2) &#123; /* 上面的HTML例子中，第2段落，不会被选中，因为等2段落不是其父元素的第2个子元素，是第3个子元素。 */ font-weight: bold;&#125;li:nth-child(2) &#123; text-transform: uppercase;&#125; :nth-child(3n + 1), 从第一个子元素开始，每隔 3 个选则一个子元素。n代表：0,1,2,3,4,5,6 …,3n + 1的结果是:1,4,7,10,13 … ；nth-last-child(n)，从最后一个子元素数起，朝向 首元素。 可以使用 CSS 确定列表中有多少个列表项，并相应地设置起样式： 123456789101112131415161718li:only-child &#123; width: 100%;&#125;li:nth-child(1):nth-last-child(2),li:nth-child(2):nth-last-child(1) &#123; width: 50%;&#125;li:nth-child(1):nth-last-child(3),li:nth-child(1):nth-last-child(3) ~ li &#123; width: 33.33%;&#125;li:nth-child(1):nth-last-child(4),li:nth-child(1):nth-last-child(4) ~ li &#123; width: 25%;&#125; 选择类型的第 n 个：p &gt; a:nth-of-type(even),从第 2 个开始，选择所有 p 元素内所有第偶数个 a 元素。 动态伪类应用样式是基于一些无法预测的短暂条件。比如a标签，判断访问过哪些链接的唯一方法是将文档中的链接与浏览器历史记录进行比较。 超链接伪类超链接必须是有href属性，&lt;a&gt;TH lives of Meerkats&lt;/a&gt;,a:link&#123;&#125;无法匹配，a&#123;&#125;匹配。 Name Description :link 未访问的超链接（必须有href属性） :visited 已访问过的超链接 用户操作伪类根据用户操作改变文档的外观样式。 Name Description :focus 具有输入焦点的任何元素 :hover 鼠标指针所在的元素 :active 任何被用户输入激活的元素，包括链接、按钮、菜单选项、任何有tabindex值的元素 (例如，按钮，用户单击按下鼠标期间，直到鼠标松开) 伪类的顺序link -&gt; visited -&gt; focus -&gt; hover -&gt; active 动态样式在实际中存在的问题 123456a:link, a:visited &#123; font-size: 13px;&#125;a.hover, a:active &#123; font-size: 20px;&#125; 鼠标悬浮，字体变大。在触摸屏，则多亏:active。 鼠标悬浮，字体变大，必须要重新绘制文档，迫使链接后面的所有内容回流（reflow）。 UI 状态伪类基于用户界面元素的当前状态进行样式化。 Name Description :enabled 启用的用户界面元素，可以输入 :disabled 禁用的用户界面元素，不能输入 :indeterminate 状态不确定的元素，单选、复选框既没有选中也没有不选中，由 DOM 脚本 设置 :default 默认选择的单选、复选框或者选项 :valid 通过有效性校验的 input、form 元素 :invalid 未通过有效性验证的 input、form 元素 :in-range 用户输入的值，在最小值~最大值之间 :out-of-range 用户输入的值，不在最小值~最大值之间 :required 必须由用户输入来设置值的表单元素 :optional 不需设置值的表单元素，即没有 required 属性 :read-write y 用户可编辑的表单元素 HTML 元素有 contenteditable 属性 :read-only 用户不可编辑的表单元素 目标伪类（:target） 片段标识符：Some URIs refer to a location within a resource. This kind of URI ends with a “number sign” (#) followed by an anchor identifier (called the fragment identifier).一些 uri 指向本地资源，这种 uri 以#结尾，后跟一个锚标识符。 带有片段标识符的 uri 链接到文档中的某个元素，即目标元素.示例如下:URI 链接到 HTML 文档中名字是p1的锚。 1234&lt;a href=&quot;http://youwebsite.com/html/demo.html#p1&quot;&gt;&lt;a href=&quot;#p1&quot;&gt;Jump to the first paragraph! &lt;/a&gt;&lt;p id=&quot;p1&quot;&gt;You can target this paragraph using a URL fragment&lt;/p&gt; 语言伪类(:lang())基于语言来选择元素，:lang(fr)伪类与[lang|=&#39;fr&#39;]属性选择器是等价的；但使用伪类选择器它是语言信息来源有多个，属性选择器必须是该元素有 lang 属性。 12*:lang(fr) &#123;font-style:italic;&#125;*[lang|=&#x27;fr&#x27;] &#123;font-style:italic;&#125; 否定伪类(:not()):not()是附加到一个元素上，括号内填写一个简单选择器(simple selector). simple selector:一个没有祖先-后代关系的选择器。包括 type selector(Element type selector,元素选择器),universal selector（通配选择器）, attribute selector（属性选择器）, class selector（类选择器）, ID selector（ID选择器）, or pseudo-class（伪类选择器） 伪元素选择器伪元素将虚构的元素插入到文档中。使用双冒号(::first-letter)语法，同伪类选择器（单冒号 :hover）区分。伪元素选择器只能出现在选择器末尾，p::first-letter em是不合法的。 Name Description ::first-letter 非内联元素的第一个字母或第一个标点符号 ::first-line 元素中的第一行文本 ::before 在元素前插入生产的内容并设置其样式 ::after 在元素后插入生产的内容并设置其样式 1234h2::before &#123; content: &#x27;]]&#x27;; color: silver;&#125; ::first-letter 和 ::first-line限制(样式属性) ::first-letter ::first-line All font properties All font properties All background properties All background properties All text decoration properties All margin properties All inline typesetting properties All padding properties All inline layout properties All border properties All border properties All text decoration properties box-shadow All inline typesetting properties color color opacity opacity","categories":[{"name":"技术总结","slug":"技术总结","permalink":"https://better-jiang.github.io/categories/%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%93/"}],"tags":[{"name":"css","slug":"css","permalink":"https://better-jiang.github.io/tags/css/"}]},{"title":"CSS知识点梳理(1)","slug":"CSS知识点梳理-1","date":"2019-12-09T01:11:41.000Z","updated":"2023-02-03T12:14:22.416Z","comments":true,"path":"2019/12/09/CSS知识点梳理-1/","link":"","permalink":"https://better-jiang.github.io/2019/12/09/CSS%E7%9F%A5%E8%AF%86%E7%82%B9%E6%A2%B3%E7%90%86-1/","excerpt":"","text":"Chapter 1 元素 可替换元素：展现效果不是由 CSS 来控制的。这些元素是一种外部对象，它们外观的渲染，是独立于 CSS .元素内容被外部的内容所替换，根据元素的标签和属性来决定元素的具体显示的内容；替换元素可用 height 和 width 属性进行缩放；如&lt;img&gt;，本身没具体内容，被文档外部的图像替换。&lt;input&gt;，由一个单选按钮、复选框、文本输入框替换。 不可替换元素：元素内容由浏览器在元素本身生产的框中显示。如&lt;span&gt;、&lt;h1&gt;、&lt;td&gt;、&lt;li&gt; 块级元素：默认地生成一个元素框，它会填充起父元素的内容区，且独占一行，旁边不能有其它元素。替换元素可以是块级元素，但通常都不是。如p、div、li 行内元素：在一个文本行内生成元素框，且不会破坏该行的流。 HTML、CSS 都有块级元素、行内元素的概念，但存有一个重要差别。HTML 中，块级元素不能继承自行内元素。CSS 中，对显示角色如何嵌套不存在任何限制。 CSS 与 HTML 的结合 外部样式：使用 link 标签来链接样式表和 HTML 文档。 文档样式 用&lt;style&gt;元素包裹，且一定要是用 type 属性type=&quot;text/css&quot; 使用@import指令，必须放在样式表开头。123456&lt;style type=&quot;text/css&quot;&gt;@import url(other.css) print, projection;h1 &#123; color:red;&#125;&lt;/style&gt; 行内/内联样式：使用style属性为单个元素指定样式。 浏览器供应商前缀浏览器供应商 标记 CSS 属性、值作为实验或专有的一中方法 Prefix Vendor -epub- epub 格式 -moz- firefox -ms- IE -o- Opera -webkit- 基于 webkit 内核，Safari、Chrome 等 媒体查询可用地方： link 元素中 media 属性 style 元素中 media 属性 @import 声明中，媒体描述部分 @media 声明中，媒体描述部分 123456789&lt;link type=&quot;text/css&quot; ref=&quot;sheetstyle&quot; href=&quot;bar.css&quot; media=&quot;screen, print&quot;&gt;&lt;style type=&quot;text/css&quot; media=&quot;screen, print&quot;&gt;&lt;/style&gt;@import url(bar.css) screen, print;@media screen, print &#123; h1 &#123; color: red; &#125;&#125; 特性查询在某个 CSS 特性支持下应用 CSS 规则。例如，此样式块仅应用于支持、特性查询和网格布局的浏览器中，若不支持，则完全跳过样式块。 12345@supports (display: grid) &#123; #main &#123; display: grid; &#125;&#125;","categories":[{"name":"技术总结","slug":"技术总结","permalink":"https://better-jiang.github.io/categories/%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%93/"}],"tags":[{"name":"css","slug":"css","permalink":"https://better-jiang.github.io/tags/css/"}]},{"title":"《CSS权威指南4》- Chapter2.3-选择器-群组","slug":"《CSS权威指南4》-Chapter2-3-选择器-群组","date":"2019-12-05T10:28:22.000Z","updated":"2023-02-03T12:14:22.416Z","comments":true,"path":"2019/12/05/《CSS权威指南4》-Chapter2-3-选择器-群组/","link":"","permalink":"https://better-jiang.github.io/2019/12/05/%E3%80%8ACSS%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%974%E3%80%8B-Chapter2-3-%E9%80%89%E6%8B%A9%E5%99%A8-%E7%BE%A4%E7%BB%84/","excerpt":"","text":"分组迄今为止，我们已经学习了将单个样式应用于单个选择器这种相当简单的技术。但是如果想要向多个元素应用同一个样式？如果是这样的话，则需要使用多个选择器，或者向一个或一组元素应用多个样式。 分组选择器假设希望h2和p元素文本都是灰色。最简单的实现方式是使用以下声明： 123h2, p &#123; color: gray;&#125; 将 h2和p选择器放在规则的左边，并使用逗号分隔，右边是样式（color：gray;）应用于两个选择器所指的元素,这样就定义了一个规则。逗号告诉浏览器，在该规则中涉及到两个不同的选择器。去掉逗号，会给这个规则带来完全不同的含义，我们将在“后代选择器”中对此进行讨论。实际上，将多少个选择器组合在一起是没有限制的，例如，想要显示大量的灰色元素，可以使用如下规则： 123body, table, th, td, h1, h2, h4, h5, p, pre, strong, em, b, i &#123; color: gray;&#125; 分组允许作者极大的压缩某些类型的样式，这样可得到一个更简单的样式表。以下的两组可选规则，产生相同的结果，但是可以很清楚的看出还一个更容易书写。 123456789h1 &#123;color: purple;&#125;h2 &#123;color: purple;&#125;h3 &#123;color: purple;&#125;h4 &#123;color: purple;&#125;h5 &#123;color: purple;&#125;h1, h2, h3, h4, h5 &#123; color: purple;&#125; 分组也允许一些有趣的选择。例如，以下例子中所有的规则分组都是等价的。每一个组仅展示了对选择器和声明 分组的不同方式。 123456789101112131415161718192021/* group 1 */h1 &#123;color: silver; background: white;&#125;h2 &#123;color: silver; background: gray;&#125;h3 &#123;color: white; background: grey;&#125;h4 &#123;color: silver; background: white;&#125;b &#123;color: gray; background: white;&#125;/* group 2 */h1, h2, h4 &#123;color: silver;&#125;h3 &#123;color: white;&#125;b &#123;color: gray;&#125;h1, h4, b &#123;background: white;&#125;h2, h3 &#123;background: gray;&#125;/* group 3 */h1, h4 &#123;color: silver; background: white;&#125;h2, h3 &#123;background: gray;&#125;h2 &#123;color: silver;&#125;h3 &#123;color: white;&#125;b &#123;color: gray; background: white;&#125; 通用选择器CSS2 引入了一个新的简单选择器，称为“通用选择器”，显示为一个星号（*）。这个选择器可以匹配任何元素，就像一个通配符。例如，要让一个文档中每一个元素都为红色，样式可以这样写。 1* &#123;color: red;&#125; 这个声明相当于一个分组选择器，它列出文档中包含的每个元素，通用选择器只需敲击键盘一次，就能把文档中所有元素的 color 属性赋值为 red。 但是，要注意：虽然通用选择器很方便，但是它的特性是 0-0-0；由于它的目标是其声明范围内的所有内容，因此它可能产生意想不到的结果，本书稍后对此进行讨论。 分组声明由于可以将选择器组合成单个规则，因此也可以对声明进行分组。假设你想要所有的h1元素的都呈现为紫色、高 18 像素、Helvetica 字体、浅绿色背景。可以这样编写样式： 123h1 &#123;font: 18px Helvetica;&#125;h1 &#123;color: purple;&#125;h1 &#123;background: aqua;&#125; 但是这种方法是低效率的，想象一下，为一个包含 10 或 15 个样式的元素创建这样一个列表！可以把声明放在一起来替代它。 1h1 &#123; font: 18px Helvetica; color: purple; background: aqua;&#125; 这将产生与以上展示的三行样式完全相同的效果。注意,在 对每个声明进行分组时，在其末尾使用分号是至关重要的。浏览器忽略样式表中的空白，因此用户代理必须依赖正确的语法来解析样式表。可以大胆的格式化样式如下： 12345h1 &#123; font: 18px Helvetica; color: purple; background: aqua;&#125; 也可以最小化 CSS，删除所有不需要的空格。 1h1&#123;font:18px Helvetica;color:purple;background:aqua;&#125; 忽略空白，最后一个也会被服务器平等对待，但是第二个最易读的，也是在开发过程中编写 CSS 的推荐方法。处于网络性能的考虑，你可能会选择最小化 CSS，但这通常是由服务端脚本、缓存网络或其他服务来处理的。如果第二个声明省略了分号，用户代理对样式表的解释如下： 1234h1 &#123; font: 18px Helvetica; color: purple background: aqua;&#125; 因为background:不是color的有效值，而且color只能有一个关键字，所有用户代理将完全忽略color声明（包括background: aqua;部分）。你可能以为浏览器至少会把h1元素渲染成没有浅绿色背景的紫色文本，但事实并非如此。相反，color将是默认的颜色（通常是黑色）,banckground是透明的（transparent，也是默认的）。声明font: 18px Helvetica任然有效，因为它是用分号正确结束的。与选择器分组一样，声明分组是保持样式表简短、富有表现力、易于维护的一种便利方式。 分组一切现在你知道可以对选择器、声明进行分组。通过在单个规则中结合这两种类型的分组，可以仅使用几个语句来定义非常复杂的样式。现在，如果你想给文档中所有的标题分配一些复杂的样式，并且希望对所有的标题应用相同的样式，该怎么办？具体做法如下： 1234567h1, h2, h3, h4, h5, h6 &#123; color: gray; background: white; padding: 0,5em; border: 1px solid black; font-family: Charcoal, sans-serif;&#125; 这里我们将选择器分组，因此规则右侧的样式将应用于列出的所有标题。声明分组意为着所有列出的规则将应用于规则左侧的选择器。这种方法比冗长的替代方法更可取，后者的开头是这样的： 12345678910111213h1 &#123;color: gray;&#125;h2 &#123;color: gray;&#125;h3 &#123;color: gray;&#125;h4 &#123;color: gray;&#125;h5 &#123;color: gray;&#125;h6 &#123;color: gray;&#125;h1 &#123;background: white;&#125;h2 &#123;background: white;&#125;h3 &#123;background: white;&#125;h4 &#123;background: white;&#125;... 并继续许多行。你可以编写这样长的样式，但不建议使用。因为在编辑更改时，它们江河到处使用的样式属性一样繁琐乏味。可以向选择器添加更多的表达式，并以一种有利于信息类型的元素间切换的方式来应用样式。想要得到如此强大的功能，需要先做些准备工作，但这是非常值得的。 新元素在老旧的浏览器随着 HTML 的更新，如 HTML5 规范，新的元素已经出现。有一些浏览器比这些新元素更早，所以不能识别它们。比如，IE9 之前的 ie 版本，不支持选择它们不理解的元素，解决方案是在 DOM 中创建该元素，从而告知浏览器该元素存在。例如， IE8 不能识别&lt;main&gt;元素，一些 JavaScript 将告知main元素的存在: 1document.createElement(&#x27;main&#x27;); 通过运行这行代码，旧版本的 IE 将识别元素的存在，从而允许对其进行选择和样式。","categories":[{"name":"技术总结","slug":"技术总结","permalink":"https://better-jiang.github.io/categories/%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%93/"}],"tags":[{"name":"翻译","slug":"翻译","permalink":"https://better-jiang.github.io/tags/%E7%BF%BB%E8%AF%91/"},{"name":"CSS权威指南-第四版","slug":"CSS权威指南-第四版","permalink":"https://better-jiang.github.io/tags/CSS%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97-%E7%AC%AC%E5%9B%9B%E7%89%88/"}]},{"title":"EventLoop梳理","slug":"EventLoop梳理","date":"2019-12-02T11:10:50.000Z","updated":"2023-02-03T12:14:22.416Z","comments":true,"path":"2019/12/02/EventLoop梳理/","link":"","permalink":"https://better-jiang.github.io/2019/12/02/EventLoop%E6%A2%B3%E7%90%86/","excerpt":"","text":"JS 是单线程的，它是通过事件队列（EventLoop）的方式来实现异步回调的。 浏览器内核(渲染引擎: Rendering Engine)浏览器内核其实指的是浏览器内的一个进程，它负责页面的渲染、脚本执行、事件处理等，每一个 Tab 页一个渲染进程。对于渲染进程来讲，它是多线程的，包括以下线程 GUI 渲染线程 复杂渲染页面，回流、重绘 与 JS 引擎线程互斥，防止渲染结果不可预期 JS 引擎线程 复杂处理解析、执行 JS 脚本程序 只有一个 JS 引擎（单线程） 与 GUI 渲染线程互斥 事件触发线程 控制事件循环（鼠标点击、setTimeout、ajax 等） 当事件满足触发条件时，将回调事件放入到 JS 引擎所在的执行队列中 定时器触发线程 setTimeout、setInterval 中计时 计时完成后，通知事件触发线程 异步 HTTP 请求线程 浏览器中一个单独的处理 AJAX 请求的线程 当请求完成时，若有回调函数，通知事件处理线程 为了防止渲染结果不可预期，浏览器设定GUI渲染线程和JS引擎线程互斥，当JS引擎线程执行时GUI渲染线程挂起，GUI 更新则会在JS引擎线程空闲时立即被执行 JS 的运行机制 JS 分为同步任务和异步任务 同步任务在JS引擎线程上执行，形成一个执行栈，且JS引擎线程只执行执行栈中的事件 事件触发线程管理一个任务队列，异步任务触发条件达成，将回调事件放入任务队列中 事件队列中的回调事件，是由各自线程插入到事件队列中的 执行栈中所有同步任务执行完毕，此时JS引擎线程空闲，系统会读取任务队列，将可执行的异步任务回调事件添加到执行栈中，并执行 举例说明 setTimeout 定时任务当代码执行到 setTimeout 时，JS引擎线程通知定时器线程，间隔一段时间后，触发一个回调事件。而定时器线程在接受到这个消息后，在间隔时间后，将回调事件放入由事件触发线程所管理的事件队列中。 ajax 网络请求代码执行到 ajax 时，JS引擎线程通知异步HTTP请求线程，发送一个网络请求，并制定一个请求完成后的回调事件。而异步HTTP请求线程接受到这个消息后，会在请求成功后，将回调事件放入由事件触发线程管理的事件队列中 setTimeout， ajax 代码执行时，其本身是同步任务，而其中的回调函数才是异步任务。当同步任务执行完，JS引擎线程会询问事件触发线程，在事件队列中是否有待执行的回调函数，如果有的话，则加入到执行栈中，交给JS引擎线程执行 宏任务、微任务我们可以将每次执行栈执行的代码当做一个宏任务(包括每次从事件队列中获取一个事件回调并放入执行栈中执行)，每一个宏任务会从头到尾执行完毕，期间不会执行其他。因为JS引擎线程和GUI渲染线程互斥，浏览器为了能够是宏任务和DOM任务有序的进行，会在一个宏任务执行结束后，在一个宏任务执行前，GUI渲染线程开始工作，更新 DOM、对页面进行渲染。 主代码，setTimeout, setInterval 等，属于宏任务 微任务可以理解为：在当前宏任务执行后立即执行的任务。也就是说，在宏任务执行完，在渲染前，将执行期间所产生的所有微任务。Promise, process.nextTick，mutation observer 等，属于微任务 1// 宏任务 --&gt; 所有微任务 ---&gt; 渲染 ---&gt; 宏任务 ---&gt; 所有微任务 ---&gt;渲染 ... 总结 执行一个宏任务(执行栈中没有，从事件队列中取) 执行过程中遇到微任务,将把它添加到微任务队列中 宏任务执行完毕后，立即依次执行当前微任务队列中的所有微任务 当前宏任务执行完毕，开始检查渲染，然后GUI渲染线程接管渲染 渲染完毕后，JS引擎线程继续接管，开始下一个宏任务（从事件队列中获取） 宏任务/微任务（再总结）以下内容参考了该文章: 任务、微任务、队列和调度 (英文版)微任务执行时机（2 种情况）： after every callback, as long as no other JavaScript is mid-execution （在每个回调之后，没有其他 JavaScript 在执行时） at the end of each task （在每个宏任务执行完之后） 代码触发事件 / 鼠标、键盘等操作触发事件 鼠标、键盘等操作触发的事件，事件在 JS 执行栈中执行完后，执行栈为空，可执行加微任务。因冒泡触发其他事件加入执行栈，再次执行。 代码触发的事件，会先在 JS 执行栈执行script代码,再添加触发事件，触发事件执行完后，因 JS 执行栈还在执行script代码，故不可执行微任务。接着冒泡触发的事件加入执行栈执行。当所有冒泡事件执行完，script执行完后，才执行微任务队列。 示例内外两个 div，都注册了鼠标单击事件， 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot; /&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot; /&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot; /&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; .outer &#123; margin: 40px auto; width: 200px; height: 200px; display: flex; justify-content: center; align-items: center; background: chocolate; &#125; .inner &#123; width: 100px; height: 100px; background: navy; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div class=&quot;outer&quot;&gt; &lt;div class=&quot;inner&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;script&gt; let outer = document.querySelector(&quot;.outer&quot;); let inner = document.querySelector(&quot;.inner&quot;); new MutationObserver((mutations, observer) =&gt; &#123; // console.log(mutations, observer); let dataSetRandomVal = mutations[0].target.dataset.random; console.log(`$&#123;dataSetRandomVal&#125; - mutate`); &#125;).observe(outer, &#123; attributes: true &#125;); function onClick(event) &#123; let currentClassName = event.currentTarget.className; console.log(`$&#123;currentClassName&#125; - click`); setTimeout(() =&gt; console.log(`$&#123;currentClassName&#125; - timeout`), 0); Promise.resolve().then(() =&gt; console.log(`$&#123;currentClassName&#125; - promise`) ); outer.setAttribute(&quot;data-random&quot;, currentClassName); &#125; inner.addEventListener(&quot;click&quot;, onClick); outer.addEventListener(&quot;click&quot;, onClick); // outer.click(); // inner.click(); &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 点击外/内层 div,鼠标单击触发 12345678910111213141516单击outerdemo.html:41 outer - clickdemo.html:46 outer - promisedemo.html:36 outer - mutatedemo.html:43 outer - timeout单击innerdemo.html:41 inner - clickdemo.html:46 inner - promisedemo.html:36 inner - mutatedemo.html:41 outer - clickdemo.html:46 outer - promisedemo.html:36 outer - mutatedemo.html:43 inner - timeoutdemo.html:43 outer - timeout 执行 outer.click() / inner.click()，代码触发 1234567891011121314151617outer.click();demo.html:41 outer - clickdemo.html:46 outer - promisedemo.html:36 outer - mutateundefined // outer.click()执行完，无返回值demo.html:43 outer - timeoutinner.click()demo.html:41 inner - clickdemo.html:41 outer - clickdemo.html:46 inner - promisedemo.html:36 outer - mutate // MutationObserver的监听是异步触发，在所有的DOM操作完成后才触发使回调函数进入微任务队列，故这里触发一次demo.html:46 outer - promiseundefined // inner.click()执行完，无返回值demo.html:43 inner - timeoutdemo.html:43 outer - timeout","categories":[],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://better-jiang.github.io/tags/javascript/"}]},{"title":"《CSS权威指南4》- Chapter2.2 - 分组","slug":"《CSS权威指南4》-Chapter2-2-分组","date":"2019-12-02T07:30:38.000Z","updated":"2023-02-03T12:14:22.416Z","comments":true,"path":"2019/12/02/《CSS权威指南4》-Chapter2-2-分组/","link":"","permalink":"https://better-jiang.github.io/2019/12/02/%E3%80%8ACSS%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%974%E3%80%8B-Chapter2-2-%E5%88%86%E7%BB%84/","excerpt":"","text":"分组迄今为止，我们已经学习了将单个样式应用于单个选择器这种相当简单的技术。但是如果想要向多个元素应用同一个样式？如果是这样的话，则需要使用多个选择器，或者向一个或一组元素应用多个样式。 分组选择器假设希望h2和p元素文本都是灰色。最简单的实现方式是使用以下声明： 123h2, p &#123; color: gray;&#125; 将 h2和p选择器放在规则的左边，并使用逗号分隔，右边是样式（color：gray;）应用于两个选择器所指的元素,这样就定义了一个规则。逗号告诉浏览器，在该规则中涉及到两个不同的选择器。去掉逗号，会给这个规则带来完全不同的含义，我们将在“后代选择器”中对此进行讨论。实际上，将多少个选择器组合在一起是没有限制的，例如，想要显示大量的灰色元素，可以使用如下规则： 123body, table, th, td, h1, h2, h4, h5, p, pre, strong, em, b, i &#123; color: gray;&#125; 分组允许作者极大的压缩某些类型的样式，这样可得到一个更简单的样式表。以下的两组可选规则，产生相同的结果，但是可以很清楚的看出还一个更容易书写。 123456789h1 &#123;color: purple;&#125;h2 &#123;color: purple;&#125;h3 &#123;color: purple;&#125;h4 &#123;color: purple;&#125;h5 &#123;color: purple;&#125;h1, h2, h3, h4, h5 &#123; color: purple;&#125; 分组也允许一些有趣的选择。例如，以下例子中所有的规则分组都是等价的。每一个组仅展示了对选择器和声明 分组的不同方式。 123456789101112131415161718192021/* group 1 */h1 &#123;color: silver; background: white;&#125;h2 &#123;color: silver; background: gray;&#125;h3 &#123;color: white; background: grey;&#125;h4 &#123;color: silver; background: white;&#125;b &#123;color: gray; background: white;&#125;/* group 2 */h1, h2, h4 &#123;color: silver;&#125;h3 &#123;color: white;&#125;b &#123;color: gray;&#125;h1, h4, b &#123;background: white;&#125;h2, h3 &#123;background: gray;&#125;/* group 3 */h1, h4 &#123;color: silver; background: white;&#125;h2, h3 &#123;background: gray;&#125;h2 &#123;color: silver;&#125;h3 &#123;color: white;&#125;b &#123;color: gray; background: white;&#125; 通用选择器CSS2 引入了一个新的简单选择器，称为“通用选择器”，显示为一个星号（*）。这个选择器可以匹配任何元素，就像一个通配符。例如，要让一个文档中每一个元素都为红色，样式可以这样写。 1* &#123;color: red;&#125; 这个声明相当于一个分组选择器，它列出文档中包含的每个元素，通用选择器只需敲击键盘一次，就能把文档中所有元素的 color 属性赋值为 red。 但是，要注意：虽然通用选择器很方便，但是它的特性是 0-0-0；由于它的目标是其声明范围内的所有内容，因此它可能产生意想不到的结果，本书稍后对此进行讨论。 分组声明由于可以将选择器组合成单个规则，因此也可以对声明进行分组。假设你想要所有的h1元素的都呈现为紫色、高 18 像素、Helvetica 字体、浅绿色背景。可以这样编写样式： 123h1 &#123;font: 18px Helvetica;&#125;h1 &#123;color: purple;&#125;h1 &#123;background: aqua;&#125; 但是这种方法是低效率的，想象一下，为一个包含 10 或 15 个样式的元素创建这样一个列表！可以把声明放在一起来替代它。 1h1 &#123; font: 18px Helvetica; color: purple; background: aqua;&#125; 这将产生与以上展示的三行样式完全相同的效果。注意,在 对每个声明进行分组时，在其末尾使用分号是至关重要的。浏览器忽略样式表中的空白，因此用户代理必须依赖正确的语法来解析样式表。可以大胆的格式化样式如下： 12345h1 &#123; font: 18px Helvetica; color: purple; background: aqua;&#125; 也可以最小化 CSS，删除所有不需要的空格。 1h1&#123;font:18px Helvetica;color:purple;background:aqua;&#125; 忽略空白，最后一个也会被服务器平等对待，但是第二个最易读的，也是在开发过程中编写 CSS 的推荐方法。处于网络性能的考虑，你可能会选择最小化 CSS，但这通常是由服务端脚本、缓存网络或其他服务来处理的。如果第二个声明省略了分号，用户代理对样式表的解释如下： 1234h1 &#123; font: 18px Helvetica; color: purple background: aqua;&#125; 因为background:不是color的有效值，而且color只能有一个关键字，所有用户代理将完全忽略color声明（包括background: aqua;部分）。你可能以为浏览器至少会把h1元素渲染成没有浅绿色背景的紫色文本，但事实并非如此。相反，color将是默认的颜色（通常是黑色）,banckground是透明的（transparent，也是默认的）。声明font: 18px Helvetica仍然有效，因为它是用分号正确结束的。与选择器分组一样，声明分组是保持样式表简短、富有表现力、易于维护的一种便利方式。 分组一切现在你知道可以对选择器、声明进行分组。通过在单个规则中结合这两种类型的分组，可以仅使用几个语句来定义非常复杂的样式。现在，如果你想给文档中所有的标题分配一些复杂的样式，并且希望对所有的标题应用相同的样式，该怎么办？具体做法如下： 1234567h1, h2, h3, h4, h5, h6 &#123; color: gray; background: white; padding: 0,5em; border: 1px solid black; font-family: Charcoal, sans-serif;&#125; 这里我们将选择器分组，因此规则右侧的样式将应用于列出的所有标题。声明分组意为着所有列出的规则将应用于规则左侧的选择器。这种方法比冗长的替代方法更可取，后者的开头是这样的： 12345678910111213h1 &#123;color: gray;&#125;h2 &#123;color: gray;&#125;h3 &#123;color: gray;&#125;h4 &#123;color: gray;&#125;h5 &#123;color: gray;&#125;h6 &#123;color: gray;&#125;h1 &#123;background: white;&#125;h2 &#123;background: white;&#125;h3 &#123;background: white;&#125;h4 &#123;background: white;&#125;... 并继续许多行。你可以编写这样长的样式，但不建议使用。因为在编辑更改时，它们江河到处使用的样式属性一样繁琐乏味。可以向选择器添加更多的表达式，并以一种有利于信息类型的元素间切换的方式来应用样式。想要得到如此强大的功能，需要先做些准备工作，但这是非常值得的。 新元素在老旧的浏览器随着 HTML 的更新，如 HTML5 规范，新的元素已经出现。有一些浏览器比这些新元素更早，所以不能识别它们。比如，IE9 之前的 ie 版本，不支持选择它们不理解的元素，解决方案是在 DOM 中创建该元素，从而告知浏览器该元素存在。例如， IE8 不能识别&lt;main&gt;元素，一些 JavaScript 将告知main元素的存在: 1document.createElement(&#x27;main&#x27;); 通过运行这行代码，旧版本的 IE 将识别元素的存在，从而允许对其进行选择和样式。","categories":[{"name":"技术总结","slug":"技术总结","permalink":"https://better-jiang.github.io/categories/%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%93/"}],"tags":[{"name":"翻译","slug":"翻译","permalink":"https://better-jiang.github.io/tags/%E7%BF%BB%E8%AF%91/"},{"name":"CSS权威指南-第四版","slug":"CSS权威指南-第四版","permalink":"https://better-jiang.github.io/tags/CSS%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97-%E7%AC%AC%E5%9B%9B%E7%89%88/"}]},{"title":"《CSS权威指南4》- Chapter2.1 - 基本样式规则","slug":"《CSS权威指南4》-Chapter2-1-基本样式规则","date":"2019-11-29T07:48:23.000Z","updated":"2023-02-03T12:14:22.416Z","comments":true,"path":"2019/11/29/《CSS权威指南4》-Chapter2-1-基本样式规则/","link":"","permalink":"https://better-jiang.github.io/2019/11/29/%E3%80%8ACSS%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%974%E3%80%8B-Chapter2-1-%E5%9F%BA%E6%9C%AC%E6%A0%B7%E5%BC%8F%E8%A7%84%E5%88%99/","excerpt":"","text":"选择器CSS 的主要优点之一就是它很容易将一组样式应用于同一类型的所有元素。还无动于衷？请考虑这种情况：只通过编辑一行 CSS，就可以改变所有标题的颜色。不喜欢现在用的蓝色？改变一行代码，它们可以时紫色、黄色、栗色或者任何你想要的其他颜色。这能让作为设计者的你，专注于设计，而非枯燥繁重的工作。下次开会时，如果有人希望标题带有绿色的阴影，只要编辑样式，然后点击重新加载，只需几秒中就可完成，每个人都可以看到结果了。CSS 并不能解决所有问题。例如，你不能改变图片的颜色，至少现在还不能。但是 CSS 能更容易做些全局性的修改。所有先从选择器和结构开始介绍。 基本样式规则如上所述，CSS 是一个核心特性是能将某些规则应用于文档中的整个的一组元素类型。例如，假设你想要让所有的h2元素的文本显示为灰色，如果使用老式的 HTML，必须在所有h2元素中插入&lt;font color=&quot;gray&quot;&gt;...&lt;/font&gt;标签。使用style属性，这也是一种不好的做法，需要在所有的h2元素中包含style=&quot;color: gray;&quot;,如下所示： 12&lt;h2&gt;&lt;font color=&quot;gray&quot;&gt;h2 text&lt;/font&gt;&lt;/h2&gt;&lt;h2 style=&quot;color: gray;&quot;&gt;h2 text&lt;/h2&gt; 如果文档中包含大量的h2元素，这将是一个冗长繁琐的过程。更糟糕的是，如果你后来又决定要让所有h2元素都是绿色而不是灰色，就必须重新再来一次，手动地设置标签。CSS 则可以创建易于更改、编辑和应用于你定义的所有文本元素的规则。例如，编写以下规则一次，就能让 所有h2元素变成灰色 ： 123h2 &#123; color: gray;&#125; 如果想将所有h2文本变成其他颜色，如 银色，只需要改变 color 属性的值： 123h2 &#123; color: silver;&#125; 元素选择器元素选择器通常是 HTML 元素，但也不完全如此。例如，如果 CSS 文件中包含 XML 文档的样式，选择器可能如下所示 ： 123456789101112quote &#123; color: gray;&#125;bib &#123; color: red;&#125;booktitile &#123; color: purple;&#125;myElement &#123; color: red;&#125; 换句话说，文档的元素充当了最基本的选择器。在 XML 中，选择器可以是任意的，因为 XML 允许创建新的标记语言，它可以包含任何元素名。另一方面，如是设置 HMTL 文档的样式，选择器 通常是众多 HTML 元素的一个。如p, h3, em, a，甚至可以是html本身。例如： 123456789html &#123; color: black;&#125;h1 &#123; color: gray;&#125;h2 &#123; color: silver;&#125; 一旦全局地将样式直接向应用于元素，就可以将这些样式从一个元素切换到另一个元素。假你决定段落文本设置成灰色，而不是h1元素，没问题 ，只需把h1选择器改成p： 123456789html &#123; color: black;&#125;p &#123; color: gray;&#125;h2 &#123; color: silver;&#125; 声明和关键字声明块包含一个或多个声明。一个声明格式通常是一个属性后跟冒号，然后是值跟分号(property:value;)。冒号和分号后可以跟一个或多个空格。在几乎所以情况下，值可以是单个关键字，也可以是其属性允许的一个或多个关键字的空格分隔列表。如果在声明中使用的错误的属性或值，则整个规则将被忽略。因此，以下两个声明将失败： 12brain-size: 2cm; /* 未知的属性-“brain-size” */color: ultrviolet;/* 未知的值-“ultraviolet” */ 在可以使用多个关键字表示属性值的情况下，关键字通常由空格分隔，由些情况下需要斜杠（/）或逗号（,）。并不是每个属性的值都可以接受多个关键字，但是有许多可以，比如font属性。假如想要为段落文本定义一个中等大小的 Helvetica 字体,样式规则如下: 123p &#123; font: medium Helvetica;&#125; 注意medium和Helvetica之间有空格，它们每一个都是关键字，第一个是字体大小，第二个是实际的字体名称。空格使得用户代理（浏览器）区分这两个关键字并正确的使用它们。冒号表示该声明已经结束了。这些被空格分隔的单词被成为关键字，它们合在一起构成了所讨论的属性的值。例如，考虑以下虚构的规则： 1rainbow: red orange yellow green blue indigo violet; CSS 中并不存在rainbow这样的属性，但这个例子对于说明目有关概念很有用。 rainbow 的值是red orange yellow green blue indigo violet, 七个关键字加起来就是一个独特的值。我们可以重新定义 rainbow 的值： 1rainbow: infrared red orange yellow green blue indigo violet ultraviolet; 现在我们 rainbow 有了一个新的值，它由九个关键字组成而不是七个了，尽管这两个值看起来很相似，但是它们是独特的、不同的，就像 0 和 1 一样。这似乎是一个抽象的观点，但它对于理解特性的一些微妙影响和继承性（cascade）是至关重要的。 正如我们所看到的，CSS 关键字通常由空格分隔。在 CSS2.1 中，有一个例外，在 CSS 字体（font）属性，只有一个地方可以用正斜杠（/）来分隔两个特定的关键字。 123h2 &#123; font: large/150% sans-serif; /* font-ize and line-height */&#125; 正斜杠分隔了设置元素字体大小（font-size）和行高（line-height）的关键字。这是字体声明中唯一允许出现正斜杠的地方，其他所有允许用于字体的关键字都用空格分隔。自此以后，斜杠进入了许多其他属性的值中，包括但不一定限于以下内容： background bg-color bg-image positon/bg-size bg-repeat bg-origin bg-clip bg-attachment border-radius 1-4 length|% / 1-4 length|% |intial|inherit; grid grid-area grid-row-start / grid-column-start / grid-row-end / grid-column-end | itemname; grid-column grid-column-start / grid-column-end; grad-row grid-row-start / grid-row-end; grid-template mask-border 还有一些用逗号分隔的关键字。在声明多个值时，例如多背景图像（background image），过渡属性（transition）、阴影（shadow）。此外，函数中的参数，例如线性梯度（linear gradient），变换（transform）是用逗号风格的。如下例所示： 12345678910.box &#123; box-shadow: inset -1px -1px white, 3px 3px 2px rgba(0,0,0,0.2); /*多层次的阴影效果 */ background-image: url(image.png), linear-gradient(180deg,#fff,0%,#000,100%); transform: translate(100px, 200px);&#125;a:hover &#123; transition: color, background-color 200ms ease-in 50ms;&#125; 这些是简单声明的基础，但它们可能变得更加复杂。下一节向您展示 CSS 的强大功能。","categories":[{"name":"技术总结","slug":"技术总结","permalink":"https://better-jiang.github.io/categories/%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%93/"}],"tags":[{"name":"翻译","slug":"翻译","permalink":"https://better-jiang.github.io/tags/%E7%BF%BB%E8%AF%91/"},{"name":"CSS权威指南-第四版","slug":"CSS权威指南-第四版","permalink":"https://better-jiang.github.io/tags/CSS%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97-%E7%AC%AC%E5%9B%9B%E7%89%88/"}]},{"title":"节流与防抖","slug":"节流与防抖","date":"2019-11-26T11:15:58.000Z","updated":"2023-02-03T12:14:22.416Z","comments":true,"path":"2019/11/26/节流与防抖/","link":"","permalink":"https://better-jiang.github.io/2019/11/26/%E8%8A%82%E6%B5%81%E4%B8%8E%E9%98%B2%E6%8A%96/","excerpt":"","text":"节流和防抖是的两种广泛使用的技术，用于提高在一段时间内重复执行的代码的性能。这两个函数通常用于处理这样的情况：用户正在导致事件处理程序重复触发，而我们希望降低底层函数调用的速度。比如，滚动处理程序，键盘事件、甚至只是快速的点击一个按钮。 节流（Throttle）函数在指定的时间段内最多执行一次。固定周期内，函数只执行一次，若在该周期内又调用该函数，则不执行。周期结束后，又有调用，则开始新的周期。 简单实现12345678910111213function throttle(func,timeout) &#123; let ready = true; return (...args) =&gt; &#123; if(!ready) &#123; return; &#125; ready = false; func(...args); setTimeout(() =&gt; &#123; ready = true; &#125;, timeout); &#125;&#125; 节流策略有 2 种： 周期结束后 执行动作 (函数在每个等待时延的结束被调用，trailing：true) 执行动作后 开始周期 (函数在每个等待时延的开始被调用， leading： true) 防抖（Debounce）函数在停止调用以后的指定时间段后执行。当调用函数 n 秒后，才会执行，若在这 n 秒内又调用了该函数，则取消前一次计时并重新计算执行的时间。 简单实现123456789function debounce(func,timeout) &#123; let timer; return (...args) =&gt; &#123; clearTimeout(timer); timer = setTimeout(() =&gt; &#123; func(...args); &#125;,timeout); &#125;&#125; 防抖策略也有 2 种： 周期结束后 执行动作 (函数在每个等待时延的结束被调用，trailing：true) 执行动作后 开始周期 (函数在每个等待时延的开始被调用， leading： true) lodash 内 _throttle 与 _debounce_debounce(func,[wait=0],[options={}])创建一个 debounced（防抖动）函数，该函数会从上一次被调用后，延迟 wait 毫秒后调用 func 方法。 debounced（防抖动）函数提供一个 cancel 方法取消延迟的函数调用以及 flush 方法立即调用。 可以提供一个 options（选项） 对象决定如何调用 func 方法，options.leading 与|或 options.trailing 决定延迟前后如何触发（是 先调用后等待 还是 先等待后调用）。 func 调用时会传入最后一次提供给 debounced（防抖动）函数 的参数。 后续调用的 debounced（防抖动）函数返回是最后一次 func 调用的结果。 注意： 如果 leading 和 trailing 选项为 true,则 func 在 wait 期多次调用防抖方法 如果 wait 为 0 并且 leading 为 false, func 调用将被推迟到下一个点，类似 setTimeout 为 0 的超时 options参数中定义了一些选项：主要有以下 3 个： leading ， 函数在每个等待时延的开始被调用，默认值：false trailing ， 函数在每个等待的结束时被调用，默认值：true maxwait ， 最大的等待时间，因为 _debounce 的函数调用时间不满足条件，可能永远都无法触发，增加该配置，保证了大于一段时间后一定能执行一次函数。 _debounce 还有cancel方法，用于取消防抖调用 _throttle(func,[wait=0],[options{}])创建一个节流函数，在 wait 秒内最多执行 func 一次的函数。 该函数提供一个 cancel 方法取消延迟的函数调用以及 flush 方法立即调用。 可以提供一个 options 对象决定如何调用 func 方法， options.leading 与|或 options.trailing 决定 wait 前后如何触发。 func 会传入最后一次传入的参数给这个函数。 随后调用的函数返回是最后一次 func 调用的结果 注意： 如果 leading 和 trailing 都为 true 则 func 在 wait 期间会被多次调用 如果 wait 为 0，并且 leading 为 false，func 调用将被推迟到下一个点，类似 setTimeout 为 0 的超时 _throttle 其实就是设置了 maxwait 的 debounce. optinons参数同样定义了leading和trailing选项，与 debounce 含义相同。 用例：_debounce 源码: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127function debounce(func, wait, options) &#123; let lastArgs; let lastThis; let maxWait; let result; let timerId; let lastCallTime; // 上次调用时间 let lastInvokeTime = 0; // 上次执行时间 let leading = false; let maxing = false; let trailing = true; if (typeof func !== &quot;function&quot;) &#123; throw new TypeError(&quot;Expected a function&quot;); &#125; wait = +wait || 0; if (isObject(options)) &#123; leading = !!options.leading; // 如果 options 选项中有 maxWait 属性， // maxWait 取 wait 和 maxWait 2者最大值，不在取 0 maxing = &quot;maxWait&quot; in options; maxWait = maxing ? Math.max(+options.maxWait || 0, wait) : maxWait; trailing = &quot;trailing&quot; in options ? !!options.trailing : trailing; &#125; function isObject(value) &#123; const type = typeof value; return value != null &amp;&amp; (type === &quot;object&quot; || type === &quot;function&quot;); &#125; function invokeFunc(time) &#123; let args = lastThis; let thisArg = lastThis; lastAr = lastThis = undefined; lastInvokeTime = time; result = func.apply(thisArg, args); return result; &#125; // 函数是否执行 function shouldInvoke(time) &#123; const timeSinceLastCall = time - lastCallTime; const timeSinceLastInvoke = time - lastInvokeTime; return ( lastCallTime === undefined || // 首次调用 timeSinceLastCall &gt;= wait || // 距离上次被调用已经超过 wait timeSinceLastCall &lt; 0 || // 系统时间倒退 (maxing &amp;&amp; timeSinceLastInvoke &gt;= maxWait) // 距离上次执行超过了最大等待时间 ); &#125; // 在 leading edge 阶段执行函数 function leadingEdge(time) &#123; lastInvokeTime = time; timerId = setTimeout(timerExpired, wait); // leading = true 执行函数，否则返回 reuslt return leading ? invokeFunc(time) : result; &#125; function trailingEdge(time) &#123; timerId = undefined; // 有lastArgs才执行，意味着 只用func 已经被debounced过一次以后才会在 trailing edge 执行 if (trailing &amp;&amp; lastArgs) &#123; return invokeFunc(time); &#125; // 每次trailing edge都会被清除 lastArgs 和lastThis，避免最后一次函数执行2次 // 例如：最后一次函数执行时，恰好是前一次的trailing edge，函数被调用；而在自己时延的trailing Edge，又会被调用一次 lastArgs = lastThis = undefined; return result; &#125; // 定时器 function timerExpired() &#123; let time = Date.now(); if (shouldInvoke(time)) &#123; return trailingEdge(time); &#125; timerId = setTimeout(timerExpired, remainingWait(time)); &#125; //剩余时间 function remainingWait(time) &#123; let timeSinceLastCall = time - lastCallTime; let timeSinceLastInvoke = time - lastInvokeTime; // 下一次 trailing 时间 let timeWaiting = wait - timeSinceLastCall; // 两种情况， // 有maxing: 比较下一次maxing和下一次trailing的最小值，作为下一次函数执行的时间 // 无maxing， 下一次trailing时，执行timerExpired return maxing ? Math.min(timeWaiting, maxWait - timeSinceLastInvoke) : timeWaiting; &#125; function debounced(...args) &#123; const time = Date.now(); const isInvoking = shouldInvoke(time); lastArgs = args; lastThis = this; lastCallTime = time; if (isInvoking) &#123; if (timerId === undefined) &#123; return leadingEdge(lastCallTime); &#125; if (maxing) &#123; timerId = setTimeout(timerExpired, wait); return invokeFunc(lastCallTime); &#125; &#125; if (timerId === undefined) &#123; timerId = setTimeout(timerExpired, wait); &#125; return result; &#125; function flush() &#123; return timerId === undefined ? result : trailingEdge(Date.now()); &#125; function cancel() &#123; if (timerId !== undefined) &#123; clearTimeout(timerId); &#125; lastInvokeTime = 0; lastArgs = lastCallTime = lastThis = timerId = undefined; &#125; debounced.cancel = cancel; debounced.flush = flush; return debounced;&#125; _throttle 源码： 1234567891011121314151617181920212223242526272829// 用例 * // Avoid excessively updating the position while scrolling. * jQuery(window).on(&#x27;scroll&#x27;, throttle(updatePosition, 100)) * * // Invoke `renewToken` when the click event is fired, but not more than once every 5 minutes. * const throttled = throttle(renewToken, 300000, &#123; &#x27;trailing&#x27;: false &#125;) * jQuery(element).on(&#x27;click&#x27;, throttled) * * // Cancel the trailing throttled invocation. * jQuery(window).on(&#x27;popstate&#x27;, throttled.cancel) *function throttle(func, wait, options) &#123; let leading = true; let trailing = true; if (typeof func !== &quot;function&quot;) &#123; throw new TypeError(&quot;Expected a function&quot;); &#125; if (isObject(options)) &#123; leading = &quot;leading&quot; in options ? !!options.leading : leading; trailing = &quot;trailing&quot; in options ? !!options.trailing : trailing; &#125; return debounce(func, wait, &#123; leading, trailing, maxWait: wait &#125;);&#125;","categories":[{"name":"技术总结","slug":"技术总结","permalink":"https://better-jiang.github.io/categories/%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%93/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://better-jiang.github.io/tags/javascript/"}]},{"title":"《CSS权威指南4》- Chapter1.4 - 特性查询","slug":"《CSS权威指南4》-Chapter1-5-特性查询","date":"2019-11-26T01:11:47.000Z","updated":"2023-02-03T12:14:22.416Z","comments":true,"path":"2019/11/26/《CSS权威指南4》-Chapter1-5-特性查询/","link":"","permalink":"https://better-jiang.github.io/2019/11/26/%E3%80%8ACSS%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%974%E3%80%8B-Chapter1-5-%E7%89%B9%E6%80%A7%E6%9F%A5%E8%AF%A2/","excerpt":"","text":"特性查询在 2015 到 2016 年之间，CSS 获得了在特定情况下（即浏览器支持的 CSSs 属性-值的组合下）应用 CSS 块的能力。这被称为特性查询。他们在结构上与媒体查询非常相似。考虑这样一种情况：如果 color 是受支持的属性，那么就对元素应用 color。它是这样的： 12345@supports (color:black) &#123; body &#123;color: black;&#125; h1 &#123;color: purple;&#125; h2 &#123;color: navy;&#125;&#125; 实际上，它意味着“如果理解并能处理color: black这样的属性-值组合，就应用这些样式，否则，就跳过这些样式”。在不理解@supports的用户代理（浏览器等）中，整个 CSS 规则块被跳过。 特性查询是渐进增强样式的完美方法。例如，假设想在现有的浮动和内联块布局中添加一些网格布局，可以保留旧的布局方案，然后在样式表中包含这样的块： 12345@supports (display: grid) &#123; section#main &#123;display: grid;&#125; /*styles to switch off old layout*/ /*grud layout styles*/&#125; 这样样式将应用于支持网格显示的浏览器中，覆盖旧的页面布局样式，然后应用所需的样式使其在基于网格的未来中生效。太老的浏览器无法支持网格布局，也很可能因太老而无法支持@supports,所以他们完全的跳过整个块，就好像从来没出现过一样。特性查询 可以彼此 嵌入，也可以嵌入到媒体查询中，反之亦然。编写基于弹性盒子布局的屏幕、打印的样式，将媒体查询包裹在@support (display: flex)块中： 12345678@supports (display: flex) &#123; @media screen &#123; /*screen flexbox styles go here */ &#125; @media print &#123; /*print flexbox styles go here */ &#125;&#125; 相反，可以在各种响应设计的媒体查询块中，添加@supports () 块： 12345678910@media screen and (max-width: 30em) &#123; @supports (display: flex) &#123; /*small-screen flexbox styles go here*/ &#125;&#125;@media screen and (min-width: 30em) &#123; @supports (display: flex) &#123; /* large-screen flexbox styles go here */ &#125;&#125; 如何组织这些区块完全取决自己。 与媒体查询一样，特性查询也允许有逻辑操作符。假设想要在一个用户代理同时支持网格布局和 CSS 形状（shapes）时应用样式，应该这样的： 1234@supports (display: grid) and (shape-outside: circle()) &#123; /* grid-and-shape styles go here */&#125; 这基本上等价于以下写法： 123456@supports (display: flex) &#123; @supports (shape-outside: circle()) &#123; /* */ &#125;&#125; 除了and操作符外，还有更多可用的操作。CSS 形状是个很好的例子去说明为什么or是 有用的。因为在很长一段时间 webkit浏览器只支持通过 带厂商前缀属性的 CSS 形状。所以，如果用形状，可以这样使用特性查询： 1234@supports (shape-outside: circle()) or (-webkit-shape-outside: circle()) &#123; /* shape styles go here */&#125; 你仍然需要确保同时使用带前缀和不带 前缀的形状属性，这将支持 webkit 发行版本，并向后兼容，同时也支持其他支持 形状的浏览器，但不是通过带前缀的属性。 特性查询也可以使用not。例如，在不支持网格布局时应用以下样式： 123@supports not (display: grid) &#123; /* grid-not-suppoted styles go here*/&#125;","categories":[{"name":"技术总结","slug":"技术总结","permalink":"https://better-jiang.github.io/categories/%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%93/"}],"tags":[{"name":"翻译","slug":"翻译","permalink":"https://better-jiang.github.io/tags/%E7%BF%BB%E8%AF%91/"},{"name":"CSS权威指南-第四版","slug":"CSS权威指南-第四版","permalink":"https://better-jiang.github.io/tags/CSS%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97-%E7%AC%AC%E5%9B%9B%E7%89%88/"}]},{"title":"《CSS权威指南4》- Chapter1.4 - 媒体查询","slug":"《CSS权威指南4》-Chapter1-4-媒体查询","date":"2019-11-25T01:22:19.000Z","updated":"2023-02-03T12:14:22.416Z","comments":true,"path":"2019/11/25/《CSS权威指南4》-Chapter1-4-媒体查询/","link":"","permalink":"https://better-jiang.github.io/2019/11/25/%E3%80%8ACSS%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%974%E3%80%8B-Chapter1-4-%E5%AA%92%E4%BD%93%E6%9F%A5%E8%AF%A2/","excerpt":"","text":"媒体查询使用媒体查询，作者可以定义浏览器使用给定的样式表的媒体环境。在过去，这是通过手动在link元素、style元素或使用@import、@media声明设置上设置媒体类型来实现的。媒体查询通过允许作者使用所谓的媒体描述符根据给定媒体类型的特性选择样式表，将这一概念又向前推进了几步。 用法媒体查询可以在以下地方使用： link 元素 的 media 属性 style 元素 的 media 属性 @import 声明 的媒体描述符部分 @media 声明 的媒体描述符部分 媒体的查询范围可以从简单的媒体类型到复杂的媒体类型和特性 组合 简单的媒体查询在介绍媒体查询的所以可能性之前，让我们先看看简单的媒体块。假设我们想要一些不同的样式用于在投影设置中显示样式的情况，例如幻灯片显示。这里有两个简单的 CSS 片段： 123456789h1 &#123; color: maroon;&#125;@media projection &#123; body &#123; background: yellow; &#125;&#125; 在本例中，h1 元素 将在所以媒体中被涂成褐红色，但是 body 元素只在投影媒介中才会得到黄色背景。在给定的样式表中可以有任意数量的@media 块，每个块都有自己的一组媒体描述符，甚至可以将所以规则封装在一个@media 块中： 12345678@media all &#123; h1: &#123; color: maroon; &#125; body &#123; background: yellow; &#125;&#125; 在这些例子中projection和all的地方就是设置媒体查询的地方。这些查询依赖于 媒体类型的描述 和 媒体参数的描述 的组合，以 CSS 块确定何时被应用。 媒体类型媒体查询最基本的形式是媒体类型，它首次出现在 CSS2 中。以下是不同媒体类型的简单标签： all，适用所有的展示媒体 print，为有视力是用户打印文档时使用，也用于文档的打印预览展示 screen, 当以屏幕媒体（如桌面计算机显示器）显示文档时使用。所以的 web 浏览器也都是屏幕介质的用户代理。一些浏览器也支持投影，它允许文档以幻灯片的形式显示。一些移动浏览器支持 手持类型（handheld）。 可以使用逗号分隔的列表指定多个每媒体类型。以下四个例子都是在屏幕和打印媒体中应用样式表（或规则块）的等效方法： 123456&lt;link type=&quot;text/css&quot; href=&quot;demo.css&quot; media=&quot;screen, print&quot;&gt;&lt;style type=&quot;text/css&quot; media=&quot;sreen, print&quot;&gt; body &#123; font-size: 15px; &#125;&lt;/style&gt; 1234@import url(foo.css) screen, print;@media screen, print &#123; font-size: 15px;&#125; 当向这些媒体类型添加特性的描述符时，会更有趣。例如 描述给定媒体的分辨率或颜色深度的值。 媒体描述符对于任何曾经在 link 元素或@import 声明上设置过媒体类型的作者，媒体查询的位置将是非常熟悉的。以下是在彩色打印机上渲染文档时应用外部样式表的两种本质上等效的方法： 123&lt;link href=&quot;print-color.css&quot; type=&quot;text/css&quot; media=&quot;&quot;print and (color) rel=&quot;stylesheet&quot;&gt;@import url(print-color.css) print and (color); 在可以使用媒体类型的任何地方，都可以使用媒体查询。这意味着，按照上一级的示例，可以在逗号分隔的列表中列出多个查询： 123&lt;link href=&quot;print-color.css&quot; tyoe=&quot;text/css&quot; media=&quot;print and (color), screen and (color-depth:8)&quot; ref=&quot;stylesheet&quot;&gt;@import url(print-color.css) print and (color), screen and (colo-depth: 8); 在任何情况下，即使其中一个媒体查询的结果未“true”,也会应用相关联的样式表。因此，前面给定的@import,print-color.css被应用在彩色打印机或彩色足够充足的屏幕环境。如果在黑白打印机上打印，两个查询结果都是“false”,print-color.css将不会应用到文档中。这同样适用于任何屏幕媒体。 每个媒体描述符由一个媒体类型和一个或多个列出的媒体特性组成，每个媒体特性描述符使用括号括起。如果没有提供媒体类型，则假设为 all，这使得下面两个例子等价： 12@media all and (min-resolution: 96dpi) &#123; ... &#125;@media (min-resolutionL 96dpi) &#123; ... &#125; 一般来讲，媒体特性描述符的格式类似于 CSS 中的属性-值 对。有些不同之处，最明显的是一些特性可以在没有值的情况指定。例如，任何基于颜色的媒体都将使用（color）进行匹配，而任何使用 16 位颜色深度的媒体都将是使用（color: 16）进行匹配。实际上，使用没有值的描述符是对该描述符的真/假测试：（color）的意思是“这个媒介是彩色的吗？” 多个特性描述符可以用and逻辑关键字链接。事实上，媒体查询有两个逻辑关键字： and将两个或多个媒体特性链接在一起，所有特性都为真，查询才为真。例如：(color) and (orentation: landscape) and (mid-device-width: 800px)意味着必须满足所有 3 个条件，如果媒体环境有颜色，处于横向方向，并且设备的显示宽度至少为 800px，这样样式表才被应用。 not否定整个查询，如果所以条件都为真，则不应用样式表。例如：not (color) and (orientation: landscape) and (min-device-widht: 800px)意味着如果满足所以 3 个条件，则否定该语句。因此，如果媒体环境有颜色，是横向的，而且设备的显示宽度至少 800px，那么样式表将不被应用。在所以其他情况下，样式表都将被应用。注意： not 关键字 只能在媒体查询开头使用。像(color) and not (min-device-width: 800px)的代码是不合法的，在这种 情况下，查询将被忽略。 媒体查询中没有OR关键字。实际上，分隔查询列表的逗号具有 OR 的功能。print, screen意思是“如果媒体是打印机或屏幕”。screen and (max-color: 2) or (monochrome)是不合法的，将被忽略。因该写成screen and (max-color: 2), screen and (monochrome). 还有一个关键字only，它被设计成故意向后不兼容 only用于隐藏样式表，使其不被那些太老旧而不支持媒体查询的浏览器看到。例如，要将样式表应用于所有媒体，但只适用于那些支持媒体查询的浏览器，应该写成@import url(new.css) only all。支持媒体查询的浏览器中，only 关键字会被忽略，样式表被应用。在不支持的浏览器中，only 关键字创建了一个明显的媒体类型only all，这是无效的，因此，样式表不会应用于 这些浏览器。*注意： only 关键字只能用在媒体查询的开头。 媒体特性描述符和值类型迄今为止，我们已经在示例中看到了许多媒体特性描述符，但是还没有一个完整的列表 ，下面是所有可能的描述符列表（目前截至到 2017 年底）： with aspect-ratio color-index min-width min-aspect-ratio min-color-index max-width max-aspect-ratio max-color-index device-width device-aspect-ratio momochrome min-device-width min-device-aspect-ratio min-monochrome max-device-width max-device-aspect-ratio max-monochrome height color resolution min-height min-color min-resolution max-height max-color max-resolution device-height orientation min-device-height ratio scan max-device-height resolution grid","categories":[{"name":"技术总结","slug":"技术总结","permalink":"https://better-jiang.github.io/categories/%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%93/"}],"tags":[{"name":"翻译","slug":"翻译","permalink":"https://better-jiang.github.io/tags/%E7%BF%BB%E8%AF%91/"},{"name":"CSS权威指南-第四版","slug":"CSS权威指南-第四版","permalink":"https://better-jiang.github.io/tags/CSS%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97-%E7%AC%AC%E5%9B%9B%E7%89%88/"}]},{"title":"Vue调试工具(Vue-DevTools)使用指南","slug":"Vue调试工具Vue-DevTools使用指南","date":"2019-11-21T10:47:25.000Z","updated":"2023-02-03T12:14:22.416Z","comments":true,"path":"2019/11/21/Vue调试工具Vue-DevTools使用指南/","link":"","permalink":"https://better-jiang.github.io/2019/11/21/Vue%E8%B0%83%E8%AF%95%E5%B7%A5%E5%85%B7Vue-DevTools%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/","excerpt":"","text":"安装可查看 vue-DevTools 文档 5 种常用调试方法Vue DevTools 使得在运行时调试 Vue 应用程序变得很容易，以下会介绍在调试 Vue 中常用的 5 中方法 1. 实时编辑组件 data 数据当在使用 Vue 构建组件时，我们希望能实时去操作组件 data 数据。IDE 中更新 data 后，然后再去浏览器中查看结果比较麻烦，已经不适合了。 Vue-DevTools 允许 我们在运行时去 编辑组件 data 打开浏览器调试工具，导航到 Vue tab 在 tab 左列选择组件 在 tab 右列 编辑 组件 data数据 默认情况下，prop 数据是不可编辑的，但我们可以在 settingstab 设置为可编辑状态 使用此功能，我们可以编辑所以 data 类型,切换 boolean 值，操作数组，我们还可以操作来自远端 API 的数据，只要我们把它加载到 vue 组件内，就可以对其实时操作了。 2. 组件/ DOM 快速定位 组件 tab Inspect DOM,可快速定位该组件在 DOM 中位置 组件 tab select in component in page，可点击页面元素，快速定位其所属组件 3. 跟踪自定义事件Vue Devtools 可以跟踪我们在 Vue 应用中使用的定义事件，查看事件是否正确触发，检查它们携带是数据（payload）Vue Devtools 只能跟踪自定义事件，即使用this.$emit(&#39;myEvent&#39;)触发的事件，不能跟踪绑定到组件上的事件比如v-on:ckick、v-on:keyup 监视 路由历史和数据当我们使用 Vue 构建单页面应用时，希望能实时调试路由并跟踪整个应用的导航流。Vue DevTools 有一个 Routing tab，记录了路由变化时的历史和数据。Routing tab 有 2 个选项： Hishtory 显示 路由的历史和其数据 Routes 显示 应用中所有的路由及其 options 调试 Vuex 行为，回到过去状态Vuex是 Vue 的状态管理库，它运行我们以可预知的形式管理和更新应用的状态。Vue Devtools 可以让我们在运行时检查状态，以便调试。Vuex tab ，记录了应用状态，每当Vuex派发一个更新（dispatch a mutation）。它还允许我们在运行时 回退到以前 Vuex 的状态。","categories":[{"name":"技术总结","slug":"技术总结","permalink":"https://better-jiang.github.io/categories/%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%93/"}],"tags":[{"name":"vue","slug":"vue","permalink":"https://better-jiang.github.io/tags/vue/"}]},{"title":"《CSS权威指南4》- Chapter1.3 - 样式表内容","slug":"《CSS权威指南》-Chapter1-3-样式表内容","date":"2019-05-17T03:24:50.000Z","updated":"2023-02-03T12:14:22.416Z","comments":true,"path":"2019/05/17/《CSS权威指南》-Chapter1-3-样式表内容/","link":"","permalink":"https://better-jiang.github.io/2019/05/17/%E3%80%8ACSS%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97%E3%80%8B-Chapter1-3-%E6%A0%B7%E5%BC%8F%E8%A1%A8%E5%86%85%E5%AE%B9/","excerpt":"","text":"样式表内容在这之后，样式表的实际内容是什么？就像这样： 123h1 &#123; color: maroon;&#125; 诸如此类的样式构成了任何嵌入样式表的主体，可以简单也可以复杂，可以很多也可以很长。很少有文档的style元素不包含任何样式规则，尽管可以有一个简单的@import声明列表，而没像上一个示例那样的实际的规则。 在我们继续阅读该书剩余部分之前，有一些关于样式表中可以活不可以包含的顶级内容需要介绍。 标记(Markup)在样式表中没有标记，这似乎是显而易见的，但是你会惊讶。唯一的例外是 HTML 的注释标记，由于历史原因，它可以在style元素内部使用。 12345678h1 &#123; color: maroon;&#125;&lt;!--body &#123; background: yellow;&#125;--&gt; 规则结构为了更详细的说明规则的概念，我们要将规则的结构进行分解并逐一介绍。每一个样式规则有 2 个基本部分：选择器（selector）和声明块（declaration block）。声明块由一个或多个声明组成，每个声明是一个属性-值对。每个样式表由一系列规则组成。图 Figure1-7 显示了规则的各个部分。如规则左边所示，选择器定义了文档的哪些部分将受影响。图 Figure1-7 中，h1元素被选中。如果选择器是p，则会选择所要的p(段落)元素.规则的右边包含声明块，它由一个或多个声明组成。每个声明都是一个 CSS 属性和该属性值的组合。图 Figure1-7 中，声明块包含 2 个声明。第一个声明指出该规则将导致文档的部分颜色为红色，第二个声明指出文档中该部分的背景色为黄色。所以，文档中所有h1元素（由选择器定义）将以红色文本，黄色背景为样式。 供应商前缀（Vendor prefixing）有时你会看到 CSS 前面有破折号和标签，比如-o-border-image.它们被称为供应商前缀，是浏览器厂商 将属性、值或其他 CSS 的位标记为实验或专用（或两者都是）的一种方式。截止 2016 年底，市面上出现了一些供应商前缀，最常见的如表 1-1 所示。 Prefix Vendor -epub- 国际数字出版论坛 ePub 格式 -moz- 基于 MOzilla 的浏览器（Firefox） -ms- 微软 IE 浏览器 -o- 基于 Opera 的浏览器（Opera） -webkit- 基于 Webkit 的浏览器（Safari,Chrome） 正如表格 1-1 所示，供应商前缀普遍可接受的格式一个破折号，一个标签，一个破折号，尽管有几个前缀错误的省略了第一个破折号。供应商的使用和滥用是冗长的，扭曲的，并且超出了本书的范围。可以这样说，它们一开始是作为浏览器厂商测试新产品的一种方式，因此有助于提高互用性，而不用担心陷入与其他浏览器不兼容的遗留行为中。这避免了整个类的问题，在 CSS 初期它几乎扼杀了 CSS。不幸的是，前缀属性随后被 web 作者公开发行，最终导致了一系列全新的问题。截止 2016 年底，供应商前缀种类正在减少，旧的前缀属性和值慢慢的从浏览器实现中移除。你完全有可能永远不编写有前缀的 CSS，但是你会在市面上遇到它，或者从老旧的代码库中继承它。 空白处理CSS 基本对规则之间的空白不敏感，对规则内部的空白页不敏感，尽管有一些例外。一般来说，CSS 对待空白如 HTML 文档一样：为了进行解析，任何连续的空白字符都被折叠成一个空格。因此，你可以按照以下方式格式化假象的彩虹规则: 12345678910111213141516rainbow:infrared red orange yellow green blue indigo violet ultravilet;rainbow: infrared red orange yellow blue indigo violet ultraviolet;rainbow: infrared red orange yellow green blue indigo violet ultraviolet ; 唯一限制的是分隔字符必须是空白字符：空格，制表符、换行符，可以单独使用，也可以组合使用，个数不限，可任意使用类似的，你可以以任何喜欢的方式使用空白字符格式化一系列的 CSS 规则。 这是无限可能当中的 5 种： 1234567891011121314html&#123;color:black;&#125;body &#123;background: white;&#125;p &#123; color: gray;&#125;h2 &#123; color: silver ;&#125;ol &#123; color : silver ;&#125; 从第一个规则看出，空格能被最大限度的省略。实际上，这通常出现在压缩的 CSS 中，即删除所有多余的空格。在前两个规则之后，使用了越来越多的空格，直到最后一个规则，几乎所有能被分隔的东西，都被分隔到单独的一行中。所有这些都是有效的，所以你应该选择最合理的格式（也就是最容易阅读），并坚持下去。在某些方面，实际上需要出现空格。最常见的例子是在值中分隔关键词列表，就像彩虹例子一样，必须使用空格分隔。 CSS 注释css 允许注释，同C/C++注释相似，它们使用/*和*/包围要注释的内容： 1/* CSS 注释 */ 跨多行注释，像C++一样: 123/** 多行注释，没有问题/ 但是，CSS 注释不能嵌套,以下例子是不正确的： 123/* css内注释嵌套 /*是不正确的*/不在注释内*/ CSS 不存在类似//或#注释’一行其余部分’模式，只有/**/这一种模式。所以，如果你希望把注释与标签放在同一行，需要小心处置。例如，以下是正确的做法： 123h1 &#123;color:red&#125; /*css 注解 有多行，*/p &#123;font-size:12px&#125; /*但是，因为 它 在内容的旁边*/h2 &#123;width:20px&#125; /*所以，每一行都需要使用注释符号 包裹起来*/ 如果每一行没有注释符号，那么大部分样式将变成注释，从而不起作用。 123h1 &#123;color:red&#125; /*css 注解 有多行，p &#123;font-size:12px&#125; 但是，因为 它 在内容的旁边h2 &#123;width:20px&#125; 所以，每一行都需要使用注释符号 包裹起来*/ 这个例子中，只有第一个样式规则（h1 {color:red}）会被应用到文档，余下规则都成为注释部分，被浏览器渲染引擎忽略。","categories":[{"name":"技术总结","slug":"技术总结","permalink":"https://better-jiang.github.io/categories/%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%93/"}],"tags":[{"name":"翻译","slug":"翻译","permalink":"https://better-jiang.github.io/tags/%E7%BF%BB%E8%AF%91/"},{"name":"CSS权威指南-第四版","slug":"CSS权威指南-第四版","permalink":"https://better-jiang.github.io/tags/CSS%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97-%E7%AC%AC%E5%9B%9B%E7%89%88/"}]},{"title":"编程新理解（代码大全，代码整洁之道-读书摘要）","slug":"编程新理解（代码大全，代码整洁之道-读书摘要）","date":"2019-05-09T03:16:34.000Z","updated":"2023-02-03T12:14:22.416Z","comments":true,"path":"2019/05/09/编程新理解（代码大全，代码整洁之道-读书摘要）/","link":"","permalink":"https://better-jiang.github.io/2019/05/09/%E7%BC%96%E7%A8%8B%E6%96%B0%E7%90%86%E8%A7%A3%EF%BC%88%E4%BB%A3%E7%A0%81%E5%A4%A7%E5%85%A8%EF%BC%8C%E4%BB%A3%E7%A0%81%E6%95%B4%E6%B4%81%E4%B9%8B%E9%81%93-%E8%AF%BB%E4%B9%A6%E6%91%98%E8%A6%81%EF%BC%89/","excerpt":"","text":"人，多是无知与自大的，我也不例外。自认为挺聪明，也好学习，在编程上也有热爱之情。因此早已预设自己未来于编程道路上定有一番作为。还好，好奇心与读书拯救了深陷幻想中的我。顶级大神如何编程？有什么经验之谈？有哪些书籍能醍醐灌顶，影响程序员一生？带着疑惑，上网搜索，找到了一份程序员必读书单。草草通读完《代码整洁之道》，《代码大全》，对编程有了新认知，也正视了自己。编程需要注重细节，要计划先行，谋定而后动；本人无非一枚普通人罢了。空想无益，自大较无知更可怕，想实现理想，必须勤勤恳恳，早早养成好习惯。 编程是一种技艺甚于科学的东西，要编写整洁代码，必须先编写脏代码，然后再清理它！ 代码整洁 “离开时要比发现时更整洁”好事多磨，不论是维护他人的代码，还是更改自己的代码，都要抱此代码一定有改进的空间的想法，而不非仅仅只为完成特定功能而已。这样一来，多思考，产生多种改进方案，最后迭代出最好的方案，一步一步的使代码更整洁。 “Later equals never”稍后等于永不。想着先实现功能，代码混乱点，复杂点，没关系，先能完成需求，通过测试吧。以后有时间，再回过头来好好梳理，重构代码，不是还使用 TODO 标记了吗？这样一来，也保证自己不会忘记。亲身验证，如果测试已通过，这代码肯定不会去管了，即使有空闲时间，甚至是出现 bug，也仅仅是在原先的基础上修改，根本不会，也没胆量魄力完全抛弃烂代码，重新梳理需求，重新设计、再编写。 “花时间保持代码整洁，不但关乎效率，还关乎生存”不整洁的代码，难以维护，且错误百出；不但拖累开发效率，而且代码质量差，bug 层出，修改成本高，也容易引入新 bug，会越改越差，直到无法掌控，必须废弃为止。为了公司的生存，也要多花些时间去保持代码整洁，公司凉了，自己不也凉凉吗？ “做的快的唯一方法是保持代码整洁”之前认为，先快速上手，编写代码，完成主要功能需求即可。反正需求会改的，先做个大概，以后再根据需求边做边改。需求都没完全确定，写的代码没自然没必要花费时间保持代码整洁，做封装、设计、模块化、写单元测试都是扯淡，多此一举。事实证明，全错了，没搞清楚需求，没设计，直接上手写代码，就是自掘坟墓，bug 多，难修改，又不想舍弃重写，极其难受，一次次的向烂代码妥协，一次次的放弃编写整洁代码的机会，如何成长为一名光荣而优秀的程序员。 “逻辑直接了当，缺陷就难以隐藏；减少依赖，便于维护”编写逻辑清晰代码，依赖自然会减少，缺陷也就越容易被发现，也就越好维护。如果觉得编写困难，意味着对问题的认知不足，需求不明，逻辑不清，是没法编写高质量的代码的。归根结底，还是要清楚的理解需求，分解问题，设计好，多思考，尽力能设计出多种方案，再比较方案优劣，从中选出最优解。 “糟糕的代码引发混乱，别人修改时会越改越烂。所以，把代码调至最优，省的别人做没有规矩的优化，搞出一堆混乱来”本人打心里不希望别人来改自己的代码，一来怕别人越改越乱，二来是怕别人与自己思路对不上，改变了我的思路与设想。如果，我不给别人修改代码的理由，不就能阻止吗？于一开始就考虑周达，做到代码整洁，性能最优。 “使之易读，实际上也使之易写”代码是给人读的，不管给自己，还是将来给别人读，如果不能保证代码的可读性，那么此代码将毫无意义，终将会被摒弃。与其花费时间精力去读一份混乱的代码，为何不抛弃它，自己重新设计，编写呢？多数程序员是喜欢编写新代码，极其讨厌维护他人代码的，原因就是如此，他人代码难以阅读。另外，如果能做到代码易读，侧面证明了该程序员明确需求，设计合理，逻辑清晰，写起来当然也容易。 “如果名称（包括变量名、函数名、文件名、包名、模块名）需要注释来补出，则不算名副其实”花时间在名称命名上，是值得的。清楚的、易懂、无歧义的命名，就代表了你对程序的理解。如果你取不出一个好的名字，则间接证明你对问题还不是很理解，设计的程序是存在的问题。 函数 “函数不应该大到足以容纳嵌套结构，因为 if else 或 switch 天生要做 N 件事” “禁用标识参数，标识参数证明函数不止做一件事； true：事 1；false：事 2” “每个函数一个抽象层级”代码层级是自顶向下的，每个函数需要在一个抽象层级中。混合多层级内容的函数，依赖过多，需要顾虑的方面过多，难以编写测试代码，更不太容易复用，理解意图难、维护难。函数只做一件小事，控制在同一层级中，清楚表达其功能即可。 “函数应该尽量避免多参数，如果函数需要多个参数，就说明其中一些参数应该封装为类或对象”过多的参数，很可能是函数做的事情模糊不清，不止一件。过多的参数，在调用时需要注意参数顺序，数量，测试难，读懂难，复用难。 “函数分 2 种：1.做什么事；2.回答什么事。二者不可兼得”编写函数的目的，要么是希望它去做什么事，是一个指令；要是是希望它回答什么，有个返回值，是一个询问。要分隔询问与指令，例如打开文件函数，要先判断是否有该文件，有则打开。判断是否有文件是个询问，打开则是一条指令，二者要分开。需要 2 个函数完成，判断是否有文件、打开。先询问在下发指令。 “函数取名，应是动宾词组，动词+关键名词；如果有参数，函数和参数应该形成一种动词+参数的对应形式，以解释函数的意图，以及参数的顺序意图”例如 writeFile(name),就比 write(name)更成解释函数意图，写入的是文件格式，名称是 name。assertEquals(expected,actual),你并不知道参数的顺序，哪个是实际值，哪个期待值.assertExpectedEqualsActual(expected,actual),函数名则说明了参数的顺序。 “函数别返回 NULL 值，也别传递 NULL 值” “对于第三方 api 要学会用装饰器模式管理，降低对它的依赖”对于使用第三方的 api，最好使用装饰器模式管理，降低对其依赖，未来可轻松的改用其他代码库。 类 “类名应该描述其权责，如果无法为某个类命名，则说明这个类有过多的权责” “每个小类封装一个权责，且只有一个修改它的理由” “依赖倒置： 1.高层次的模块不应该依赖于低层次模块，它们都应该依赖于抽象； 2.抽象不应该依赖于具体，具体应该依赖于抽象” “对象与数据结构是对应的”对象把数据隐藏于抽象之后，暴露操作数据的函数；数据结构只暴露了某数据，但没有提供有意义的函数。 检查、测试 “在没有检查程序，并确保程序是正确之前，不要急于开始编译” “千万不要陷入试图通过运行程序来检查其是否正确的怪圈”学会审查自己，不光是在编码阶段，在编码前后、设计、测试时都要去检查。要对自己的代码负责，对自己有信心，做个踏实可靠的人。自己审查过的代码，一定是高质量的。千万不可把错误交个编译器、测试来检查，到那时再去修改，已经晚了。一是改动代码，牵扯关联的地方多，修改成本大；二来时间不多，都到测试阶段了，也没多少时间去好好设计，重构。 “没有测试的代码，是不可测的代码，也就无法验证对错，也就不可部署” “脏测试等于没测试，测试代码也要保持整洁”不够整洁的代码，是不能确保测试质量，也更难以利用，代码变更，测试代码也需要做相应的调整。保证测试代码长久易懂，同样需要花时间做设计，保证代码整洁。 “每一个测试，有一个断言，并只测一个概念”测试用例也就是一个函数，只做一件小事。仅一个断言，测试难度小，需要测试路径清晰，数量少，能保证质量。 “测试的三个环节，Build -&gt; Operate -&gt; Check” 构造测试数据 操作测试数据 检查操作正确性 “如果发现程序的错误异乎寻常的多，那就要重新开发，不要试图去修补它。修补意味着不充分理解，而且肯定会在将来产生更多的问题” 程序设计 “程序设计是一个逐次迭代逼近的过程” “程序设计也是一个启发过程，需要吃一堑，长一智” “要把最可能改动的区域设计成最容易改动的区域；最容易改动的部分：” 硬件依赖部分 输入输出部分 复制的数据结构 商务规则 最深体会 想要成为优秀的程序员，写出高质量的代码。需要坚持编写代码、然后不厌其烦的一遍遍重构改进，同时还要克服自我劣性（懒惰，妥协将就、怕麻烦的心理）。 编写代码之前，做好设计，越详细越好，同时要不断的调整设计，逐步求精。 要养成良好的编程习惯，清晰明了的命名，只做一个小事的函数，逻辑明了，易读易懂的流程控制，必要的注释说明，编写详细的设计文档等等。好习惯是一个人的思想与行为的体现，习惯能减少思考时间，简化行动步骤与阻力，提高效率。 要建立自信心，营造踏实可靠的人设。我写的代码，提测后，bug 少；我完成需求，保量过硬；我不会迟到，我不吹牛，我不做无准备之事。","categories":[{"name":"技术总结","slug":"技术总结","permalink":"https://better-jiang.github.io/categories/%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%93/"}],"tags":[{"name":"编程认知","slug":"编程认知","permalink":"https://better-jiang.github.io/tags/%E7%BC%96%E7%A8%8B%E8%AE%A4%E7%9F%A5/"}]},{"title":"CSS中的图像大小","slug":"CSS中的图像大小","date":"2019-04-03T07:15:08.000Z","updated":"2023-02-03T12:14:22.415Z","comments":true,"path":"2019/04/03/CSS中的图像大小/","link":"","permalink":"https://better-jiang.github.io/2019/04/03/CSS%E4%B8%AD%E7%9A%84%E5%9B%BE%E5%83%8F%E5%A4%A7%E5%B0%8F/","excerpt":"","text":"图像由img元素src指定：12345&lt;img src=&quot;./xi_map.jpg&quot; alt=&quot;&quot; /&gt;&lt;img src=&quot;./xi_map.jpg&quot; alt=&quot;&quot; width=&quot;100&quot; height=&quot;100&quot; /&gt; &lt;img src=&quot;./xi_map.jpg&quot; alt=&quot;&quot; width=&quot;100&quot; /&gt; &lt;img src=&quot;./xi_map.jpg&quot; alt=&quot;&quot; height=&quot;100&quot; /&gt; 图像元素尺寸 ：690 X 586，显示的尺寸依次： 690px, 586px 100px, 100px 100px, 586/(690/100) = 84.92px 100*(690/586) = 117.74px, 100px 图像由backgroud-image指定:123456789101112131415161718192021222324252627 &lt;span class=&quot;img&quot; style=&quot;width:690px;height:586px&quot;&gt;&lt;/span&gt; &lt;span class=&quot;img&quot; style=&quot;width:100px;height:100px&quot;&gt;&lt;/span&gt; &lt;span class=&quot;img&quot; style=&quot;width:100px;height:100px; background-size: 50px 50px&quot; &gt;&lt;/span&gt; &lt;span class=&quot;img&quot; style=&quot;width:100px;height:100px; background-size: contain&quot; &gt;&lt;/span&gt; &lt;span class=&quot;img&quot; style=&quot;width:100px;height:100px; background-size: cover&quot; &gt;&lt;/span&gt; &lt;span class=&quot;img&quot; style=&quot;width:100px;height:117.74px; background-size: cover&quot; &gt;&lt;/span&gt;&lt;style&gt; .img &#123; background-color: rgb(156, 54, 54); display: inline-block; background-image: url(&#x27;./xi_map.jpg&#x27;); background-repeat: no-repeat; background-size: auto; &#125;&lt;/style&gt; 图像显示尺寸依次: 690px, 586px 100px, 100px (只显示图像左上角 100px X 100px 大小的部分) 50px, 50px 100px, 84.92px (图像按比例缩放显示) 100px, 100px (图像高度上按缩放显示，但宽度上只截取了 100px 显示（按原图像宽高比计算的话，宽度应该显示 117.74px）) 117.74px, 100px (图像按原图像的固定宽高比显示) 总结 固有尺寸：固有宽度，固有高度，固有宽高比 指定大小： height,width,background-size 图像超出 背景区域的部分，会被裁剪掉；覆盖不全的部分，会用背景色来填充 调整图像大小: background-image方式 ，用background-size属性，指定大小(宽，高)，cover，contain contain是包含约束，要在背景框里尽可能的大。如上图 4，背景框宽 100px,高 100px，图像固有宽 690px,高 586px,包含约束取宽 100px，高度根据宽高比计算出来 100/690/586=84.92px,对于背景区域未覆盖的地方用背景色来填充。 cover是覆盖约束，要在大于等于背景框的前提下尽可能的小；如上图 5，背景框宽 100px，高 100px，图像固有宽 690px，高 586px，覆盖约束要取高 100px，宽根据固有宽高比计算 100*（690/586）=117.74px，对于超出背景区域的部分，被裁剪掉。 &lt;img&gt;方式，使用object-fit属性，fill, contain, cover,none,scale-down fill：填充，拉伸填充满屏幕,不保证原有比例 -contain: 包含，保持原有尺寸比例，且图像容器里放的下 cover: 覆盖，保持原有尺寸比例，且图像尺寸一定大于等于容器尺寸 none: 保持原有尺寸比例，如果图像尺寸大于容器，则裁剪多余的 scale-down: 图像的尺寸与none或contain中的一个相同，取决于它们之间谁得到的尺寸会更小一些 调整图像在背景框的位置 背景图，使用background-position: 默认值:50%,50% &lt;img&gt;,使用object-position:默认值是 50% 50%","categories":[{"name":"技术总结","slug":"技术总结","permalink":"https://better-jiang.github.io/categories/%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%93/"}],"tags":[{"name":"css","slug":"css","permalink":"https://better-jiang.github.io/tags/css/"}]},{"title":"可替换元素与非可替换元素","slug":"可替换元素与非可替换元素","date":"2019-04-03T03:42:51.000Z","updated":"2023-02-03T12:14:22.415Z","comments":true,"path":"2019/04/03/可替换元素与非可替换元素/","link":"","permalink":"https://better-jiang.github.io/2019/04/03/%E5%8F%AF%E6%9B%BF%E6%8D%A2%E5%85%83%E7%B4%A0%E4%B8%8E%E9%9D%9E%E5%8F%AF%E6%9B%BF%E6%8D%A2%E5%85%83%E7%B4%A0/","excerpt":"","text":"可替换元素在 CSS 中，一个可替换元素的展现效果不是由 CSS 控制的，它们是外部对象，且表现形式独立于 CSS 格式化模型。简单来讲，它们的内容不受当前文档的样式的影响。使用 CSS 可影响可替换元素的位置，但不会影响可替换元素自身的内容。某些可替换元素，比如&lt;iframe&gt;元素，可能有其自身的样式表，但它们不会继承父文档的样式。CSS 对可替换元素的唯一其他影响在于，有些属性支持控制元素内容在其框内的位置。详细内容，控制内容框中的对象位置 需要注意：一部分（并非全部）可替换元素，本身有尺寸和基线,会被像vertical-align之类的一些 CSS 属性用到。浏览器会根据元素的标签类型和属性来显示这些元素。可替换元素也在其中生成了框，其可替换元素通常有其固有尺寸（intrinsic dimensions）：一个固有宽度，一个固有高度，一个固有的宽高比率。根据 W3C 文档，有且仅有全体替换元素具有固有尺寸的 典型的可替换元素： &lt;iframe&gt; &lt;video&gt; &lt;embed&gt; &lt;img&gt; 在特定情况下被作为可替换元素处理： &lt;option&gt; &lt;audio&gt; &lt;object&gt; &lt;applet&gt; &lt;input&gt; 匿名的可替换元素：用 CSScontent属性插入的对象是匿名的可替换元素，它们不存在于 HTML 标记中，因此”匿名的”。 非替换元素html 中大多数元素都是非替换元素，其内容在元素本身生成的框中生成。 元素的显示 替换元素 可以增加行框高度，但不影响行高(line-height); 内容区域高度值=padding-top + pagging-bottom + margin-top + margin-bottom + height; 替换元素居中，可设置 line-height = height 行内替换元素设置上下内边距，会撑开父元素。 非替换元素 行内非替换元素，padding-top,padding-bottom,不影响行框高度，但内容区域高度会变化，也不会撑开父元素。 margin-top，margin-bottom,对行框没有影响 margin-left，margin-right,会影响非替换元素水平位置 行内元素 设置 padding-left，padding-right，可见。 行内非替换元素，不能设置垂直方向上的 margin 和 padding。","categories":[{"name":"技术总结","slug":"技术总结","permalink":"https://better-jiang.github.io/categories/%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%93/"}],"tags":[{"name":"css","slug":"css","permalink":"https://better-jiang.github.io/tags/css/"}]},{"title":"《CSS权威指南4》- Chapter1.2 - CSS与HTML结合","slug":"《CSS权威指南》-Chapter1-2 - CSS与HTML结合","date":"2019-04-03T02:06:59.000Z","updated":"2023-02-03T12:14:22.415Z","comments":true,"path":"2019/04/03/《CSS权威指南》-Chapter1-2 - CSS与HTML结合/","link":"","permalink":"https://better-jiang.github.io/2019/04/03/%E3%80%8ACSS%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97%E3%80%8B-Chapter1-2%20-%20CSS%E4%B8%8EHTML%E7%BB%93%E5%90%88/","excerpt":"","text":"在详细学习任何编写 CSS 之前，我们需要了解如何将 CSS 与文档关联。毕竟，如果不把二者结合，CSS 就没有办法影响文档。我们将在 HTML 设置中探讨这个问题，因为它是最常见的。 结合 CSS 和 HTML我已经提到过，HTML 文档有一个固有的结构，并且需要重申这一点。实际上，这也是旧网页的问题之一：我们之中大部分人忘记了文档应该有一个内在结构，这与视觉结构完成不同。我们急于创建最酷的网页，我们弯曲、扭曲了网页，并通常会忽略一点，页面应该包含有具有某种结构含义的信息。这种结构是 HTML 和 CSS 之间关系中固有部分，没有它，就不会有任何关系。为了更好的理解这一点，让我们看一个 HTML 文档的例子，并把它分成几部分： 123456789101112131415&lt;html&gt; &lt;head&gt; &lt;title&gt;Eric&#x27;s World Waffles&lt;/title&gt; &lt;meta http-equiv=&quot;content-type&quot; content=&quot;text/html; charset=utf-8&quot;&gt; &lt;link ref=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;sheet1.css&quot; media=&quot;all&quot;&gt; &lt;style&gt; @import url(sheet2.css); &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;h2&gt;Waffles&lt;/h2&gt; &lt;p style=&quot;color: gray;&quot;&gt;The most wonderful of all breakfast foods isthe waffle—a ridged and cratered slab of home-cooked&lt;/p&gt; &lt;/body&gt;&lt;/html&gt; 现在，让我们研究一下文档与 CSS 关联的多种方式。 link 标签首先，考虑link标签的作用： 1&lt;link ref=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;sheet1.css&quot; media=&quot;all&quot;&gt; link标签是一个很少被关注，但是完全合法的标签，它在 HTML 规范中已经存在多年，等待着被好好利用，施展才华。其基本目的是允许 HTML 创作人员将包含link标签的文档与其他文档相关联。CSS 使用它来将样式表链接到文档中。在图Figure1-5中，一个名为sheet1.css的样式表被链接到文档中。 这样的样式表并不是 HTML 文档的一部分，但是被 HTML 文档使用，称为外部样式表，因为它们是 HTML 文档外部的样式表。要成功加载一个外部样式表，link标签必须放在head元素内部，但不能放在其它元素的内部（如 title）。这样一来，web 浏览器才能找到并加载样式表，然后使用它包含的任何样式来呈现 HTML 文档，如图Figure1-5所示。图figure1-5还显示了通过@import声明来加载外部样式表sheet2.css.@import声明必须放在包含它们样式表的开头，其他的没有限制。外部样式表有什么格式呢？它是一个规则列表，就像我们上一节和示例 HTML 文档中见到的一样。但在本例中，规则被保存到其自己的文件中。只要记住，样式表中不能包含 HTML 或任何其他标记语言，只能有样式规则。以下是一个外部样式表的内容： 12345678h1 &#123; color: red;&#125;h2 &#123; color: maroon; backgroud: white; font: medium Helvetica;&#125; 这就是它的全部内容，完全没有 HTML 标签和注释，只有简单的样式声明。它们被存入纯文本文件，通常给一个.css的扩展名，如sheet1.css所示。.css文件扩展名不是必要的，但是一些较老的浏览器无法识别包含样式表的文件，除非文件以.css结尾，即使在link元素中包含正确的类型.(type=&quot;text/css&quot;).实际上，有些 web 服务器不会将文件作为text/css传递，除非文件名以.css结尾，不过通常可以通过更改服务器的配置文件来修复这个问题。 属性对于link标签的剩余部分，其属性和值是相当简单。rel代表”关系(relation)”，在这里该“关系”是stylesheet.属性type总是被设置为text/css,这个值描述了使用link标签将要被加载的数据的类型，这样，浏览器就知道这个样式表示 CSS 样式表，这一事实将决定浏览器任何处理它导入的数据。毕竟，将来有可能会使用其他的样式语言，因此声明使用何种语言是很重要的。接下来，我们看到href属性，这个属性的值是样式表的 URL，它可以是绝对 URL，也可以是相当 URL,取决于你要做的工作。在我们的例子中，URL 是相对 URL。最后，还有一个media属性，这个属性的值是一个或多个媒体描述符，它们是关于媒体类型和这些媒体特性的规则，每个规则使用逗号分割。因此，例如，你可是在屏幕和投影媒体中使用一些链接样式表： 1&lt;link ref=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;sheet.css&quot; media=&quot;screen, projection&quot;&gt; 媒体描述符可能变得相当复杂，在以后章节会详细解释。现在，我们继续关注所示的基本的媒体类型。注意，一个文档可能关联多个链接样式表。如果这样的话，只有那些带有ref为stylesheet的link标签才会在文档的初始显示中使用。因此，如果你想链接 名为basic.css和splash.css的 2 个样式表，应该这样做： 12&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;basic.css&quot;&gt;&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;splash.css&quot;&gt; 这将导致浏览器加载这 2 个样式表，合并它们的规则，并将其全部应用于文档，例如： 1234&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;basic.css&quot;&gt;&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;splash.css&quot;&gt;&lt;p class=&quot;a1&quot;&gt;This paragraph will be gray only if styles from the stylesheet &#x27;basic.css&#x27; are applied&lt;/p&gt;&lt;p class=&quot;b1&quot;&gt;This paragraph will be gray only if styles from the stylesheet &#x27;splash.css&#x27; are applied&lt;/p&gt; 有一个属性不在示例标记中，但可用，它是title属性。这个属性不经常使用，但将来会变得很重要。如果使用不当，可能会有意想不到的后果。为什么呢？我们将在下一节对探讨。 候选样式表还可以去定义候选样式表。将ref属性的值设置为alternate stylesheet就可以定义候选样式表，只有被用户选中才会用于文档的展示。如果一个浏览器能使用候选样式表，它会使用link元素的title属性的值去生成一个候选样式列表。 123456 &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot;href=&quot;sheet1.css&quot; title=&quot;Default&quot;&gt;&lt;link rel=&quot;alternate stylesheet&quot; type=&quot;text/css&quot;href=&quot;bigtext.css&quot; title=&quot;Big Text&quot;&gt;&lt;link rel=&quot;alternate stylesheet&quot; type=&quot;text/css&quot;href=&quot;zany.css&quot; title=&quot;Crazy colors!&quot;&gt; 然后用户就能选择他们想用的样式，浏览器会从第一个样式（这本例中，也就是标记为”Default”的样式）切换为用户所选择任何样式。图Figure 1-6显示了这种选择机制的实现方法（事实上，是在 CSS 复兴的早期）。截止到 2016 年底，候选样式表在大多数基于Gecko内核的浏览器中都得到了支持，比如 Firefox,Opera。在 IE 家族中，用户可以通过 javaScript 得到支持，但浏览器本身是不支持的。web-lit家族的浏览器(如 Chrome)不支持选择候选样式表的，所有这里就不在讨论它了…… style 元素style元素是包含样式表的一种方式，它出现在文档中 1&lt;style type=&quot;text/css&quot;&gt;&lt;/style&gt; sytle应该始终使用type属性，对于 CSS 文档，正确的值是text/css,就像link元素一样。style元素应该始终以&lt;style type=&quot;text/css&quot;&gt;开始，如上例所示，其后可跟一个或多个样式，最后以一个结束标记&lt;/style&gt;结束。还可以给style元素一个media属性，它的功能与前面讨论的链接样式表功能相同。在开始和结束style标记中的样式被称为文档样式表或嵌套样式表（因为这个样式表示嵌套在文档中的）。它将包含很多要应用于文档的样式，还可以使用@import指令包含多个指向外部样式表的链接。 @import指令现在，我们来讨论在style标记中的内容，首先，我们有一些与link非常相似的东西：@import指令 123&lt;style type=&quot;text/css&quot;&gt; @import url(sheet2.css);&lt;/style&gt; 与link一样，@import能指导浏览器去加载外部样式表，并且在渲染 HTML 文档时使用其样式。唯一的区别在于命令的语法和位置。可以看到，@import出现在style容器中，它必须放在其它 CSS 规则之前，否则不起作用。考虑下面的例子： 123456&lt;style type=&quot;text/css&quot;&gt; @import url(styles.css); h1 &#123; color: gray; &#125;&lt;/style&gt; 类似于link标签，在一个文档中可以出现不止一个@import语句。但不同于link，每一个@import指令的样式表 都会被加载并使用，所以用@import无法指定候选样式表。因此，给定以下标记： 123@import url(sheet2.css);@import url(blueworld.css);@import url(sheet1.css); 这 3 个外部样式表都会被加载，而且它们所有的样式规则都会在文档的显示中使用。与link一样，你可以通过在样式表 URL 后列出要应用于此样式表的媒体类型，来限定所导入的样式表应用于一种或多种媒体类型。 12345@import url(sheet2.css) all;@import url(blueworld.css) screen;@import url(sheet1.css) projection,print;&lt;link ref=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;sheet1.css&quot; media=&quot;projection and print&quot;&gt;&lt;/link&gt; 如果有一个外部样式表，它需要使用其他外部样式表的内容，那么@improt就非常有用。因为外部样式表中不能包含任何文档标记，所有不能使用link元素，但是可以使用@import。因此，可以有一个外部样式表包含以下内容： 123456789@import url(http://example.org/library/layout.css);@import url(base-text.css);@import url(print.css) print;body &#123; color: red;&#125;h1 &#123; font-size: 19px;&#125; 也许具体样式并非如此，但是希望你能了解我的意思。注意，上面提供的例子不仅使用了绝对 URL，还使用了相对 URL，正如link元素一样，这 2 中 URL 形式都可以使用。 还是要注意：如示例文档所示，@import指令出现在样式表的开头。CSS 要求@import指令出现在样式表中其他规则之前，如果出现在其他规则之后，将会被用户代理（浏览器）所忽略。 内联样式（Inline Styles）对于只想给一个独立的元素添加一些样式，而不需要内部/嵌入样式或外部样式。可以使用 HTML 的style属性来设置内联样式。 1&lt;p style=&quot;color:gray;&quot;&gt;If you love Dog, we are friends!&lt;/p&gt; style属性可以和任何 HTML 标签相关联，除了那些在body之外的标签（比如 head,title）。style属性的语法相当普通，实际上，它看起来很像是在&lt;style&gt;容器内定义的声明，除了其中的大括号被双引号替代。因此&lt;p style=&quot;color:maroon;background:yellow&quot;&gt;&lt;/p&gt;，将把该段落的文本设置为褐红色（maroon），背景设置为黄色。其他文档部分将不会受到该声明的影响。 注意：你只能将声明块而不是整个的样式表放入style属性中.因此,你不能将@import放入style属性中，也不能包含任何完整的规则。style属性的值唯一可以放入的是花括号之间的规则。一般不建议使用style属性。实际上，它不太可能出现在 HTML 以外的 XML 语言中。CSS 许多主要的优点：组织的集中样式的能力，这些集中的样式控制着整个文档的外观，或 web 服务器上所有文档的外观。它们不赞同把样式规则放入style属性。在许多方面，内联样式并不比font标签好多少，尽管它们在视觉效果方面的应用方面有很到的灵活性。","categories":[{"name":"技术总结","slug":"技术总结","permalink":"https://better-jiang.github.io/categories/%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%93/"}],"tags":[{"name":"翻译","slug":"翻译","permalink":"https://better-jiang.github.io/tags/%E7%BF%BB%E8%AF%91/"},{"name":"CSS权威指南-第四版","slug":"CSS权威指南-第四版","permalink":"https://better-jiang.github.io/tags/CSS%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97-%E7%AC%AC%E5%9B%9B%E7%89%88/"}]},{"title":"《CSS权威指南4》- Chapter1.1 - CSS和文档","slug":"《CSS权威指南》-Chapter1-1 - CSS和文档","date":"2019-03-27T06:11:23.000Z","updated":"2023-02-03T12:14:22.415Z","comments":true,"path":"2019/03/27/《CSS权威指南》-Chapter1-1 - CSS和文档/","link":"","permalink":"https://better-jiang.github.io/2019/03/27/%E3%80%8ACSS%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97%E3%80%8B-Chapter1-1%20-%20CSS%E5%92%8C%E6%96%87%E6%A1%A3/","excerpt":"","text":"CSS 和文档层叠样式表（Cascading Style Sheets, CSS）是一个强大的工具，它可以转换文档或一组文档的表现形式。它几乎已经蔓延到 web 的各个角落，并扩展到了表面上非 web 环境中。比如，基于 Gecko 的浏览器使用 CSS 来影响浏览器 chrome 自身的表现，许多 RSS 客户机允许你将 CSS 应用于提要和提要条目，一些即时消息客户端使用 CSS 来格式化聊天窗口。各部分 CSS 也可以在所使用的 JavaScript 框架的语法中找到，甚至在 JavaScript 自身中，它无处不在。 web 样式简史在 1994 年 CSS 被首次提及，当时 web 正开始流行起来。那时浏览器给用户提供了各种样式功能（Misaic 中的首选项）。比如，允许用户在每个元素的基础上定义各种各样类型的字体、颜色和大小，而这些功能都没有提供给文档的作者，他们所能做的就是将一段内容标记为段落、某个级别的标题、预定义格式化文本，或其他几种类型元素中的一种。如果一个用给户浏览器配置为 所有 1 级标题都是小的，粉红色的，而所有的 6 级标题都是大的，红色的，那么，就会如他所愿。 CSS 就是在这种环境中被引入的。它的目的是提供一种简单的声明式样式语言，对作者来说是灵活的，更重要的是，为作者和用户都提供了样式功能。通过层叠（cascade）这种方式，样式能被组合在一起，并按优先级顺序排列，因此作者和读者都有发言权，尽管读者总是拥有最后发言权。 工作进展迅速，在 1995 年底，CSS1 完成。而新成立的 CSS 工作组将继续推进 CSS2，但是浏览器难以以一种互操作的方式实现 CSS1 特性。虽然每个独立的 CSS 部分是相当简单，但组合它们却导致了令人惊讶的复杂行为。在早期的实现中也有些不幸的失误，比如在盒子模型实现中臭名昭著的差异。这些问题威胁着 CSS 的发展，幸运的是，一些明智的建议得到了实现，浏览器厂商也趋于和谐统一。在这几年里，由于增强了互操作性和引人注目的开发，比如基于 CSS 改版的《连线》杂志和《CSS 禅意花园》，CSS 开始流行起来。 r 然而，在这以前发生前，CSS 工作组已经在 1998 年初确定了 CSS2 的规范。CSS2 一旦完成，会立即开始 CSS3 的工作，和一个 CSS2 的澄清版本叫做 CSS2.1。本着时代精神，CSS3 被构建成一系列（理论上）的独立模块，而不是一个单一的整体规范。这种方式反映了当时的情况（例如活跃的 XHTML 规范），出于相同的原因，CSS3 也被分成多个模块。 模块化 CSS3 的基本原理是，每个模块可以按照自己的速度工作，特别重要（流行的）模块可按照 W3C 的进度推进，而不用被其他阻碍。事实上，结果就是如此。截止到 2012 年初，3 个 CSS3（以及 CSS1 和 CSS2.1）模块已经达到完全推荐状态，它们是 3 级的 CSS 样色，CSS 命名空间，3 级的选择器。与此同时，7 个模块处于候选推荐模块，还有十几个在工作草案阶段。在旧的方法下，颜色、选择器、命名空间必须等到规范的其他部分完成或删除之后才能成为完整规范的一部分，多亏有了模块化，它们不必等待。 这种优势的另一个好处，它很难说成是一个单独的“CSS3 规范”，是没有这样说法的，也不可能有。即使每一个 CSS 模块都达到 3 级（说是在 2016 年底），但是已经有 4 级的选择器在处理中了。我们会把它称为 CSS4 吗？所有的 CSS3 孩子发挥作用吗？网格布局甚至还没有达到 1 级？ 因此我们不能指着一本大册的书说它是 CSS3，我们可以根据引入的模块名来讨论起特性。灵活性的模块可以弥补它们有时在语义上造成的尴尬。如果你想要一个近于单一完整的规范，CSS 工作组每年会发布一个快照文档。 有了这些，我们就差不多可以开始学习 CSS。不过，首先我们要复习一下标签。 元素元素（Element）是文档结构的基础。在 HTML 中，最常用的元素是很容易辨别的，如p,table,span,a,div.文档中的每一个元素都对其表现起一定的作用。 替换和非替换元素虽然 CSS 依赖于元素，但并不是所有元素都以同样的方式创建。例如，图像和段落就不是同一类型的元素，span和div也不相同。在 CSS 中，元素通常有 2 种形式：替换和非替换。 替换元素替换元素是指用来替换元素内容的部分并不是由文档内容直接呈现。可能最熟悉的替换元素的例子就是img标签，它由文档本身之外的一个图像文件来替换。实际上，img没有实际的内容，通过以下简单例子可以了解这一点： 1&lt;img src=&quot;dog.gif&quot;&gt; 这个标记片段只包含一个元素名和一个属性。除非将其指向外部内容（这里，就是由 src 属性指定的一个图像），否则这个元素不显示任何内容。如果你指向一个有效的图像文件，图像将被放置到文档中，如果没有，它什么也不显示或浏览器显示一个”损坏的图像”的占位符。input元素与之类似，它取决于input元素的类型，是由一个单选钮，复选框，还是由一个文本输入框替换元素内容。 非替换元素大部分 HTML 元素是非替换元素。这意味着，它们的内容由用户代理（通常是一个浏览器）在元素自身生成的框中（盒子内部）显示。例如，&lt;span&gt;hi there&lt;/span&gt;就是一个非替换元素，文本&quot;hi there&quot;将有用户代理显示。段落、标题、单元格、列表，以及 HTML 中几乎所有的元素也是这种情况。 元素显示角色除了替换元素和非替换元素，CSS 也使用其他两中基本元素类型：块级元素（block-level）和行内级元素/行内元素（inline-level）。还有更多的显示类型，但是这些事最基本的，也是大多数其他类型所引用的类型.对于花时间研究 HTML 标记以及其在浏览器的显示的作者来说，块级和行内类型是很熟悉的。这些元素如图 Figure 1-1 所示。 块级元素块级元素生成一个元素框，（默认下）它会填充其父元素的内容区域，并且在它的两侧不能有其他元素。换句话说，它在元素框前后生成“分隔符”。最熟悉的来自 HTML 块级元素是p和div,替换元素可以是块级元素，当通常它们都不是。列表项是块级元素的一种特殊情况。除了表现方式与其他块元素一致，列表项还会生成一个标记符———无序列表通常是一个圆点，有序列表则是一个数字，标记符会附加到元素框中。除了这个标记符外，列表项在所有其其他方面都与其他块元素相同。 行内元素行内元素在一个文本行内生成元素框，也不会打断这行文本。行内元素最好的例子就是 HTML 中的a元素，还有strong和em。这些元素不会在它自身之前或之后生成“分隔符”，所以它们可以出现在另一个元素的内容中，而不会破坏其显示。 注意，虽然“块”和“行内”的名称与 HTML 中的块级和行内级元素有很多共同之处，但也存在一个重要的差别。在 HTML 中，块级元素不能继承行内元素（即不能嵌套在行内元素中），但在 CSS 中，对于显示角色如何嵌套不存在任何的限制。 要了解这是任何工作的，我们来考虑一个 CSS 属性：display 1234567891011121314151617181920212223242526Values: [&lt;display-outside&gt; || &lt;display-inside&gt;] | display-listiem | display-internal | display-box | display-legacyDefinitions: See belowInitial value: inlineApplies to: All elementsComputed value: As specifiedInherited: NoAnimatable: No&lt;display-out&gt;: block | inline | run-in&lt;display-inside&gt;: flow | flow-root | table | flex | grid | ruby&lt;dispay-listitem&gt;: list-item &amp;&amp; &lt;display-outside&gt;? &amp;&amp; [flow | flow-root]?&lt;display-internal&gt;: table-row-group | table-header-group | table-footer-group | table-row | table-cell | table-column-group | table-column | table-caption | ruby-base| ruby-text | ruby-base-container | ruby-text-container&lt;display-box&gt;: contents | none&lt;display-legacy&gt;: inline-block | inline-list-item | inline-table | inline- flex | inline-grid 你也许注意到display有很多的值，其中只有block,inline,list-item3 个是我们经常提及到。大部分的值将在这本书的其他部分讨论，例如，grid和inline-grid将在关于网格布局的单独一章中讨论，表格相关的值，在 CSS 表格布局单独一章讨论。目前，我们先只关注block和inline。 123&lt;body&gt; &lt;p&gt;This ia paragraph with &lt;em&gt;an inline element&lt;/em&gt; within it&lt;/p&gt;&lt;/body&gt; 这里有 2 个块元素（body，p）和一个行内元素（em）.根据 HTML 的规范，em可以从p继承而来，但反过来不行。通常，HTML 层次结构是有效的，所有行内元素可以继承自块元素，而反之则不允许。与之不同，CSS 没有这种限制。你可以让标记保持原样，但改变 2 个元素的显示角色。 123456p &#123; display: inline;&#125;em &#123; display: block;&#125; 这会使得元素在一个行内框中生成一个块框，这是完全合法的，不违反任何 CSS 规范、然而，如果你试图反转元素的嵌套关系，就会遇到问题： 1&lt;em&gt;&lt;p&gt;This is a paragraph improperly enclosed by an inline element .&lt;/p&gt;&lt;/em&gt; 不论你通过 CSS 对显示角色做什么改变，ta 在 HTML 中是不合法的。 虽然在 HTML 文档中更改元素的显示角色很有用，但对 XML 来讲，也变的意义重大。XML 文档不太可能有固有的显示角色，所有它要由创作者来定义。例如，你可能想知道如何摆放以下 XML 片段： 1234567891011121314151617&lt;book&gt; &lt;maintitle&gt;Casading Style Sheets: The Dfinitive Guide&lt;/maintitle&gt; &lt;subtitle&gt;Third Edittion&lt;/subtitle&gt; &lt;author&gt;Eric A. Meyer&lt;/author&gt; &lt;publisher&gt;O&#x27;Reilly and Associates&lt;/publisher&gt; &lt;pubdate&gt;November 2006&lt;/pubdate&gt; &lt;isbn type=&quot;print&quot;&gt;978-0-596-52733-4&lt;/isbn&gt;&lt;/book&gt; &lt;book&gt; &lt;maintitle&gt;Casading Style Sheets: The Dfinitive Guide&lt;/maintitle&gt; &lt;subtitle&gt;Third Edittion&lt;/subtitle&gt; &lt;author&gt;Eric A. Meyer&lt;/author&gt; &lt;publisher&gt;O&#x27;Reilly and Associates&lt;/publisher&gt; &lt;pubdate&gt;November 2006&lt;/pubdate&gt; &lt;isbn type=&quot;print&quot;&gt;978-0-596-52733-4&lt;/isbn&gt;&lt;/book&gt; 由于display属性的默认值是inline,默认地其内容将被渲染成行内文本，如图Figure 1-2 所示，这种显示用处不大。 你可以使用display来定义基本布局： 123456book, maintitle, subtitle,author,isbn &#123; display: block;&#125;publisher,pubdate &#123; display: inline;&#125; 我们现在将 7 个元素中的 5 个设置为块元素，2 个设置成行内元素。这意味着每个块元素都会像 HTML 中的div一样处理，而 2 个行内元素将以类似于span的方式来处理。这种影响显示角色的基本功能使得 CSS 在各种情况下都非常有用。我们可以将以上规则作为起点，再另外增加一些样式以获得更好的视觉冲击，得到如图 Figure 1-3的结果。","categories":[{"name":"技术总结","slug":"技术总结","permalink":"https://better-jiang.github.io/categories/%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%93/"}],"tags":[{"name":"翻译","slug":"翻译","permalink":"https://better-jiang.github.io/tags/%E7%BF%BB%E8%AF%91/"},{"name":"CSS权威指南-第四版","slug":"CSS权威指南-第四版","permalink":"https://better-jiang.github.io/tags/CSS%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97-%E7%AC%AC%E5%9B%9B%E7%89%88/"}]},{"title":"直面bug，而后反思","slug":"直面bug，而后反思","date":"2019-03-27T02:49:26.000Z","updated":"2023-02-03T12:14:22.415Z","comments":true,"path":"2019/03/27/直面bug，而后反思/","link":"","permalink":"https://better-jiang.github.io/2019/03/27/%E7%9B%B4%E9%9D%A2bug%EF%BC%8C%E8%80%8C%E5%90%8E%E5%8F%8D%E6%80%9D/","excerpt":"","text":"新公司，自我来，产品迭代了 2 个版本。2 个版本中我都去做了难度与复杂度较高的任务，很棘手也挺闹心。每个版本提测后，大大小小的 bug 多达 30~40 个，为此被测试怼过，被组长怀疑过，也被负责人找去谈话过。哎，心里有怨气，有委屈，这不是我一个人造成的呀！但事实摆在眼前，我无力狡辩，也懒的去花功夫去说服他人，算了，先自我反省吧。 一定要理清楚需求必须弄清楚需求，越仔细越好。在没搞清楚需求前，写的代码，大部分不能用，是后续要删除的。如果不想删除，就会想方设法在此基础上，来完成以后的需求，就不会去仔细分析该正确的需求，去设计更合理的实现方法，达到可复用，易维护的最低标准。总之，越加越乱，越改越难，越来越复杂难懂，越来越不知所措，维护成本也必然越来越高。久而久之，一定会破罐子破摔，东补西凑，代码写的能混过测试即可。后面谁维护，谁倒霉呗。 理清需求，做的无用功就少了。提测时，才被检测出问题，多半会因没有充足的时间去改，自然会投机取巧，随便胡弄。 理清需求后，别急动手，多思考如何更好的实现，并画流程图了解需求后，别急着写代码。好好思考下如何去实现？有几种可行方式，并画出每种方式的流程图。每种方式的有那些优点、缺点、难点？要实现所需技能难不难？自己掌握了没？如果没有，如何去学习了解，花费多少时间？流程中涉及到的方法，是否之前有能复用的？如果没有，新写的方法，是否符合单一原则，能否被更好的复用？流程中如何设计数据结构，怎样设计更容易理解，更好操作？该功能，能被拆封的更小吗？能直接复用之前组件吗？后续要添加，调整，怎样更容易？假若每个人都能以此理想化的方式，实现需要，编写代码，那么版本迭代将会越来越容易。而非像现在一样，每一次的版本迭代，不论是添加新需求，亦或是修改之前功能，复杂度和难度陡增，牵扯的部分，要考虑的地方越来越多，另外，因为没有编写测试代码，，隐藏 bug 无以计数， 远比发现的多啊。 编写代码，要有规范，并且要坚持符合规范，不能有丝毫的纵容代码是不会欺骗人的，所以你也别去想着如何能欺骗它。找份高质量的代码规范，一以贯之的按规范编写，无形中会少犯很多错误，渐渐的也会养成好的编码习惯和思考方式。例如，如何给变量命名？如何给函数命名？循环、分支结构如何编写？不要使用魔幻数值或字符等；因为有规范，就有了评判对错的参考物，且易于去更改，会易形成习惯。之后得心顺手了，甚至能以平静或开心的心态编去编写代码了。千万不能有丝毫的纵容，当心“破窗理论”，千里之提，毁于蚁穴呀。 摒弃侥幸心理，坏事一定会发生的很多时候明明知道编写的代码，小概率会出错，要改，则要花费过多的时间、精力去思考和完善。这时惰性和侥幸心理会选择不改不完善，或者打个 TODO 标签，标记以后有时间会去完善。那么，不到被测试测出，或因有问题影响用户正常使用，是不会去改的。因为不被强制要求改的话，我怎么会去花时间看前面代码，去抵制侥幸心理作祟，这对正常人来讲也是很难的。别再心存侥幸了，踏踏实实的，把问题考虑全了，所有的可能性都考虑到了，这是一种本事，既然想到了，就去做好它。善始善终，圆满无暇真真的难呀。 尽量去编写测试用例，编写可测试的代码，得到好代码如果你对自己写代码没把握，没自信，害怕提测，且总是有许许多多本可避免的 bug,则需要开始去编写测试代码了。写代码之前，思考并设计，理清功能点的输出和输入，编写测试用例，再在测试代码的约束下，编写的代码，就会更加高内聚低耦合，更高质量。同时，在后期可依托测试，进行持续重构，而不用担心破坏原有的代码逻辑。只有持续的重构，才能有高质量的好代码。其实，编写测试用例，是一个很好的思考并设计代码的过程，好的测试用例，是代码正确性的保障。 拆解需求，自顶向下的划分功能模块，编写可复用的代码世间万物都是结构化的。用结构化的思维去看待事物，思考问题。需求更是如此，大需求，由各种各样的小需求以某种结构，组合而成。所以，在遇到复杂的需求时，学会拆解成多个独立的小需求，小需求再拆解成更小的需求，真到不能拆解为止。把需求自顶向下的划分成独立的模块，再去实现各独立模块的功能。因为模块独立，不但可独立编写，独立测试，更能在以后根据需求组装，服用。 多沟通，不会则问，发问前，多想多准备白纸黑字，有图有据，你和产品对需求的理解也是有偏差的。多沟通，确保双方所理解的是相同的。与人交流，交往一样如此呀。别去费时费力的推测他人了，也别以为自己的理解，他人也应该如此理解才对，其实不然，人与人是真的不同，差距大到难以想象。学会去理解他人，尊重他人，多沟通，勤沟通，很多问题不会发生，很多烦心事也会迎刃而解。不会，搞不明白，就问问明白的人，自我的理解思考多是狭隘，容易受阻，遇死胡同。在像他人发问前，多准备，要多想，具体要问什么？真正阻隔自己的是什么？是否搞明白它，其他的问题也可解决？如果真是如此，要好好反省对比自己，为何会受阻？为何自己会那些去想？那样想的由来是什么？为什么自己不能如明白人一样思考问题呢？我有种体会，人必须要在 对与错中 不断的去自我反省，为何走到了错的路上？怎样思考，怎样走才能走到对的路上？对与错的分叉路，是否有路标指引呢？我相信是有的，那么要如何去辨别呢？","categories":[{"name":"技术总结","slug":"技术总结","permalink":"https://better-jiang.github.io/categories/%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%93/"}],"tags":[{"name":"反思怪","slug":"反思怪","permalink":"https://better-jiang.github.io/tags/%E5%8F%8D%E6%80%9D%E6%80%AA/"}]},{"title":"《我从新疆来2》读后感","slug":"《我从新疆来2》读后感","date":"2019-03-20T02:11:07.000Z","updated":"2023-02-03T12:14:22.415Z","comments":true,"path":"2019/03/20/《我从新疆来2》读后感/","link":"","permalink":"https://better-jiang.github.io/2019/03/20/%E3%80%8A%E6%88%91%E4%BB%8E%E6%96%B0%E7%96%86%E6%9D%A52%E3%80%8B%E8%AF%BB%E5%90%8E%E6%84%9F/","excerpt":"","text":"我们都一样，想让大家更了解新疆自上大学，离开新疆在内地生活，我就明显感觉到内地人对新疆了解之少，远超乎我想象，同时还多少带些偏见和不合理的假想。最最令我费解不堪的是：内地人认为维吾尔族才是新疆人，新疆也只有维吾尔族人。或许是因为维吾尔族人长相最不同与汉人，如电视电影中的外国人一般，大眼睛、高鼻梁，能歌善舞，说着汉人听不懂的语言。所以在得知我是新疆人后，几乎都会怀疑的问一句，“你怎么长都不像新疆人呀？你们新疆话咋说呀?你说的也不是新疆话呀？”尽管被问了很多很多遍，对此我真的不知如何回答，说实话，他们一来不相信，二来也会深感失落，新疆原来本非与其想象中的特别和神秘。有时我被惹毛了，会反问他们，“你觉得新疆人应该长什么样，新疆话应该怎么讲？”。现在，已不知不觉离开新疆 7 年，才慢慢发现，媒体、电视、网络、书籍中展示新疆的内容极少，人们少有途径去接触、了解较真实的新疆，才导致内地人不了解也不愿意去深入了解新疆。反倒是，维吾尔族的长相，新疆话（维吾尔族语），哈密瓜，葡萄干、核桃、巴旦木等干果；还有新疆治安不好，维吾尔族出暴徒，心狠手辣，经常搞暴乱，前者是上学阶段，地理课本或少数名族课本中了解到的新疆，后者则是最近因暴乱在新闻中了解到的新疆，这两者，构成了内地人眼中新疆的全部。作为新疆人，且热爱新疆的我，心里是委屈的。除了内地友人因不了解新疆而无意的冒犯与猜疑，也遇到过针对新疆的特殊待遇，如，大四想去西藏边境实习，需要边防证，新疆人难办，导师有顾虑，没选择我；身份证丢了不能异地办理，需本人回新疆办；去年新疆换第三代身份证，要本人回疆办理，且过期不候，派出所给我父母施压，这段时间如果不办，你孩子在内地有工作上有限制，停银行卡。办理签证、护照也要本人回疆，且比内地城市繁琐难办。而现在，心里的委屈是越来越多。从刚离开新疆到武汉上大学那会，打心底觉得新疆好，除了气候环境比武汉好太多，一年四季分明，夏天不闷热潮湿，冬天无阴冷潮湿。在新疆生活接触的人，也比其他省份要朴实简单。尽管还会有不少涉及新疆的暴乱新闻出现，外加切糕事件，有人因此对新疆有了敌意和恐惧心理。可就是那个时候，我心里是没有委屈的，仅仅是觉得，他们还不真正了解新疆，也没有在新疆亲身生活的感受，暴徒并非等同于维吾尔族人，买切糕也不能代表所有新疆人吧。但随着我在内地生活越旧，越 发现大家对新疆的认识自始至终无太多变化。都 2019 年了，绝大多人依然不知道穆斯林，不知道也不会尊重少数名族的宗教信仰，身边有些朋友依旧不敢去新疆旅游。另外，因是新疆籍，在内地办事求职遇到了愈来愈多不可理喻的不便，深圳第一份工作的大 boss，认为我离开新疆来内地发展，多半会开个牛肉拉面馆，根本不相信会安稳上班工作。从小，学校就教育我们，去了解和尊重少数名族，民族团结一家亲，要互相帮助，和睦相处。至今我依旧如此坚信，新疆各名族间就是和和睦睦的生活在一起，因为从小的我的生活感受就是如此。各名族的生活是交织在一起，相互做买卖，逛巴扎，吃馕，买羊肉串，孩子一起去学校，一起上课学习，一起踢足球，打篮球。暴恐事件后，平常老百姓的生活上其实变化不大，大家任然友好和谐共处，心中真的不存在对他名族的敌意。但最近几年，政治上、制度上变了，疆内安检仪多了，巡逻车多了，警察民兵多了；车站超市，商场、网吧、饭馆，都要过安检、查身份证了；网络有限制，手机电话有监听了；部分的小清真寺被关闭，有些少数民族干部被查被撤；团里县上老百姓每周要去升国旗；疆外，连是汉族的我都能明显感受到不公平与敌意。可想而至，如果是维吾尔族兄弟，必然更多。《我从新疆来 2》书中，几个少数名族主人翁都亲身讲述了，远超乎我想象。住旅店，被警察敲门查房；出行时被警察拦阻检查，态度蛮横无理；难租房子，昆明暴恐后，房子未到租期，也被恶意驱除，开的饭店被迫关门；街上卖干果、卖羊肉串的小贩被取缔清扫。即使父母都是清华在读博士，孩子也没能在北京上小学（之前我真认为，国家对少数民族有好政策，但怎么连在清华读博士的维吾尔族夫妇的孩子，竟然没法在北京上小学？国家不是鼓励少数民族孩子上学，接受教育吗？暴乱分子大部分不就是因为没上过学，没接受好的教育，被欺骗蛊惑而为嘛？每年的不是有内初班、内高班，送新疆少数名族都孩子去内地的北京、上海、广州、天津等大城市上学，接受好的教育吗？）正是这本书中让我知道，少数民族遭受的不公对待远非我之前了解和以为的。我心里更加纠结委屈，一方面，书中于内地生活打拼的少数民族兄弟所要面对的残酷的现实，有些情况对其是极其不公平的。另一方面多数人把对少数暴恐分子的不满、愤怒、歧视、敌意，推至全新疆少数民族身上，这有加剧了对少数民族对不公平对待。其实，我和书的作者的库尔班江，和书中的新疆汉族同伴，心里都是委屈的，都想通过自己 d 努力，让更多人知道，新疆的美，新疆人的善良友爱，新疆人同四川人、北京人、东北人，广东人是一样的，没有什么不同，也会有恶人坏人，但大部分其实与你我一样都是平凡人。 意想不到之处书中，有很多我意想不到的，在小时候生活中压根没有感受了解的事情。比如，维吾尔族并非都信教，做礼拜，这些都是自由的，汉人也可入伊斯兰教；维汉通婚并不稀奇，甚至有二婚的，有带孩子的；婚姻登记处的维吾尔族办事员，会劝说阻止上过北京电影学院的的维族小伙娶汉族姑娘。维吾尔族中好不易有受过高等教育的小伙，被汉族姑娘掳走，太可惜了!维吾尔族其实也了解并崇拜毛主席、周总理，甚至在文化大革命中有维吾尔族子女批斗其父母的； 维吾尔族青年也有找对象、被逼婚烦恼 我印象中，维汉似乎是不允许通婚的，维族青年结婚早，多是父母亲戚介绍，算半个包办婚姻，极少数自由恋爱而成婚的。没听说有维族大龄的剩男剩女，即使是现在我都不相信。其实，时代变了，汉人和少数名族是一样的呀，也是紧跟时代的呀。书中几个维族青年，不论男女，都遇到了现在青年普遍都遇到的个人情感问题，不愿意随随便便找个人将就结婚，能接受晚婚甚至不婚观念。同样的，其父母也都挺着急，会催婚，会逼婚，讲些亲戚邻里的谁家孩子结婚了，谁找到对象了，谁谁谁生孩子了的事，旁敲侧击的劝说自己孩子要早结婚早生孩子，也会帮孩子张罗相亲。 我就工作一年，只需要钱，不用成为正式员工，不用公司特意培养，也不考虑晋升 一个维族女孩，为给父母买房子，在西安一天打三分工。她告诉老饭，我就工作一年，只要钱，不要正式员工资格，不需要公司培养，也会争夺晋升机会。想法真是特别，却是她其真实想法。作为汉人，我大吃一惊，她如何能想到的呢？或许是因为不同名族之间存在着不同的思维方式吧。像她这种工作方式，是一种新型的工作雇佣关系，在将来应该很常见吧？只为钱而工作，没有其它因素的夹杂和影响，很直接，效率高。 买个维吾尔族姑娘，很有面子 在北京以跳舞为生的漂亮维族姑娘，遭遇了渣男、骗婚。她在书中讲，自己被北京艺术团相中，招至北京，在餐厅演出。艺术团里认识了个做主持的男孩，后被其强奸，中间有想强迫说服自己和他结婚算了。最后渣男本色暴露，想与其断掉关系，却受到骚扰恐吓，期间，经餐厅大哥介绍，和一个北京商人相识，并结婚了，原来这商人是个骗子，已有老婆孩子，并且因此向人炫耀，自己买了个维族姑娘， 倍有面儿。最后果断与其离婚。我很同情她，也很佩服她，即使遭受如此之苦，能勇敢讲出，依旧生活。另一方面，我在想，如果包个汉族的姑娘做小情人，商人应该还会不会四处炫耀，并自我觉得特有面儿。","categories":[{"name":"随笔感悟","slug":"随笔感悟","permalink":"https://better-jiang.github.io/categories/%E9%9A%8F%E7%AC%94%E6%84%9F%E6%82%9F/"}],"tags":[{"name":"书籍读后感","slug":"书籍读后感","permalink":"https://better-jiang.github.io/tags/%E4%B9%A6%E7%B1%8D%E8%AF%BB%E5%90%8E%E6%84%9F/"}]},{"title":"《CSS权威指南4》- 前言","slug":"《CSS权威指南》-前言","date":"2019-03-13T10:05:44.000Z","updated":"2023-02-03T12:14:22.415Z","comments":true,"path":"2019/03/13/《CSS权威指南》-前言/","link":"","permalink":"https://better-jiang.github.io/2019/03/13/%E3%80%8ACSS%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97%E3%80%8B-%E5%89%8D%E8%A8%80/","excerpt":"","text":"前言如果你是一个网页设计师或文档创作人员，且对丰富的页面样式感兴趣，想改善网站的可访问性，同时又想节约时间和精力，那么这本书正适合你。在阅读本书之前，你需要知道的东西很少，仅仅是对 HTML4.0 有适当了解，你了解的越多，也就准备的越充分，但是，这不是必须的。本书第四本版于 2017 年年中完成，并尽量反映出当时 CSS 的最新状态。我们假设的是，本书中任何详细介绍的内容，要么在写的时候已经得到大多数浏览器的支持，要么在本书出版不久后得到支持。一些还在开发中，或者已经知道不久后会抛弃的 CSS 特性，不在本书的讨论范围内。 本书中使用的约定本书使用了以下的排版约定（但要务必阅读属性的值的语法约定，注意其中的一些修改部分） 斜体 (Italic)指示 新术语、URL、电子邮件地址、文件名、文件扩展名 等宽字体 （Constant width）用于 程序清单，已经在段落中涉及到的程序元素，例如变量、函数名、数据库、数据类型、环境变量、语句和关键字 等宽粗体 (Constant width bold)显示 用户要输入的命令、或其他文本内容 等宽斜体 (COnstant width italic)显示 要被 用户输入的值或由上下文推断的值 来替代的文本。例如 在路径中 /code/username,要把 username，替换成自己的名字 属性的值的语法约定在书中，有些方框是用来分解、描述给定 CSS 属性的细节，包括那些可被允许的值，它们是从 CSS 规范逐字逐句照搬过来的，不过另外也有些语法上的解释。自始至终，每个属性的可取值都被如下的语法列出： Value: &lt;family-name&gt;# Value: &lt;url&gt; || &lt;color&gt; Value: &lt;url&gt;? &lt;color&gt; [/&lt;color&gt;]? Value: [&lt;length&gt; | thick | thin]&#123;1,4&#125; 任何在&lt; 和 &gt; (尖括号) 之间的斜体字给出了某种值的类型，或者是对另一个属性的引用。例如，属性font可以接受原本属于属性font-family 的值，由文本&lt;font-family&gt;标示。相似的，如果允许使用诸如颜色之类的值的类型，它将用&lt;color&gt; 表示。任何用等宽字体显示的词都是关键词，必须原样的显示，不需要加引号。斜线(/)和逗号(.)也必须原样显示。 一个值的定义 可有多种方式去组合： 2 个或多个关键字串在一起，且只有空格来分割它们，这意味着所有这些关键词必须按给定的顺序出现。例如，help me 表示这个属性必须以此顺序使用这些关键字。（即先 help 后 me） 如果候选项由 1 个竖线分割(X|Y),那么必须出现其中一个，且仅有一个。给定（X||Y|Z）,表示 x,y,z 中任何一个都是允许的。 双竖线(X||Y)表示出现 X,Y,或二者都出现，但是它们可以以任何顺序出现。因此:X, Y, X Y, Y X都是合法的解释。 (X &amp;&amp; Y),表示 X 和 Y 必须出现，但是可以以任何顺序。因此: X Y或 Y X都是合法的解释。 中括号[...]用于将事物分组。因此: [please || help || me] do this 表示 单词 please, help, me 可以以任何顺序出现，且每个单词只出现一次。 do this 必须出现，且是有该顺序。例如： please help me do this, help me please do this, me please help do this 每一个组合，或加了中空号的分组后可以跟（也可不跟）以下修饰符之一： 星号(*),表示它前面的值或分组重复 0 次或多次。因此，bucket*表示单词bucket可以使用任意次数，包括 0 次，且使用次数没有上限 加号(+),表示它前面的值或分组重复 1 次或多次。因此，mop+ 表示 单词mop必须使用至少一次，有可能多次。 井号(#)，表示它前面的值或分组重复一次或多次，且使用逗号(,)分割。因此,floor# 可表示floor,floor,floor,floor。它通常与分组后值类型一起使用。 问号(?)表示它前面的值或分组是可选的。比如 [pine tree]? 表示 pine tree 不一定使用，如果使用他们，就必须以指定的顺序出现。 感叹号(!)表示它前面的值或分组是必须的，因此必须产生至少一个值，即使语法上似乎表明不是这样。例如[what? is? happening?]!,必须 出现三个 标记为可选词中的至少一个 大空号中的一对数字&#123;M,N&#125;表示它前面的值或分组重复至少 M 次，最多 N 次。例如，ha&#123;1,3&#125;表示可以是 1 个，2 个，3 个 单词ha。 以下是些例子： give || me || liberty至少使用这三个词中的一个，而且可以以任何顺序使用。例如，give liberty, give me, liberty me give, give me liberty都是合法的。 [I | am]? the || warlrus单词 I,am 二选一，但不能二者都使用，而且是否使用其中之一是可选的。另外，其后必须跟the或walrus, 或者二者都可，且可以以任何顺序。因此，你可以构造出I the walrus, am walrus the, am the, I walrus, walrus the等等。 Koo+ ka-chookoo 可以有一个或多个，其后必须跟ka-choo.因此，koo koo ka-choo, koo koo koo ka-choo, koo ka-choo是合法的。koo 的数量可以是无限的，不过这要受到实现的特定限制所限。 I really&#123;1,4&#125;? [love | hate] [Microsoft | Netscape | Opera | Safari | Chrome这是 web 设计人员通用的表示选择的表达式。这个示例可以理解为I love Netscape, I really love Microsoft等类似的表达。really 可以使用 0~4 次，且不需要被逗号分隔。你也可以在love和hate中选择一个，这看起来像是某种隐喻。 It&#39;s a [mad]# world这给了我们一个机会，去尽可能多的输出使用逗号分隔的mad，而且至少有一个mad。如果只有一个mad,则不需要加逗号。因此,It&#39;s a mad, mad, mad,mad,mad world和It&#39;s mad world都是合法的解释。 [[Alpha || Baker || Cray],]&#123;2,3&#125; and Delphi2 个或 3 个Alpha,Baker,Cray后面必须跟着and Delphi.一种可能的结果:Cray,Alpha, and Delphi.在这个例子，逗号的位置取决于它在嵌套分组中的位置。（一些较老版本的 CSS 以这种方式来强制使用逗号分隔，而不是使用#修饰符） 代码示例的使用每当你看到一个代码示例图标，这意味着就有一个相关的代码示例。真实示例可以在 https://meyerweb.github.io/csstdg4figs获得到。如果你正在使用一个联网的设备上阅读此书，那么你可以点击示例图标，跳转到所参考的代码示例的实际展示。 补充的资料，以 HTML，Css，和图片 文件的形式，用于生产本书中几乎所有的图表，它可以在(https://github.com/meyerweb/csstdg4figs)[https://github.com/meyerweb/csstdg4figs]下载。请务必阅读该项目的`README.md`文件，它包含了关于该项目的任何说明。 这本书就是帮助你完成工作的。总之，如果是本书提供的示例代码，你可以在你的程序和文档中使用。你不需要联系我们获得许可，除非你复制使用了大部分代码。例如，你编写的程序，仅使用了本书中的几个代码段，是不需要获得许可的。不过，销售或发行 O’Reilly 图书的示例光盘则需要得到许可。如果引用本书，或引用本书中示例代码回答一个问题是不需要获得许可的。如果在你产品文档中大量使用书中的示例代码是需要获得许可的。我们希望大家在使用本书中的代码时能注明出处，但不强求。相关信息通常包括书名、作者、出版社、ISBN。例如，&quot;CSS:The Definitive Guide by Eric A.Meyer and Estelle Weyl (O&#39;Reilly). Copyright 2018 Eric Meyer, Estelle Weyl, 978-1-449-39319-9&quot; 如果你感觉你对代码示例的使用超出了合理的使用范围或上述的许可范围，请随时通过permissions@oreilly.com.联系我们 O’Reilly SafariSafari(以前的 Safari 在线图书)是一个面向企业、政府、教育工作者和个人的会员制的培训和参考平台。会员可以访问超过 250 家出版商（包括 O’ReillyMedia, Harvard Business Review, Prentice Hall Professional, Addison-Wesley Professional,Microsoft Press, Sams, Que, Peachpit Press, Adobe, Focal Press, Cisco Press,John Wiley &amp; Sons, Syngress, Morgan Kaufmann, IBM Redbooks, Packt, AdobePress, FT Press, Apress, Manning, New Riders, McGraw-Hill, Jones &amp; Bartlett, andCourse Technology）的数以千计的图书，培训视频，学习路径、互动教程和精选的播放列表。 联系我们请通过以下地址，向出版商提出关于本书的建议和问题： 123456O’Reilly Media, Inc.1005 Gravenstein Highway NorthSebastopol, CA 95472800-998-9938 (in the United States or Canada)707-829-0515 (international or local)707-829-0104 (fax) 我们为此书提供了 web 页面，其中列出了错误、示例和一些附件信息。你可访问该页面在http://bit.ly/css-the-definitive-guide-4e 给这本书提建议或问技术方面的问题，可以发邮件到bookquestions@oreilly.com 有关我们书籍、课程、会议和新闻的更多信息，访问我们的网站https://www.oreilly.com/ 致谢Eric Meyer出于技术和个人原因，这个版本是我参加过最具挑战的项目之一，一路上，我得到了无数人的帮助。我会尽力记住每一个人，但是如果我把你遗漏了，我很抱歉。对于 CSS 的创建者，Håkon Wium Lie 和 Bert Bos，感谢你们的远见，如果没有你们的努力，网络将是一个更加贫瘠之地。感谢不同浏览器厂商的实践者，你们付出了那么多，一路走来感谢你们让那么多事变为可能。对于版本控制软件 git,我非常感谢它在最后关头救了我。当发现有一整章的内容丢失后，但是却很容易从过去的提交中恢复。特别感谢 Simon St.Laurent,因为他相信我每次出版新章节的想法，当我不得不离开该项目很长一段时间，他一直守着的项目并等到我归来。他不知疲倦的和我一起工作，按着我提议的方式去推动事物向前进展。感谢我的合作者，Estelle，感谢你在我需要帮助时挺身而出，感谢你敏锐的如审稿人般的眼睛，感谢你对本版本做出的巨大贡献。当我没能理解 CSS 时，有很多人帮助我理解它，而且通常要经过好几轮的解释。其中一些返回了上几个版本，但大部分 帮助我适应了这个版本的 CSS 新模式。按着姓氏字母顺序排序：Rachel Andrew, Rossen Atanossov, Tab Atkins, AmeliaBellamy-Royds, Dave Cramer, Elika Etemad, Jen Simmons, Sara Soueidan, MelSumner, and Greg Whitworth。我为我疏忽而错过的任何人道歉。感谢整个社区里的 web 开发人员和设计人员，他们与我一起度过了我所经历过的最艰难时刻，无论是朋友、同事还是陌生人，我对你们的感谢之情无以言表。在某些方面，我欠你们我的生命，感谢你能听我所诉。对于我的家庭，我的妻子 kat, 我的孩子 Carolyn,Rebecca,Joshua.你们是庇护我的家园，是我天空中的太阳，是指引我方向的星星。没有你们我不可能走到这一步，谢谢你们所做的一切。 Estelle Weyl我想感谢每一个努力 使 CSS 成为今天这样子的人，以及所有助于提高技术多样性和包容性的人。我想感谢那些不知疲倦的浏览器开发者和编写 CSS 规范的开发人员。没有这些 CSS 工作组的成员，过去、现在以及将来，我们没有规则、没有标准、没有跨浏览器兼容。我对每一个 CSS 属性，从规范中加入、或删除的值，为此而思考的过程感到敬畏。像 Tab Atkins, Elika Emitad, Dave Baron, Léonie Watson, Greg Whitworth 这样的人，不仅要编写规范，还要花时间去回答问题，并向更广大的 CSS 公众解释细微差别，尤其是我。我还要感谢所有深入研究 CSS 特性的人，不论他们是否在 CSS 工作组中，还有那些对我们翻译规范有帮助的人，包括 Sarah Drasner, Val Head, Sara Souidan, Chris Coyier, Jen Simmons,和 Rachel Andrew.另外，我想感谢那些开发了使所有 CSS 开发者生活变容易的工具的人。尤其是开发并维护https://caniuse.com/.的 Alexis Deveria。我还要感谢为提高 CSS 多样性和包容性而付出时间和努力的开发社区里所有部门人员。是的，CSS 因此而了不起。在一个伟大的社区和伟大的人在一起工作对我来说是很重要的。当我在 2007 第一次参加技术大会时，与会者 93%是男性，而且 100%是白人。观众的性别多样性略低，仅种族多样性略高些。实际上，我选择参加这个会议，是因为该会的阵容比巨大大多数会议更具多样性，实际上，仅有一个女性。环顾房间，我知道事情需要改变，而我也意识到我需要做些事。当时我没有意识到，在未来的 10 年，我将遇到多少默默无闻的英雄，他们为了科技和生活中的各个领域的多样性与包容性而努力。有太多默默无闻，不知疲倦工作的人，但我想要强调其中的一些人，我无法去表达 这些人所做的积极影响，像 Erica Stanley 的《Women Who CodeAtlanta》，CarinaZona 的 《Callback Women》等等，所以这激发我去创建了一个清单http://www.standardista.com/feeding-the-diversity-pipeline/,来帮助并确保通往 web 开发职业的道路并非属于那些拥有特权的人。 谢谢大家，谢谢所有的人，谢谢你们的努力，你们所做的工作，比我 10 年前坐在那次会议上所想象的还要多。","categories":[{"name":"技术总结","slug":"技术总结","permalink":"https://better-jiang.github.io/categories/%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%93/"}],"tags":[{"name":"翻译","slug":"翻译","permalink":"https://better-jiang.github.io/tags/%E7%BF%BB%E8%AF%91/"},{"name":"CSS权威指南-第四版","slug":"CSS权威指南-第四版","permalink":"https://better-jiang.github.io/tags/CSS%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97-%E7%AC%AC%E5%9B%9B%E7%89%88/"}]},{"title":"《尘埃落定》读后感","slug":"《尘埃落定》读后感","date":"2019-03-13T09:59:59.000Z","updated":"2023-02-03T12:14:22.415Z","comments":true,"path":"2019/03/13/《尘埃落定》读后感/","link":"","permalink":"https://better-jiang.github.io/2019/03/13/%E3%80%8A%E5%B0%98%E5%9F%83%E8%90%BD%E5%AE%9A%E3%80%8B%E8%AF%BB%E5%90%8E%E6%84%9F/","excerpt":"","text":"好奇是源动力这是我第二遍读了，上一次读大约是在高中吧，那时我对少数民族很感兴趣，特想知道他们是如何生活的，是否超乎我的想象？或是否与我相同，他们是不是也会遇到各样的问题烦恼？他们又是如何面对的？他们有没有什么值得我学习效仿的好方法来解决问题，克服重重困难。讲真，这次读，多半也是此原因。因为初高中读过的书很多已经忘记，所以又去搜了些写少数名族的书籍，尤其是维族、回族、藏族，毕竟其离我的生活很近，可我却并非了解他们。另外一点让我好奇的是，他们都有我没有的宗教信仰。维族、回族信奉伊斯兰教，藏族多信奉藏传佛教，在我看来，他们大概是中国最虔诚、最特殊的，也最有神秘感的少数民族了吧。除此之外，他们所生活的环境，是很远方，很闭塞的，大部分人也许一辈子也不会去过，要去哪里更是需要胆量与勇气的。遥远边陲的新疆，总让我联想到少年时语文课本中的塞外诗，大漠孤烟，戈壁黄沙，铁马金戈，好不空旷洒脱；西藏更是世界屋基，雪域高原，人世间最后的一片净土，也是离天空最近之地，另世人向往。除了好奇他们如何生活，另一个我好奇的是，宗教信仰在其人生中是否起了巨大作用？他们自己又是如何看待的？以我和穆斯林、藏族接触，我隐隐约约能感受到，因为宗教信仰，他们都很乐观坦率，乐于助人，对陌生人没有戒备和遮掩。因为有和我差不多年纪也离家求学的孩子，陌生维族大妈会主动包车送我回家。搭过维族叔叔开的卧铺大巴从伊犁到焉耆。在那拉提，晚上睡帐篷，哈萨克族小朋友怕我冷，拿自家被子给我。在检查站，哈萨克族警察，会帮我拦愿意载我的顺路车，中午还让我去房子吃了抓饭，喝了奶茶。大学里，同班的藏族同学，总有一副洒脱不羁之态，无忧无虑的，毫无烦恼。校内的藏族学生，不分年纪的会经常组织活动，打篮球、踢足球，且喜好裸露上身。宿舍晚上，藏族同学常常三五个人到某人宿舍，耍乐高歌。很多时候，我会在想，为什么我做不到如他们一样坦荡真诚呢？不惧怕出丑，不害怕失败，不忧心忡忡，不多思多虑，不瞻前顾后，不犹犹豫豫呢？深究其因，大概是心里找不到安稳的支撑吧，总在害怕什么东西似的。如果真的是真主或佛祖给了他们力量和勇气，那谁会给我这些呢？更何况，我打心底里不相信真主、上帝的存在？从小，我就被灌输了知识才是力量，努力方能克服困难的人生信条。但如果在知识还不足，努力还不够时，内心迷惘不定，心神焦悴时，该如何去处理呢？绝大多数，我会渐渐放弃，被击垮了，也就害怕了，不会再轻易去挑战那些苦差事。路越走越窄，能去的地方越来越少，见到的事与物与人也趋于固定，我囚困于此。如果，不曾好奇，就不会有新发现，不会把它拿来和自己比较，比较后才感受到，原来外面的世界如此缤纷不同。这个过程里，我常常发现了自己喜欢的，想要的，自然而然的会去努力追寻，有了追求的人生，似乎没了寂寞孤单。 专注、不受他人影响麦其吐司的小儿子，因为是傻子，所以能随心所欲，想做什么就做什么，想说就说，不想说就不说。他影响不了别人，因为正常人是不会听进一个傻子之言。反过来，别人也不会去打搅他，因为你说什么傻子不懂，也就没法利用。就因如此，傻子可按自我意愿行事说话，且无人干扰。很多事、很多人失败了，原因就是受到外界的恶意阻挠或善意帮助。比如，父母眼中的大龄剩男剩女，需要恋爱结婚，父母会催促帮忙、搜罗相亲对象、逼婚，结果适得其反。工作中的“猪队友”，“狗上司”，多会徒增不必要的工作量。如何能做到，如傻儿子一样呢？装傻 B，我极笨特傻，不但没有利用价值，还会给人添麻烦。装高冷，我不好相处，压根瞧不上你，你谁呀？你滚吧。装严肃，我严于律己，也严以待人，你不能有定点差错，否则吃不了兜着走。而我，选择了自闭，不主动，能拒则据。不对！！！王阳明早就给了答案，当你感到困扰时，应该向内看，去刨析自己的内心。看看自己的“良知”是否有缺陷？ 要不断的“致良知”，要“知行合一”。有了想法，就要去实践，在“行”中，会加深对“知”理解。而不要做思想的巨人，行动的矮子。 为何你不够专注？没有目标，就会有乱思杂念，谈不上专注。有了目标，但因人本能的惰性，趋利避害，选择了做轻松享乐之事。归根结底，就是“良知”还不够，没法子抵制本能的惰性，要用心去修行锻炼。吾日三省吾身，为何抵挡不住享乐与偷懒？享乐后、偷懒后，得到了什么？它们是我需要的吗？与此同时，我又失去了什么？那一刻，为何做如此选择？这个选择受到什么影响？这影响之前有无预兆，是否能提前防范？ 时间不会在困苦处停止的专注于某事，时间不会在困苦处停止的，用平静的心态，一样能面对并度过。比如，算上今天，我已连续使用流利说 APP 学习 英语口语 30min 以上 24 天了。刚开始，我没认为能坚持下去。每天 30min 其实对我是一种煎熬，很难，会害怕面对它。所以我先 一边上厕所一边讲口语，来骗自己，好让我感觉是在上厕所，而不是在 30min 中的煎熬里。然后，起身对着镜子讲口语，也是骗自己，我是在自娱自乐中，也不是在煎熬中。或者，站在窗前，对着窗外讲口语、躺着讲、趴在健身球上讲、在等外卖的时候讲，总之，就是不愿意正面刚这 30min。后来，突然意识到，这 30min 一定会过去的，时间永远不会停止的。我大可平平静静的讲口语，一句接着一句讲，反正 30min 百分百会过去，有什么好怕的呢？","categories":[{"name":"随笔感悟","slug":"随笔感悟","permalink":"https://better-jiang.github.io/categories/%E9%9A%8F%E7%AC%94%E6%84%9F%E6%82%9F/"}],"tags":[{"name":"书籍读后感","slug":"书籍读后感","permalink":"https://better-jiang.github.io/tags/%E4%B9%A6%E7%B1%8D%E8%AF%BB%E5%90%8E%E6%84%9F/"}]},{"title":"Vue-查缺补漏(5)-异步更新队列","slug":"Vue-查缺补漏-5-异步更新队列","date":"2019-03-02T08:29:06.000Z","updated":"2023-02-03T12:14:22.414Z","comments":true,"path":"2019/03/02/Vue-查缺补漏-5-异步更新队列/","link":"","permalink":"https://better-jiang.github.io/2019/03/02/Vue-%E6%9F%A5%E7%BC%BA%E8%A1%A5%E6%BC%8F-5-%E5%BC%82%E6%AD%A5%E6%9B%B4%E6%96%B0%E9%98%9F%E5%88%97/","excerpt":"","text":"一个例子,有一个div，默认用v-if将它隐藏，点击一个按钮后，改变v-if的值，使div显现，同时获取div的文本内容 12&lt;div ref=&quot;div&quot; v-if=&quot;showDiv&quot;&gt;隐藏div内容&lt;/div&gt; &lt;button @click=&quot;getText&quot;&gt;获取文本内容&lt;/button&gt; 1234567methods: &#123; getText: function() &#123; this.showDiv = true; let text = this.$refs.div.innerHTML; alert(text); &#125;&#125; 运行后出错：Cannot read property &#39;innerHTML&#39; of undefined,获取不到div元素。此涉及到 Vue 的一个重要概念：异步更新队列 异步更新队列Vue 在观察到数据变化并不会直接更新 DOM，而是开启一个队列，并缓冲在同一事件循环中发生的所有数据变化。并在缓冲时去重重复数据，从而避免不必要的计算和 DOM 操作。如果同一个watcher被多次触发，只会被推入队列中一次。然后，在下一个事件循环tick中，Vue 刷新队列并执行实际（已去重的）工作。所以，在设置this.showDiv = true后，改组件不会立即被渲染，当刷新队列时，组件会在下一个tick更新渲染。为了在数据变化之后等待Vue 完成更新 DOM，可以在数据变化后立即使用vm.$nextTick(callBack),这样回调函数在 DOM 更新后就会被调用了。回调函数中的this将自动绑定到调用它的 Vue 实例上 123456789methods: &#123; getText: function() &#123; this.showDiv = true; this.$nextTick(function() &#123; let text = this.$refs.div.innerHTML; alert(text); &#125;); &#125;&#125; 因为$nextTick()返回一个Promise对象，所以可以使用新的ES2016 async/await 语法来 实现 12345678methods: &#123; getText: async function() &#123; this.showDiv = true; await this.#nextTick(); let text = this.$refs.div.innerHTML; alert(text); &#125;&#125;","categories":[{"name":"技术总结","slug":"技术总结","permalink":"https://better-jiang.github.io/categories/%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%93/"}],"tags":[{"name":"vue","slug":"vue","permalink":"https://better-jiang.github.io/tags/vue/"}]},{"title":"Vue-查缺补漏(4)-组件高级用法","slug":"Vue-查缺补漏-4-组件高级用法","date":"2019-03-02T07:21:53.000Z","updated":"2023-02-03T12:14:22.414Z","comments":true,"path":"2019/03/02/Vue-查缺补漏-4-组件高级用法/","link":"","permalink":"https://better-jiang.github.io/2019/03/02/Vue-%E6%9F%A5%E7%BC%BA%E8%A1%A5%E6%BC%8F-4-%E7%BB%84%E4%BB%B6%E9%AB%98%E7%BA%A7%E7%94%A8%E6%B3%95/","excerpt":"","text":"递归组件组件可以在其自己的模板中调用自身，**需要设置name选项，且通过name选项**。递归组件可用来开发一些具有未知层级关系的独立组件，如级联选择器、树形控件等。注意，必须给出一个条件来限定递归数量，否则抛出Maximum call stack size错误 1234567891011121314151617// 递归组件 Vue.component(&#x27;recursion-component&#x27;, &#123; name: &#x27;recursion-component&#x27;, props: &#123; count: &#123; type: Number, default: 2 &#125; &#125;, template: `&lt;div class=&quot;nn&quot;&gt; &lt;recursion-component :count=&quot;count + 1&quot; v-if=&quot;count &lt; 3&quot;&gt; &lt;/recursion-component&gt; &lt;/div&gt;` &#125;); 动态组件Vue 提供了一个特殊元素&lt;component&gt;，用来动态地挂载不同的组件，并使用is属性来选择要挂载的组件另外使用&lt;keep-alive&gt;元素，把动态组件包裹起来，可以把那些被创建的 组件实例缓存下来，而不是在切换时，反复重新渲染注意：&lt;keep-alive&gt;要求被 切换到的组件都要有自己的名字，通过name选项设置 123&lt;keep-alive&gt; &lt;component v-bind:is=&quot;currentComponent&quot;&gt;&lt;/component&gt;&lt;/keep-alive&gt; 异步组件当工程足够大，使用的组件足够多时，需要考虑性能问题，因此一开始把所有的组件都加载是没有必要的开销。Vue 允许将组件定义为一个工厂函数，动态地解析组件。Vue 只在组件需要渲染时触发工厂函数，并把结果缓存，用于后面的再次渲染。推荐用法： 异步组件和webpack的code-splitting 功能配合使用 1234567 Vue.component(&#x27;async-component&#x27;, function(resolve, reject) &#123; setTimeout(function() &#123; resolve(&#123; template: &#x27;&lt;div&gt;异步渲染&lt;/div&gt;&#x27; &#125;); &#125;, 5000);&#125;);","categories":[{"name":"技术总结","slug":"技术总结","permalink":"https://better-jiang.github.io/categories/%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%93/"}],"tags":[{"name":"vue","slug":"vue","permalink":"https://better-jiang.github.io/tags/vue/"}]},{"title":"Vue-查缺补漏(3)-插槽(slot)","slug":"Vue-查缺补漏-3-插槽-slot","date":"2019-03-02T02:54:26.000Z","updated":"2023-02-03T12:14:22.414Z","comments":true,"path":"2019/03/02/Vue-查缺补漏-3-插槽-slot/","link":"","permalink":"https://better-jiang.github.io/2019/03/02/Vue-%E6%9F%A5%E7%BC%BA%E8%A1%A5%E6%BC%8F-3-%E6%8F%92%E6%A7%BD-slot/","excerpt":"","text":"当需要让组件组合使用，混合父组件的内容与子组件的模板时，就会用到slot，这个过程叫作内容分发.将&lt;slot&gt;元素作为承载分发内容的出口。props传递数据，events触发事件，slot内容分发，再复杂的组件也是由这 3 部分构成的。 插槽内容插槽可以包含任何模板代码，包括 HTML，甚至其他组件。 作用域父组件模板的内容是在父组件作用域内编译，子组件模板内容在子组件作用内编译。 slot分发的内容，作用域是在父组件上。 12345&lt;my-child url=&quot;/profile&quot;&gt; send to :&#123;&#123;url&#125;&#125; Logged in as &#123;&#123;use.name&#125;&#125;&lt;/my-child&gt;&lt;!-- 这里的url,是undefined,因为&#x27;/profile是传递给&lt;my-child&gt;组件的，并不在父组件作用域内&#x27; --&gt; 默认内容父组件在没有提供任何插槽内容时，则会渲染插槽默认内容 1234567891011&lt;button type=&quot;submit&quot;&gt; &lt;slot&gt;Submit&lt;/slot&gt;&lt;/button&gt;&lt;!-- 如果父组件使用改组件,并且不提供任何插槽内容，则渲染： --&gt;&lt;button type=&quot;submit&quot;&gt; Submit&lt;/button&gt;&lt;!-- 如果提供了内容，&lt;submit-buton&gt;Save&lt;/submit-button&gt;，则渲染为： --&gt; &lt;button type=&quot;submit&quot;&gt; Save&lt;/button&gt; ####（2.6.0 中，具名插槽和作用域插槽会引入统一的语法v-slot指令，它取代了slot和slot-scope目前已被废弃但未移除，在 Vue3 中将被移除） 具名插槽在&lt;slot&gt;元素，用特殊的特性name，来定义额外的插槽，一个不带name的&lt;slot&gt;出口会自动带有隐含的名字default.在向具名插槽提供内容时，可在&lt;template&gt;元素上使用v-slot指令，以v-slot的参数的形式提供其插槽名称。 1234567891011121314151617181920212223242526&lt;!-- 带有具名插槽的组件&lt;base-layout&gt; --&gt;&lt;div class=&quot;container&quot;&gt; &lt;header&gt; &lt;slot name=&quot;header&quot;&gt;&lt;/slot&gt; &lt;/header&gt; &lt;main&gt; &lt;slot&gt;&lt;/slot&gt; &lt;!--实际上： &lt;slot name=&quot;default&quot;&gt;&lt;/slot&gt; --&gt; &lt;/main&gt; &lt;footer&gt; &lt;slot name=&quot;footer&quot;&gt;&lt;/slot&gt; &lt;/footer&gt;&lt;/div&gt;&lt;!-- 向具名插槽提供内容 --&gt;&lt;base-layout&gt;&lt;template v-slot:header&gt; &lt;h1&gt;page title&lt;/h1&gt;&lt;/template&gt; &lt;template v-slot:default&gt; &lt;h1&gt;page main&lt;/h1&gt;&lt;/template&gt; &lt;template v-slot:footer&gt; &lt;h1&gt;page foter&lt;/h1&gt;&lt;/template&gt;&lt;/base-layout&gt; 作用域插槽让插槽内容能够访问子组件才有的数据。 123456&lt;!-- &lt;current-user&gt;组件的模板 --&gt; &lt;span&gt; &lt;slot v-bind:user=&quot;user&quot;&gt; &#123;&#123;user.lastName&#125;&#125; &lt;/slot&gt; &lt;/span&gt; 绑定在&lt;slot&gt;元素上的特性被称作插槽prop.在父级作用域中，给v-slot带一个值来定义我们提供的插槽 prop 的名字. 12345&lt;current-user&gt; &lt;template v-slot:default=&quot;slotProps&quot;&gt; &#123;&#123;slotProps.user.firstName&#125;&#125; &lt;/template&gt;&lt;/current-user&gt; 在此例中，把包含所有插槽 prop 的对象命名为slotProps 解构插槽 Prop作用域插槽的内部工作原理：将你的插槽内容包括在一个需要传入单个参数的函数里 123function (slotProps) &#123; // 插槽内容&#125; 所以， v-slot的值实际上可以是任何能过作为函数的参数的 js 表达式,也就可以使用ES2015 解构来传入具体的插槽 prop. 123&lt;current-user v-slot:default=&quot;&#123; user &#125;&quot;&gt; &#123;&#123; user.firstName &#125;&#125;&lt;/current-user&gt; 动态插槽名动态指令参数也可以用在v-slot指令上，来定义动态的插槽名 动态指令参数: 2.6.0 新增，可用 方括号括起来的 js 表达式作为一个指令的参数 123&lt;a v-bind:[attributeName]=&quot;url&quot;&gt;&lt;/a&gt; &lt;a v-on:[eventName]=&quot;doSomething&quot;&gt;&lt;/a&gt; 动态插槽名 12345&lt;base-layout&gt; &lt;template v-slot:[dynamicSlotName]&gt; ... &lt;/template&gt;&lt;/base-layout&gt;","categories":[{"name":"技术总结","slug":"技术总结","permalink":"https://better-jiang.github.io/categories/%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%93/"}],"tags":[{"name":"vue","slug":"vue","permalink":"https://better-jiang.github.io/tags/vue/"}]},{"title":"Vue-查缺补漏(2)-组件","slug":"Vue-查缺补漏-2-组件","date":"2019-03-01T03:58:53.000Z","updated":"2023-02-03T12:14:22.414Z","comments":true,"path":"2019/03/01/Vue-查缺补漏-2-组件/","link":"","permalink":"https://better-jiang.github.io/2019/03/01/Vue-%E6%9F%A5%E7%BC%BA%E8%A1%A5%E6%BC%8F-2-%E7%BB%84%E4%BB%B6/","excerpt":"","text":"DOM 模板解析 注意事项Vue 组件的模板在某些情况下会受到 HTML 的限制。ul,ol,table,select这些元素,只有某些特定的元素才能出现在它们内部。li,tr,option这些元素只能出现在特定的元素内部。 12345678&lt;!-- &lt;talbe&gt;元素 内只规定只允许出现&lt;tr&gt;,&lt;td&gt;,&lt;th&gt;等表格元素，所有在此内的直接使用组件时会被作为无效是内容提升到外部--&gt; &lt;table&gt; &lt;my-component&gt;&lt;/my-component&gt; &lt;/table&gt; &lt;!-- 这种情况下，需要使用 is 属性来挂载组件 --&gt; &lt;table&gt; &lt;tr is=&quot;my-component&quot;&gt;&lt;/tr&gt; &lt;/table&gt; 如果从以下来源使用的模板的话，不存在该限制 字符串模板（template:’…’） 单文件组件（.vue） &lt;script type=&quot;text/x-template&quot;&gt; 使用props 传递数据 选项 props的值 2 种，字符串数组、对象;这些传递的是一个静态的值 字符串数组,一种简便方式1props: [&#x27;message&#x27;, &#x27;message2&#x27;]; 对象,可定制prop的验证方法；123456789101112131415161718192021props: &#123; message: Number, //多个可能的类型 message2:[String,Number], message3: &#123; type: [String, Number], required: true, default: 100, // 验证函数 validator: function(value) &#123; return parseInt(value) &gt; 100; &#125; &#125;, message4: &#123; type: Object, // 对象 和 数组默认值 必须从一个工厂函数获取 default: function() &#123; return &#123;name: &#x27;22&#x27;&#125; &#125; &#125;&#125; 使用v-bind，动态给Prop赋值，任何类型的值都可以传给一个Prop 123456789101112131415&lt;!-- 传入一个数字 --&gt;&lt;!-- `42`即便是静态的，当使用`v-bind`告诉 Vue，这是一个js表达式（返回number类型），而不是一个字符串 --&gt;&lt;my-component v-bind:message=&quot;42&quot;&gt;&lt;/my-component&gt;&lt;!-- 传入一个布尔值 --&gt;&lt;!-- 包含 该 Prop ，在没有值的情况下，表示：`true` --&gt;&lt;my-component message&gt;&lt;/my-component&gt;&lt;!-- `false`是静态的，但`v-bind`告诉了 Vue,t它是一个js表达式(返回Booelean false),而不是一个字符串 --&gt;&lt;my-component v-bind:message=&quot;false&quot;&gt;&lt;/my-component&gt;&lt;!-- 同理，传入一个对象，数字 --&gt;&lt;my-component v-bind:message=&quot;&#123; name: &#x27;jaing&#x27;, age: 27&#125;&quot;&gt;&lt;/my-component&gt;&lt;my-component v-bind:message=&quot;[&#x27;133&#x27;,3334,&#x27;nihao&#x27;]&quot;&gt;&lt;/my-component&gt; Prop验证，是在组件实例创建之前进行验证，所有实例的属性在default,validator函数中是不可用的 数据流流向props传递的数据是单向的，父组件数据变化会传递给子组件，反过来不行。 2 种 改变 Prop情况 父组件传递初始值进来，子组件在data内再声明一个数据，引用父组件的prop，这样就可以在自己的作用域下随意使用和修改12345678910// 组件中声明了count,它在组件初始化时会获取来自父组件的initCount，之后就与父组件无关了，只用维护count，避免直接操作initCountVue.component(&#x27;my-component&#x27;,&#123; props: [&#x27;initCount&#x27;], template: `&lt;div&gt;&#123;&#123; count &#125;&#125;&lt;/div&gt;`, data: function () &#123; return &#123; count: this.initCount &#125; &#125;&#125;) 子组件的数据依赖父组件的props传入的数据,这种情况用计算属性1234567891011Vue.component(&#x27;my-component&#x27;, &#123; props: [&#x27;width&#x27;], template: &#x27;&lt;div :style=&quot;style&quot;&gt;组件内容&lt;/div&gt;&#x27;, computed: &#123; style: function() &#123; return &#123; width: this.width + &#x27;px&#x27; &#125; &#125; &#125;&#125;) 自定义事件 事件名称因为v-on事件监听器在 DOM 模板中会被自动转换为全小写（HTML 大小写不敏感）,v-on:myEvent会被转换成v-on:myevent，所以导致myEvent不被监听到。因此，最好使用 kebab-case 的事件名 自定义组件的 v-model具有双向绑定的v-model（本质上：语法糖）组件,需要满足以下条件： 12345678&lt;!-- 绑定value值，接受value `prop` --&gt;&lt;!-- 触发input事件时，$event的值，赋给 text --&gt;&lt;my-input v-bind:value=&quot;text&quot; v-on:input=&quot;text=$event&quot;&gt;&lt;/my-input&gt;&lt;!-- 自定义组件，就可以使用v-model 指令 --&gt;&lt;my-input v-model=&quot;something&quot;&gt;&lt;my-input&gt; 接受一个 value的prop 在value改变时，触发input事件 12345678910111213&lt;my-component v-model=&quot;total&quot;&gt;&lt;/my-component&gt;// 注册组件Vue.component(&#x27;my-component&#x27;,&#123; props: [&#x27;value&#x27;], template:&#x27;&lt;input :value=&quot;value&quot; @input=&quot;updateValue&quot;&gt;&#x27;, methods: &#123; // 默认参数：DOM事件 updateValue: function(event) &#123; this.$emit(&#x27;input&#x27;, event.target.value); &#125; &#125;&#125;) 原生事件绑定到组件在一个组件的根元素直接监听一个原生事件，使用v-on的.native修饰符 1&lt;base-input v-on:click.native=&quot;onClick&quot;&gt;&lt;/base-input&gt; 构建完全透明的包裹器（扩展组件） vm.$listeners,它是一个对象，包含了父作用域中的v-on（不包含.native 修饰符的）事件监听器。它可以通过v-on=&quot;$listeners&quot;出入到 内部的子组件，从而在 父组件上跟 子组件 相同的监听器都可以工作 vm.$props,当前组件接受的 props 对象 vm.$attrs, 它是一个对象，包含了 父作用域（父组件）中的不作为prop，且可获取的特性绑定（class,style除外）。当一个组件没有声明任何prop时，这里会包含所有父作用域的绑定。并且可以通过v-bind=&quot;$attrs&quot;传入内部的子组件。 选项inhertAttrs,默认情况，父作用域的不被作为props的特性绑定，将会”回退”且作为普通 HTML 特性应用在子元素的根元素上。设置 false,取消。在通过vm.$attrs让其特性生效，且通过 v-bind 显性的绑定到非根元素。 extend选项，引用一个”子类”, 父组件的data,覆盖其data. 12345678910// 这边 `base-table`组件时一个完全透明的包裹器，它完全像一个普通 ivewz 中的 `table`组件// 所有跟ivew `table`组件相同的特性和监听器`base-table`都可以使用import &#123; Table &#125; from &quot;iview&quot;;Vue.component(&#x27;base-table&#x27;, &#123; inheritAttrs: fasle, extends: Table, // 扩展Table组件，合并 template: `&lt;div&gt; &lt;Table v-on=&quot;$listeners&quot; v-bind=&quot;$props&quot;&gt;&lt;/Table&gt; &lt;/div&gt;`&#125;) 父链，子链 ref子组件索引在组件中，可以使用vm.$parent，直接访问 该组件的父组件或父实例。父组件也可以 通过vm.$children访问 它所有的子组件.当子组件太多时，通过vm.$children来遍历出我们需要的一个子组件实例是比较困难的，尤其是组件动态渲染时，它们的序列不固定。使用特殊的属性ref来为子组件指定一个索引名称，在通过vm.$refs（一个对象，持有注册过ref特性的所有DOM元素和组件实例）找到该组件。$refs只在组件渲染完后才被注册，并非响应式的，应该避免在模板中或计算 属性中使用$refs.","categories":[{"name":"技术总结","slug":"技术总结","permalink":"https://better-jiang.github.io/categories/%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%93/"}],"tags":[{"name":"vue","slug":"vue","permalink":"https://better-jiang.github.io/tags/vue/"}]},{"title":"Vue-查缺补漏","slug":"Vue-查缺补漏","date":"2019-02-28T01:24:34.000Z","updated":"2023-02-03T12:14:22.414Z","comments":true,"path":"2019/02/28/Vue-查缺补漏/","link":"","permalink":"https://better-jiang.github.io/2019/02/28/Vue-%E6%9F%A5%E7%BC%BA%E8%A1%A5%E6%BC%8F/","excerpt":"","text":"MVVMMVVM(Model-View-ViewModel)：它将 View 和 Model 分割开，利用 ViewModel 将 Model 中的数据经过一定的处理变成适用于 View 的数据结构并传送到 View 渲染界面，同时 view 层的视图更新也会通知 viewModel，然后再更新 model 中的数据。View 和 ViewModel 之间通过双向绑定建立联系。 选项 el el 用于指定一个页面已经存在的 DOM 元素来挂载 Vue 实例 el可以是 HTMLElement，也可以是 CSS 选择器 挂载成功后，可通过 vm.$el 来访问该元素 选项 data Vue 实例中的 data选项，声明应用内需要双向绑定的数据（建议所有用的的数据都预先再data内声明，这样不至于将数据散落在业务逻辑中，难以维护） Vue 实例本身也代理了data对象中所有的属性,同时也代理methods里的方法,所有可以直接通过 vue 实例来访问属性，调用方法 除了显示声明data外，也可以指向一个已有的变量，并且它们之间默认建立了双向绑定 Vue 生命周期函数 beforeCreate -&gt; created进行初始化事件、进行数据的观测。在 created时，数据已经和data属性进行绑定，此时还没有el选项， created -&gt; beforeMount 首先判断对象是否有el选项有，继续向下编译；没有，则停止编译。可通过手动在**Vue 实例上调用vm.$mount(el)**方法继续向下执行。 判断 对象是否有 template选项有，则将其作为模板编译成render函数；没有，则将外部 HTML 作物模板编译。template 选项 优先级高于outer HTML 如果对象还有render函数，以createElement作为函数，则直接用它渲染 综合排名优先级：render函数选项 &gt; template选项 &gt; outer HTML beforeMount -&gt; mounted给 Vue 实例对象添加$el成员，并替换掉要挂载的 DOM 元素。 beforeUpdate -&gt; updated当 Vue 发现data中数据变化，会触发对应组件的重新渲染 双括号(Mustache 语法)中的表达式双括号中，只支持单个表达式，不支持语句和流程控制；不能直接使用用户自定义的全局变量，只能使用 Vue 白名单内的全局变量，如Math、Date. 过滤器 filters 选项可自定义过滤器，用于常见文本格式化，在 2 个地方使用，在表达式尾部，由管道（|）符号指示.过滤器函数总接受表达式的值作第一参数,也可接受多个参数 双大括号插值中 123&#123;&#123; message | filterA | filterB(&#x27;arg1&#x27;, arg2)&#125;&#125;// message 的值作为 filterA函数 第一个参数// filterA 函数的返回值，作为 filterB函数的 第一参数， 字符串&quot;arg1&quot;,作为第二个参数， 表达式 arg2 的值作为第三个参数 v-bind表达式 1&lt;div v-bind:class=&quot;class | fromatClass&quot;&gt;&lt;/div&gt; 表达式 和 语句表达式(expression) 它是由常量、变量、运算符组合，计算以后返回一个结果值。表达式本身什么事情也不做，只是返回结果值。 表达式 2 个作用： 放在赋值语句的右边 作为函数的参数 语句(statement) js 整句或命令，以分号结束，语句用来自行使某件事发生 赋值或函数调用这些有副作用的表达式，可以作为单独的语句。这种把表达式当作语句的用法称作表达式语句 计算属性 默认getter方法来读取一个计算属性，，需要时也可以提供setter方法,当 手动修改计算属性的值，会触发setter 函数，执行一些自定义操作。 计算属性可以依赖其他计算属性 计算属性不仅可以依赖当前 Vue 实例的数据，也可以依赖其他实例的数据 (一个组件需要依赖另一个组件的数据) 计算属性是基于它的依赖缓存的，如果一个计算属性所依赖的数据发生变化时，它才会重新取值。 v-bind 指令动态的更新 HTML 元素上的属性，当数据变化，就会重新渲染。 绑定 class 几种方式 对象语法 对象中可以传入多个属性，来动态切换class. 对象内每项表达式为真时，对应的类名就会加上。 123456&lt;div :class=&quot;&#123;&#x27;active&#x27;: isActive, &#x27;error&#x27;: isError&#125;&quot;&gt;&lt;/div&gt;&lt;!-- 当数据 isActive, isError,为真时，对应类名active,error就会加载 当数据isActive, isError变化，对应类名也会更新 --&gt; 当:class的 表达式过长、逻辑复杂时，可 绑定一个返回对象的计算属性。 数组语法给:class绑定一个数组，应用一个 class 列表 123456&lt;div :class=&quot;[activeCls, errorCls]&quot;&gt;&lt;/div&gt;data: &#123; activeCls: &#x27;active&#x27;, errorCls: &#x27;error&#x27;, &#125;&lt;!-- 结果 --&gt;&lt;div class=&quot;active error&quot;&gt;&lt;/div&gt; 当直接在自定义组件使用class或:class，样式规则会直接应用到这个组件的根元素上；如果需要给具体的子元素设置类名，应当使用组件的props来传递。 条件渲染指令 v-if，表达式的值为真，当前组件/元素及所有子节点将被渲染，为假时被移除。 如果一次判断多个元素，可在内置&lt;template&gt;元素上使用条件指令，最终的渲染结果不会包含该元素。 Vue 在渲染时，出于效率考虑,会尽可能的复用已有的元素而非重新渲染。添加key属性后，就不会复用了。key的必须时唯一的。 v-show不能在&lt;template&gt;上使用。 v-show是改变元素的 CSS 属性display，无论条件真假，都会被编译，用于频繁切换条件。 列表渲染指令v-for 遍历数组时，1 个可选参数，当前项的索引；枚举对象属性时，2 个可选参数，键名、索引 f-for也可以用在内置&lt;template&gt;上，将多个元素进行渲染 数组变异方法，可改变原数组 push() pop() shift(), 从数组头部删除一个元素 unshift()， 从数据头部添加一个元素 splice(), [拼接]，可添加/删除元素，参数[index,howmany,item…] index, 必填，添加/删除的位置 howmany,必填，要删除的元素个数， 0，则不删除元素 item1,…,itemX, 可选，向数组中添加的新元素 sort() reverse() 数组非变异方法，不改变原数组.在使用，可以用新数组替换原数组，含有相同 元素的项不会重新渲染，因此可以 大胆替换，不用担心性能问题 filter() concat() slice() Vue 不能监测到的数组变动 利用索引设置一个项时， vm.items[indexOfItem]= newValue;解决方法：vm.$set(vm.items, indexOfItem, newValue) 修改数组的长度时 vm.items.length = newLength;解决方法: vm.items.splice(newLength) Vue 不能监测到对象属性的添加或删除 对于已经创建的实例，Vue 不能动态的添加根级别的响应属性。但可以使用Vue.set(object,key,value)方法向嵌套对象添加响应式属性。 1vm.$set(vm.userProfile,&#x27;age&#x27;,27); 有时需要为已有对象添加多个新属性，比如使用Object.assign()。这种情况，应该用 2 个对象的属性创建一个新的对象 12345vm.userProfile = Object.assign(&#123;&#125;,vm.userProfile,&#123; age: 27, favoriteColor: &#x27;Vue Green&#x27;&#125;) 显示一个数组的过滤/排序结果，但不改变或重置原始数据。这种情况下，可以创建返回过滤或排序数组的计算属性， 在计算属性不适用的情况下(例如，在嵌套v-for循环中)，可以使用一个method方法 1&lt;li v-for=&quot;n in even(numbers)&quot;&gt;&#123;&#123; n &#125;&#125;&lt;/li&gt; 同一节点，v-for的优先级比v-if高 12&lt;!-- 只渲染 未完成的todos --&gt;&lt;li v-for=&quot;todo in todos&quot; v-if=&quot;!todo.isComplete&quot;&gt;&lt;/li&gt; 事件处理 DOM 事件流（event flow）存在三个阶段：事件捕获、处于目标阶段、事件冒泡.触发顺序:先捕获再冒泡 事件捕获：当触发 DOM 事件时，浏览器会从 根节点 开始由外到内进行事件传播。即点击子元素，若果父元素通过事件捕获方式注册了对应的事件的话，会先触发父元素绑定的事件。 事件冒泡：与事件捕获相反，由内到外进行事件传播，直到根节点。 v-on，1.可直接写 Js 代码；2.调用的方法名；3.内联 js 语句中调用方法，$event，访问原始 DOM 事件。123&lt;button v-on:click=&quot;warn(&#x27;Form cannot be submitted yet.&#x27;, $event)&quot;&gt; Submit&lt;/button&gt; 使用事件修饰符，此为更好的方式：方法只有纯粹的数据逻辑，而不是去处理 DOM 事件的细节。 .stop, 阻止事件继续传播（例如：阻止子节点事件，冒泡到父节点） .prevent, 阻止默认事件 .capture，&lt;div v-on:click.capture=&quot;doThis&quot;&gt;...&lt;/div&gt; 添加事件监听器使用事件捕获模式（即，元素自身触发的事件先在此处理，然后才交给内部元素进行处理） .self, 只有再event.target 是从当前元素自身触发，（即事件不是从内部元素冒泡触发的） 表单 与 v-model 使用v-model后，表单控件显示的值只依赖所绑定的数据，不再关系初始化时的 value 属性。对再&lt;textarea&gt;&lt;/textarea&gt;之间插入的值，也不会生效。它本质上不过是语法糖，负责监听用户的输入事件以更新数据 v-model会忽略所有表单元素的value,checked,selected特性的初始值，而总是将 vue 实例中的数据作为数据来源，并在data选项中声明初始值。 v-model 在内部使用不同的属性为不同的输入元素并抛出不同的事件： text, textarea使用value属性和input事件 checkbox,radio使用checked属性和change事件 select，将value作为 prop,change事件。 对于单选、复选框、选择框，v-model绑定的值通常是静态的字符串并配合value使用； 对于只有一个选项的复选框，没有value属性，则绑定布尔值;有多个选项的复选框时，**v-model都有绑定到同一个数组类型**，否则默认为布尔类型 选项列表，同样也分为单选和多选 2 中方式12345&lt;select v-model=&quot;selected&quot; multiple&gt; &lt;option&gt;html&lt;/option&gt; &lt;option value=&quot;js&quot;&gt;javaScript&lt;/option&gt; &lt;option&gt;css&lt;/option&gt;&lt;/select&gt; 单选，为备选项，如果含有value属性，v-model会优先匹配value的值，如果没有，则直接匹配,&lt;option&gt;的text 多选，添加multiple属性，此时v-model绑定的时一个数组 &lt;option&gt;备选项如果用v-for动态输出，value和text是用v-bind来动态输出的12345&lt;select v-model=&quot;selected&quot;&gt; &lt;option v-for=&quot;option in options&quot; :value=&quot;option.value&quot;&gt; &#123;&#123;option,text&#125;&#125; &lt;/option&gt;&lt;/select&gt; 修饰符 .lazy,v-model在每次input事件触发后将输入框的值与data选项中的数据进行同步。.lazy转变成使用change事件进行同步数据。 input事件，在元素值发生变化时触发，即在用户输入时触发。可使用在input,textarea元素 change事件，在输入框失去焦点时才会触发，输入框内容变化时不会触发。使用在input,textarea,select元素 .number,将输入转换为 Number 类型 .trim,过滤输入的首尾空格","categories":[{"name":"技术总结","slug":"技术总结","permalink":"https://better-jiang.github.io/categories/%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%93/"}],"tags":[{"name":"vue","slug":"vue","permalink":"https://better-jiang.github.io/tags/vue/"}]},{"title":"Vue中的26个小技巧","slug":"Vue中的26个小技巧","date":"2019-02-27T01:30:04.000Z","updated":"2023-02-03T12:14:22.414Z","comments":true,"path":"2019/02/27/Vue中的26个小技巧/","link":"","permalink":"https://better-jiang.github.io/2019/02/27/Vue%E4%B8%AD%E7%9A%8426%E4%B8%AA%E5%B0%8F%E6%8A%80%E5%B7%A7/","excerpt":"","text":"我们都极其痛恨浪费时间。可是当我们在编写Vue程序时,却因错误的方式不知不觉的浪费掉了时间，其实我们本可以在一开始就用对的方式。但是，我们又很难知道到底应该学习什么,这就是我为什么把这26 个教你如何避免常见的 浪费时间的事 的文章整理成列表的原因。一旦你看完这一系列的文章，你能分享给其他人，来帮助它们也节约时间。 1. 再一切还来得及之前使用 Vuex如果你正在构建一个中性到大型应用，你的应用状态（即要跟踪的所有数据）可能变得相当复杂难懂。这不仅仅指你要处理的数据量，状态和状态的所有不同的改变之间的不同交换都会增加其复杂性。而管理状态是件困难的任务，所有 有许多的 bug 和浪费时间的事都是由于非常复杂的状态和逻辑造成的。因此Vuex被创建出。了解更多关于Vuex解决的问题，以及怎样在你的应用中使用Vuex,可看看 Anthony Gore的文章-Vuex 是什么？ Vue应用数据存储初学指南 2. 理解 Vue 组件实例的工作方式Vue 设计的非常巧妙，可以提高性能，并且减少其内存占用。尽管没有必要，但是随着你构建越来越多的 vue 组件，了解 vue 组件的工作原理只会对你有所帮助。理解 Vue 组件实例,是一篇简短但是信息量大的文章，由Joshua Bemenderfer所写，谈的是 Vue 如何创建组件实例。 3. 用正确的方式，强制 Vue 去重新渲染在 99%的情况下，某些东西没有必要去重新渲染。这是一个反应性（reactivity）的问题。如果你是一个 Vue 新手，你一定需要去尽可能的多了解学习 vue 的反应性。我认为这是新手开发者最大的阻塞点（难点）之一。有时，强制组件去重新渲染实际上是做好的方法。（但是非常非常少见）迄今为止，我最受欢迎的文章-重新渲染组件的正确方法 4. Vue 不能处理多个根节点并非所有组件都只有一个根节点。 例如，如果你要渲染一个项目列表，简单的把节点列表当数组返回可能是更合理的方法。为什么没有必要把它们包装在ol或ul标签内呢？它被叫做文档片段（fragment） 文档片段 DN 描述：DocumentFragments 是 DOM 节点，但它们不是 DOM 树的一部分。通常的使用场景是创建一个文档片段，然后将创建的 DOM 元素插入文档片段中，最后再把文档片段插入到 DOM 树中。在 DOM 树种，文档片段会被替换为它的所有子元素。因为文档片段存在于内存中，并不在 DOM 树中，所以将子元素插入文档片段不会引起页面的回流（对元素位置和几何上的计算）。所以，使用文档片段通常会起到优化性能作用。 现阶段 Vue 是不支持文档片段，在 VUe3 中会支持它们。React 现在已经支持文档片段了，为实现此功能，React 团队重新了它们的渲染系统。Vue 也是如此。然而，在等待 Vue3 发布之前，你可以使用功能组件来解决这个问题。你也可以阅读文章Vue 模板 能否有多个根节点(fragments)?了解更多。 5. 使用 vuelidate，一个简单的方法来验证你的表单表单是我们从用户那获取输入的主要方式，而且它对 我们的应用程序良好运作是至关重要的。然而，表单的构建也非常的棘手。在表面上，它似乎应该相当容易编写，但是，但你开始添加验证规则和其他逻辑，它很快会变成一场噩梦。这就是Vuelidate的用武之地。它是一个库，可以非常容易的去添加自定义验证，并为你完成所有繁重的工作。了解怎样设置 Vuelidate 验证，阅读Vulidate-简单的 vue 表单验证 6. 构建彼此可以很好合作的组件最糟糕的感觉就是你意识到你之前以错误的方式构建了组件，现在不得不完全重构它。你不想过度设计你的代码，但是许多时候，像这样的事能在一开始就可以避免的。Kevin Ball 写了篇文章，概述了在编写组件时要记住的几件不同的事情，以保证组件与其他组件之间的友好关系。阅读这篇文章-如和构建运行良好的组件 7. 不要编写一次新的过渡效果，让它们可以重用过渡是 Vue 一个非常酷的特性。它是一种很简单的方法，可以在你的应用添加漂亮动画。但是你不想一遍又一遍的重复写相同的东西？在 Vue 中创建可重用的过渡是一篇好文章，CirstiJora 向我们展示了，如何编写一个可以重用的过渡的组件。它还展示了一些很棒的感念，来使我们的代码更加重用，也可以很好的应用到程序的其他地方。 8. 了解如何使用axios获取数据几乎没有应用程序都需要获取或上传数据，目前最流行的能帮助我们实现这一点的库就是Axios。它是可配置的，并且使处理外部数据是变得非常容易。大多数情况下，你能使用浏览器内建的fetch，但是无论如何，最后你大概率会为此写一个包装器，以便能更方便的处理一般常见情况。阅读使用 Axios 的 Vue TEST Api，学习怎样把Axios集成到你的 vue 应用中。 9. 使用vue-router处理客户端路由如果你正在做客户端路由，手工生成自己 的解决方案并不困难。匹配路由，然后在不同组件之间切换，实际上是很简单的。但是，使用vue-router会更加容易，它也是 Vue 官方的包，因此它 在 vue 中是很好 用的。当你在处理查询参数，路由参数，嵌套路由，动态路由匹配…,编写你的解决方案将变的非常的复杂。 使用vue router代替把。vue router 指南 10. 创建过滤器来重用 格式化格式化数据以显示在屏幕是很烦人的。如果你处理的是大量数字、百分百、日期、货币、名称或其他类似的东西，你可能会需要些函数来格式化这些数据。Vue 有个很棒的特性叫过滤器(filters),它的灵感来自 Angular。它们可以让轻松的封装些格式化的函数，并且使用非常干净的语法在模板中使用它们。阅读该文章如何在 Vue 中创建过滤器,这是一篇非常详细是文章，有很多关于如何编写过滤器的例子 11. 确保避免烦人的错误和警告Vue 也有很好的警告和错误消息，但是如果你一致收到它，就会很烦人。为什么不干脆完全避免它呢？ 12. 不要害怕 JSX，它是非常强大的有许多人被 JSX 吓到了，它语法怪异，很难理解如何使用它。但是，有时，尤其是在编写高可用性的组件，模板不能解决问题时。你需要充分利用 render 函数的强大力量,JSX 是最简单的方法之一。Samuel Oloruntoba 写了篇很好的介绍 JSX 的文章。在 Vue 中使用 JSX，为什么你应该关注？ 13. 弄清楚如何对鼠标悬停做出反应我已经写了一篇关于如何在 vue 中使用悬浮的深入文章，它覆盖了很多你想了解的事情： 如何实现悬浮效果 如何显示一个元素，当鼠标移入时 鼠标移入，如何动态的更新 class 如何在定制组件上实现 14. 添加 v-model 支持到自定义组件vue 为我们提交了 v-model，这是一种为我们创建双向绑定的语法糖。它对输入非常有用，因为它大大简化的对输入的处理。我们也可以添加 v-model 支持到我们的组件中，添加 v-model 支持到自定义组件一文向我们展示如何实现它。 15. 修复”this is undefined”错误或许是最常遇见的错误之一，但是现在我完全知道我哪里出差了。它与你使用的函数类型，以及如何使用它有关。如何解决”this is undefined”错误 15. 使用现成的 Css 框架 Taiwind bootstrap 16. 观察 Vue 中的嵌套数据观察者是 vue 中非常好的一个特性，除非你尝试在数组、或对象上使用它们。观察嵌套数据结构（像数组或对象）是有点棘手的。如何观察嵌套数据是一篇深入的文章，也包含一下观察者中更高级的特性。 17. 显示异步组件加载时的错误状态现在，你可能听说了关于 web 性能的内容，最简单的方式，就是将代码分割成多个更小的块，vue 对此支持时一流的。但是，如果我们在获取组件时不能提供良好的状态，用户的体验可能会受到影响，并且出错时，我们还想展示出很好的出错状态。幸运的，整合它们并不困难。vue 中显示异步组件加载、错误的状态一文，向我们展示了如何实现。 19. 清楚干净 props有的组件仅需要几个 props，但是也有的组件需要传很多很多 props，最后会变的非常混乱。但是有几种不同的方法可以解决此问题，这不仅使我们的代码更加容易查看，也更容易理解和在将来也更容易修改。将多个 props 传递给 vue 组件,这是一篇很棒的文章，概述了清理 props 的不同方法。 20. 不要混淆 prop 的计算属性 和 观察者许多人本来要使用观察者时却使用了一个计算属性，或者在观察者更合适时使用了计算属性。尽管它们看起来做了相似的事情，但实际上watchers和 computed 是完全不同的。了解更多-计算属性 和 观察者的不同 21. 当心 Vue 中常见的陷阱vue 中常见陷阱 22. 了解 props 和 data 之间的区别vue 有两种不同的方式存储变量，props 和 data，一开始可能让人很困惑，因为它们看起来做到是类似的事情，也不知道什么时候一个，什么时候用另一个。答案设计到反应性，命名空间冲突、数据流的流向。 它是一个很重要的该内容需要掌握，所有请一定要理解它，props 和 data 不同之处 一文，详细介绍在哪里使用它们，以及如何一起使用它们。 23. 在页面加载时，正确的调用方法在 web 应用中，当页面加载完后立即执行某些逻辑时非常常见的模式。通常，你正在获取数据、甚至以某种形式操作 DOM。但是，使用 vue 会有许多错误的方法。幸运的是，Vue 为我们提供了生命周期钩子，使我们能够以一种干净、简单的方式完成。如何在页面加载时调用 Vue 方法，这篇文章，深入的讨论了什么是生命周期、如何与它们挂钩。 24. 理解如何将一个函数作为 prop 传递在两种情况下，需要传递一个函数： 从子组件传递信息到父组件 以特定的方式抽象组件行为 在 React,可以任意传递函数，但是 Vue 给了我们 2 种独立的机制来解决上面 2 个问题。 事件(events) 作用域插槽(scoped slots) 如何将一个函数作为 prop 传递 25. 为什么修改 props 是一个反面模式 避免直接修改 prop，因为当父组件重新渲染时，它的值也会被覆盖修改。可以使用一个 data 或者 一个基于 props 值的 computed 属性来代替。 避免直接修改 props 的值 26. 动态的添加 class 类根据程序的状态从元素中添加或删除 class 类，是 web 应用中一个非常常见的模式。动态的添加/删除 class 类，它包含数组语法、对象语法、使用 js 表达式计算 class，然后添加动态的 class 类到指定组件。 gist token:106553587adac707d5a8731260066c80af31d875 id:73b2958ea4e29be84efb7ca2a72d3ae3","categories":[{"name":"技术总结","slug":"技术总结","permalink":"https://better-jiang.github.io/categories/%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%93/"}],"tags":[{"name":"vue","slug":"vue","permalink":"https://better-jiang.github.io/tags/vue/"},{"name":"翻译","slug":"翻译","permalink":"https://better-jiang.github.io/tags/%E7%BF%BB%E8%AF%91/"}]},{"title":"npm常用知识汇总","slug":"npm常用知识汇总","date":"2019-02-26T07:19:44.000Z","updated":"2023-02-03T12:14:22.414Z","comments":true,"path":"2019/02/26/npm常用知识汇总/","link":"","permalink":"https://better-jiang.github.io/2019/02/26/npm%E5%B8%B8%E7%94%A8%E7%9F%A5%E8%AF%86%E6%B1%87%E6%80%BB/","excerpt":"","text":"npm 是随 Node.js 一起安装的包管理工具，它的一个很重要的作用就是：将开发者从繁琐的包管理工作中解放出来，使开发者更加专注于功能的开发。 安装/更新npm 不需要单独安装，在安装 Node 时，会连带一起安装 npm。但 Node 附带的 npm 可能不是最新版本，需要运行 npm install npm@latest -g 更新到最新版本。因在国内 访问、下载 npm 包太慢，可设置淘宝镜像。 设置淘宝镜像 npm i -g cnpm --registry=https://registry.npm.taobao.org npm config get registry 查看镜像是否配置成功 更新最新版本 npm i npm@latest -g npm 使用npm initnpm init 初始化生成一个新的 package.json 。它会向用户提一系列 配置问题。使用参数 -f(force),-y(yes),则跳过提问阶段，用默认变量 直接生成 package.json npm set npm config list -l，查看 npm 配置信息 12345678910111213$ npm config list -l ; cli configs long = true metrics-registry = &quot;https://registry.npmjs.org/&quot; scope = &quot;&quot; user-agent = &quot;npm/6.4.1 node/v8.14.0 win32 x64&quot; init-author-email = &quot;&quot; init-author-name = &quot;&quot; init-author-url = &quot;&quot; init-license = &quot;ISC&quot; init-module = &quot;C:\\\\Users\\\\14335\\\\.npm-init.js&quot; init-version = &quot;1.0.0&quot; npm set 用来设置 npm 的配置信息,这些信息会存放在主用户目录的~/.npmrc文件。 12345678$ npm set init-author-email &quot;1433539514@qq.com&quot;$ npm set init-author-name &quot;better-jiang&quot;$ npm set init-license &#x27;MIT&#x27;$ cat ~/.npmrcinit-author-email=1433539514@qq.cominit-author-name=better-jianginit-license=MIT npm set 设置之后，再 npm init, package.json中作者姓名、邮件、许可就会自动写入预设的值。 npm infonpm info 命令查看模块的具体信息 123456789101112131415161718192021$ npm info vue vue@2.6.7 | MIT | deps: none | versions: 247 Reactive, component-oriented view layer for modern web interfaces. https://github.com/vuejs/vue#readme keywords: vue dist .tarball: https://registry.npmjs.org/vue/-/vue-2.6.7.tgz .shasum: 254f188e7621d2d19ee28d0c0442c6d21b53ae2d .integrity: sha512-g7ADfQ82QU+j6F/bVDioVQf2ccIMYLuR4E8ev+RsDBlmwRkhGO3HhgF4PF9vpwjdPpxyb1zzLur2nQ2oIMAMEg== .unpackedSize: 3.0 MB maintainers: - yyx990803 &lt;yyx990803@gmail.com&gt; dist-tags: beta: 2.6.0-beta.3 csp: 1.0.28-csp latest: 2.6.7 published 4 days ago by yyx990803 &lt;yyx990803@gmail.com&gt; npm searchnpm search 命令在 npm 仓库 搜索相关内容 12345678910111213141516171819202122232425262728$ npm search vueNAME | DESCRIPTION | AUTHOR | DATE | VERSION | KEYWORDSvue | Reactive,… | =yyx990803 | 2019-02-21 | 2.6.7 | vuevue-router | Official router for… | =posva… | 2018-11-23 | 3.0.2 | vue router routingvuex | state management… | =yyx990803 | 2019-01-17 | 3.1.0 |eslint-plugin-vue | Official ESLint… | =chrisvfritz… | 2019-02-18 | 5.2.2 | eslint eslint-plugin eslint-config vue vuejs rulesbootstrap-vue | BootstrapVue… | =pi0… | 2019-02-19 | 2.0.0-r… | Bootstrap Bootstrap 4 Bootstrap for Vue SSR Web Components Directives Polymer Vue VueJS Vue2 WebCompovue-i18n | Internationalization… | =kazupon | 2019-02-17 | 8.8.2 | i18n internationalization plugin vue vue.jsvuetify | Vue.js 2 Semantic… | =amajesticpota… | 2019-02-19 | 1.5.2 |vue-style-loader | Vue.js style loader… | =yyx990803 | 2018-08-13 | 4.1.2 |vue-meta | manage page meta… | =alexchopin… | 2018-12-18 | 1.5.8 | attribute google head helmet info meta seo server ssr title universal vuevue-multiselect | Multiselect… | =shentao | 2018-10-03 | 2.1.3 |vue-class-component | ES201X/TypeScript… | =ktsn… | 2019-02-19 | 7.0.1 | vue class babel typescript@vue/eslint-config-standa | eslint-config-stand… | =akryum =soda… | 2018-10-30 | 4.0.0 | vue clird | | | | |vue-chartjs | Vue.js wrapper for… | =apertureless | 2018-08-04 | 3.4.0 | ChartJs Vue Visualisation Wrapper Charts@vue/eslint-config-pretti | eslint-config-prett… | =akryum =soda… | 2018-11-12 | 4.0.1 | vue clier | | | | |vue-hot-reload-api | hot reload api for… | =yyx990803 | 2019-02-22 | 2.3.3 | vue hot reloadvue-resource | The HTTP client for… | =steffans… | 2018-05-20 | 1.5.1 | vue xhr http ajax@vue/eslint-config-airbnb | eslint-config-airbnb… | =akryum =soda… | 2018-10-30 | 4.0.0 | vue clivue-eslint-parser | The ESLint custom… | =mysticatea | 2019-02-10 | 6.0.2 |@vue/component-compiler-u | Lower level… | =akryum… | 2019-02-21 | 2.6.0 | vue sfc component compilertils | | | | |vue-property-decorator | property decorators… | =kaorun343 | 2019-01-11 | 7.3.0 | vue typescript decorator npm list npm list 以树形结构列出当前项目已安装的所有模块，以及它们的依赖 npm list -global, 列出全局安装的模块 npm list vue, 列出指定模块 npm list -prod, dependencies中的模块 依赖树 npm list -dev, devDependencies的模块 依赖树 npm install 本地 / 全局 安装默认情况下，npm会从 http://npmjs.org 搜索或下载包，并将包安装到当前目录的node_modules子目录下。 本地安装，是指将一个模块下载到当前目录的node_modules子目录，然后只有在项目目录中，才能调用该模块 全局安装，一般来讲，只适用于工具模块，比如webpack，gulp，eslint。 | 模式 | require 引入使用 | 注册PATH || ——– | —————- | ——– | || 本地模式 | 是 | 否 || 全局模式 | 否 | 是 |注意⚠️：安装之前，npm install会先检查，node_modules目录是否已经存在指定模块，如果存在，就不重新安装了，即使远程仓库已经有一个新版本。如果希望，不过是否安装过，都要强制重新安装，可是有-f或--force参数 1$ npm install &lt;package name&gt; --force 安装不同版本12345$ npm install vue-router@2.8.1 // 2.8.1 版本 $ npm install vue-router@latest // 最新版本$ npm install vue-router@^2.7.0 // 2.7.0及以后的版本 版本范围 version， 必须是准确版本号 &gt;version, 大于指定版本号 &gt;=version,大于等于版本号 &lt;version, 小于版本号 &lt;=version, 小于等于版本号 ~version, 约等于办本号 ^version,最小的版本号，向后兼容 1.2.X, 1.2这个大版本，1.2.0,2.2.4,etc, but no 1.3.0 version1 - version2, &gt;=version1 &lt;=version2 依赖类型（dependencies， devDependencies） dependencies 依赖，是指该项目所依赖的js模块，当他人引用此包时，该依赖下的模块也会被下载 devDependencies 依赖，只是在开发环境中需要用到的，在他人引用时不会被下载。 npm install,默认会下载安装dependencies和devDependencies中的所有模块，如果使用--production 参数，只会下载安装 dependencies下的模块npm runnpm 不仅可以用于模块管理，还可以执行脚本。package.json文件中有一个scripts字段，可用于指定脚本命令，供npm直接调用。 scripts， 就是一些脚本代码，可以通过 npm run script-key来调用， npm run 是其简写。 npm run，不加参数，直接运行，会列出package.json中所有可以执行的脚本命令。 运行bash脚本在写scripts属性中的命令，也可以在node_modules/.bin目录中直接写成bash脚本 npm binnpm bin命令显示当前项目的，Node模块的可执行脚本所在的目录（即.bin目录）npm rootnpm root [-g],查看【全局的】包的安装路径常用命令123456789npm help // 查看npm 命令列表npm -l // 查看 npm命令的简单用法npm version // 查看npm node 等版本npm help [command] // 查看某命令 详细用法npm list --depth=0 [-g] // 查看[全局]本地安装的包npm view &lt;package name&gt; // 查看指定包的信息npm search [search key] // 搜索相关的npm包npm update [-g] [package name] // 升级当前项目指定模块npm config list // 查看配置信息","categories":[{"name":"技术总结","slug":"技术总结","permalink":"https://better-jiang.github.io/categories/%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%93/"}],"tags":[{"name":"npm","slug":"npm","permalink":"https://better-jiang.github.io/tags/npm/"}]},{"title":"git基础(9)-Git常用命令清单","slug":"git基础-9-Git常用命令清单","date":"2019-02-25T07:02:06.000Z","updated":"2023-02-03T12:14:22.414Z","comments":true,"path":"2019/02/25/git基础-9-Git常用命令清单/","link":"","permalink":"https://better-jiang.github.io/2019/02/25/git%E5%9F%BA%E7%A1%80-9-Git%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E6%B8%85%E5%8D%95/","excerpt":"","text":"日常工作中，如果能遵循工作流程，提交代码仔细、规范，其实仅需要 6 个常用的 Git 命令。如图： 新建代码库 git init，在当前目录新建一个 Git 代码库 git init [project-name],新建一个目录，并将其初始化为 Git 代码库 git clone [url]，克隆一个远程代码库 配置Git 的配置文件.gitconfig，在用户主目录下（全局配置 –global），在项目目录下（项目配置 –local），在安装目录下（系统配置 –system） git config --list，显示当前 Git 配置 git config -e [--global],编辑 Git 配置文件 git config [--global] user.name &quot;[name]&quot;,设置用户信息 增加/删除文件到暂存区 git add [file1] [file2] ...，添加指定文件到暂存区 git add .,添加当前目录的所有文件到暂存区 git rm [file1] [file2] ...，删除工作区文件，并将这次删除放入暂存区 git rm --cached [file]，停止追踪指定文件，但该文件会保留在工作区 git mv [rile-original] [file-renamed],改名文件，并将这个改名放入暂存区 代码提交 git commit -m [message],提交暂存区到本地仓库 git commit [file2] [file2] ... -m [message]，提交暂存区指定文件到本地仓库 git commit -a,提交工作区自上次 commit 之后的变化，直接到本地仓库 git commit -v,提交时显示 diff 信息 git commit --amend -m [message]，使用一次新的 commit，替代上一次提交 分支 git branch, 列出所有本地分支 git branch -r, 列出所有远程分支 git branch -a,列出所有本地和远程分支 git branch [branch-name],新建一个分支，但依然停留在当前分支 git checkout [commit] -b [branch-name],从提交历史检查一个新的分支，相当于恢复误删的分支 git checkout -b [branch-name],新建一个分支，并切换到该分支 git branch [branch] [commit],新建一个分支，指向指定的 commit git branch --track [branch] [remote-branch],建立一个新分支，与指定的远程分支建立追踪关系 git branch --set-upstream-to [origin/branch],修改追踪仓库，在现有分支与指定的远程分支建立追踪关系 git chekout [branch],切换到指定分支，并更新工作区 git merge [branch],合并指定分支到当前分支 git cherry-pick [commit],选择一个 commit，合并进当前分支 git branch -d [branch-name]，删除本地分支 git push origin --delete [branch-name],删除指定远端分支123$ git push GitTest --delete branches To https://github.com/Better-Jiang/GitTest.git - [deleted] branches 标签 git tag,列出所有标签 git tag -a [tag] -m [message],新建一个 附注类型的 tag，在当前 commit git tag [tag] [commit]，新建一个 tag，在指定 commit git tag -d [tag],删除指定 tag git show [tag],查看 tag 信息 git push [remote] [tag], 推送指定 tag git push [remote] --tags,推送所有 tag git push [remote] :refs/tags/[tag],远端删除指定 tag 123456$ git push GitTest :refs/tags/v1.1 remote: warning: Deleting a non-existent ref. To https://github.com/Better-Jiang/GitTest.git - [deleted] v1.1 查看信息 git status,显示文件状态，是否有变更文件 git log，当前分支的版本历史 git log --stat,显示 commit 历史，以及每次 commit 发生变更的文件 git log --follow [file],git whatchanged [file]显示某个文件的版本历史，包括文件改名 git log -p [file],显示指定文件相关的每一次 diff git blame [file],显示指定文件什么人，在什么时间修改过 git diff，显示暂存区和工作区的差异 git diff --cached,暂存区和上一个 commit 的差异 git diff HEAD,暂存区和当前分支最新 commit 之间的差异 git diff [commit] [commit],两次提交之间的差异 git show [commit], 显示某次提交的元数据和内容变化 git show --name-only [commit],显示某次提交发生变化的文件 git show [commit]:[filename],显示某次提交时，某个文件的内容 git reflog，显示当前分支的最仅几次提交 远程同步 git fetch [remote],下载远程仓库的所有变动 git remote -v,显示所有远程仓库 git remote show [remote],显示某个远程仓库的信息 git remote add [shortname] [url],增加一个新的远程仓库，并命名 git pull &lt;y远程主机名&gt; &lt;远程分支名&gt;:&lt;本地分支名&gt;,git pull origin master:testing,将远程主机 origin 的 master 分支拉取过来，与本地的 testing 分支合并。冒号：省略，表示与当前分支进行合并。 git pull [remote] [branch],取回远程仓库的变化，并于当前本地分支合并 git push &lt;远程主机名&gt; &lt;本地分支名&gt;:&lt;远程分支名&gt;，将本地分支上传到远程分支。 git push [remote] [local-branch],上传本地指定分支，到远程仓库的同名分支,如果没有则创建新分支 git push [remote]: refs/for/master，如果省略了本地分支，则表示删除指定的远程分支，因为这等同于推送一个空的本地分支到远程分支。等同于git push [remote] --delete [branch] refs/for，表示我们提交到服务器之后需要经过 code review 之后才能进行 merge 如果当前分支与远程分支存在追踪关系，则本地分支和远程分支都可以省略，git push origin，将当前分支推送到 origin 主机的对应分支 git push [remote] --force,强行推送当前分支到远程仓库，即使有冲突 git push，如果当前分支只有一个远程分支，则可以省略主机名。 撤销 git checkout [file],恢复暂存区的指定文件到工作区 git checkout [commit] [file],恢复某个指定 commit 的指定文件到工作区 git checkout .,恢复上一个 commit 的所有文件到工作区 git reset [file],重置暂存区的指定文件，与上一次 commit 保持一致，但工作区不变 git reset --hard,重置暂存区与工作区内容，与上一次 commit 保持一致 git reset [commit],重置当前分支指针为指定 commit，同时重置暂存区，但工作区保持不变 git revert [commit]，新建一个 commit,撤销指定 commit 的所有变化，并应用到当前分支 其他 git archive,生成一个可供发布的压缩包 git stash,备份当前工作区的内容 git stash pop,从 Git 栈中，读取最近一次保存的内容，恢复工作区相关内容 git stash list,显示 Git 栈内所有备份 git stash clear，清空 Git 栈","categories":[{"name":"技术总结","slug":"技术总结","permalink":"https://better-jiang.github.io/categories/%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%93/"}],"tags":[{"name":"git","slug":"git","permalink":"https://better-jiang.github.io/tags/git/"}]},{"title":"git基础(8)-重置揭秘","slug":"git基础-8-重置揭秘","date":"2019-02-25T01:19:05.000Z","updated":"2023-02-03T12:14:22.414Z","comments":true,"path":"2019/02/25/git基础-8-重置揭秘/","link":"","permalink":"https://better-jiang.github.io/2019/02/25/git%E5%9F%BA%E7%A1%80-8-%E9%87%8D%E7%BD%AE%E6%8F%AD%E7%A7%98/","excerpt":"","text":"修改最后一次提交 仅修改提交信息只想修改最近一次提交的提交信息,使用 git commit --amend 命令，进入文本编辑器（vim）,里面包含最近一条提交信息，可修改。保存并关闭后，替换最近一条提交信息 添加后修改文件更改提交快照 修改文件后运行git add或git rm一个已经追踪的文件 运行git commit --amend使当前暂存区做为新的提交快照 重置揭秘理解reset 和 checkout的最简单的方法，就是用 Git 思维框架（可将其作为内容管理器），来管理并操作三棵不同的树。树：实际上是“文件的集合”,而不是指数据结构。 三棵树 树 说明 HEAD 上一次提交的快照，下一次提交的父结点 Index 预期的下一次提交的快照 Working Directory 实际的文件，可编辑。类似沙盒 HEADHEAD是当前分支引用的指针，它总是指向该分支上的最后一次提交。这表示 HEAD 将是下次提交的父结点。理解 HEAD 最简单方式，将它看做你的上一次提交快照。查看快照实际的目录列表 git cat-file -p [commitID] 查看提交对象 123456$ git cat-file -p HEAD tree 3ed9fb9aba37ab6c9af1484fdec8f9edb5bd4e0b parent 331a960f747598a4b2119587d49a35870db888c5 author liuzhenjiang &lt;1433539514@qq.com&gt; 1550824953 +0800 committer liuzhenjiang &lt;1433539514@qq.com&gt; 1551059104 +0800 change the commit and file git ls-tree -r [commitID] 查看提交时的快照的文件 123$ git ls-tree -r HEAD 100644 blob abe3a110e1ebb15baea3ba02acda8deeb28437bb a.txt 索引索引是预期的下一次提交，也可引用为 Git 的暂存区域,也就是运行git commit 时 Git 看起来的样子。Git 将 上一次检出到工作目录中的所有文件填充到索引区，之后会将其中一些文件替换为新版本，git add 后，会替换暂存区内文件，并有新的 SHA-1 校验和，接着通过git commit 将它们转换为树来作为新的提交。git ls-files -s ，显示当前索引的样子 12$ git ls-tree -r HEAD 100644 blob d917a4f56af780cc5033241e4c274c2386a0f9be a.txt 工作目录HEAD，Index 两棵树以一种高效但不直观的方式，将它们的内容存储在.git文件夹中，工作目录会将它们解包为实际的文件，可编辑，可把其当做沙盒。 工作流程Git 就是通过操作这三棵树来以连续的状态记录项目的快照。 具体流程说明： 新目录，有一个文件 file.txt V1 版本，git init，创建一个 Git 仓库，其中 HEAD 引用指向未创建的分支（master 还不存在） 提交该文件，git add ，来获取目录中的内容，并将其复制到索引 git commit，取得索引中的内容并将其保存为一个永久的快照，然后创建一个指向该快照的提交对象，最后更新master来指向本次提交。 修改然后提交，也将经历相同的过程： 工作目录修改文件 ，V2 版本.git status，显示 Change not staged for commit，并被标记为红色，因为，该文件在索引和工作目录中存在不同。 git add 将 V2 版本文件，暂存到索引中。git status,显示Changes to be committed，并标记文件绿色，因为，预期的下一次提交与上一次提交存在不同。 git commit，把索引中的内容保存为提交对象所指向的快照，更新master来指向本次提交。 切换分支，克隆过程 检出一个分支，修改 HEAD 指向新的分支引用 把分支最后一次提交的快照，填充到索引 将索引中的内容，解包复制到工作目录中 重置作用（reset）为了演示例子，假设我们再次修改了file.txt文件并第三次提交。现在提交历史样子： 其实reset只做了三个基本的操作，操作那三颗树（HEAD，Index，Work Directory） 第 1 步：移动 HEAD （–soft）reset做到第一件事：移动 HEAD 的指向，而不是改变 HEAD 自身（checkot,会改变 HEAD）。reset,移动 HEAD 指向的分支；checkout，移动 HEAD 自身，让自身指向某分支。例如：如果HEAD设置为master分支，git reset 9e5e64a 将会使master指向9e5e64a. git resset --soft, 仅使移动 HEAD，它的本质是：撤销上一次git commit命令。当在运行git commit时，Git 会创建一个新的提交，并移动 HEAD 所指向的分支，使分支指向该次提交。当git reset HEAD~(重置回 HEAD 的父结点)，其实就是把分支移动回上一次提交的位置，而不会改变索引和工作目录。然后更新索引并再次git commit，来完成git commit --amend所要做的事情。 第 2 步：更新索引(–mixed)git status ，以绿色，标记HEAD和索引之间的区别。接下来，reset会使用HEAD指向的当前快照的内容来更新索引。 如果指定--mixed选项，reset将会停在着，这也是默认行为，如果没有指定任何选项（git rest HEAD~ 等同于 git reset --mixed HEAD~）git reset --mixed,撤销上一次提交，取消暂存所有的东西，即，回滚到所有git add 和git commit命令执行之前 第 3 步：更新工作目录（–hard）使用--hard选项， reset会让工作目录内容和索引一样。即撤销了最后的提交、 git add 和git commit命令，以及工作目录中的所有工作。 检查（checkout）不带路径 git checkout [branch] 与 git reset --hard [branch]非常相似，更新所有三棵树，使其看起来像[branch]。区别： checkout对工作目录是安全的，它会通过检查（并试着简单合并一下）来确保不会将已经更改的文件弄丢。reset --hard，则不做检查，直接全面的替换所有东西 reset会移动 HEAD分支的指向，而checkout只会移动 HEAD 自身来指向另一个分支。 带路径checout file和reset一样不会移动 HEAD 自身。它会git reset --hard [branch] file那样：用该次提交中的那个文件来更新索引，但是也会覆盖工作目录中对应的文件。 总结下面是速查表，列出了命令对树的影响。HEAD列中的&quot;REF&quot;表示该命令移动了 HEAD 指向的分支引用。&quot;HEAD&quot;表示只移动了 HEAD 自身。 WD Safe?列，表示对工作目录是否安全？ command HEAD Index Workdir WD Safe? Commit Level reset –soft [commit] REF NO NO YES reset [commit] REF YES NO YES reset –hard [commit] REF YES YES NO checkout [commit] HEAD YES YES YES File Level reset [commit] [file] NO YES NO YES checkout [commit] [file] NO YES YES NO git revertgit revert [commit]，会生成一个撤销了【commit】引入的修改的新的提交，然后引用到当前分支上。","categories":[{"name":"技术总结","slug":"技术总结","permalink":"https://better-jiang.github.io/categories/%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%93/"}],"tags":[{"name":"git","slug":"git","permalink":"https://better-jiang.github.io/tags/git/"}]},{"title":"git基础(8)-分支开发本地工作流(Branching Workflows)","slug":"git基础-8-分支开发本地工作流-Branching-Workflows","date":"2019-02-21T08:41:02.000Z","updated":"2023-02-03T12:14:22.414Z","comments":true,"path":"2019/02/21/git基础-8-分支开发本地工作流-Branching-Workflows/","link":"","permalink":"https://better-jiang.github.io/2019/02/21/git%E5%9F%BA%E7%A1%80-8-%E5%88%86%E6%94%AF%E5%BC%80%E5%8F%91%E6%9C%AC%E5%9C%B0%E5%B7%A5%E4%BD%9C%E6%B5%81-Branching-Workflows/","excerpt":"","text":"由于分支的便捷，用于开发中，渐渐衍生出了基于用分支进行开发的工作模式。最典型工作流： Git Flow GitHub Flow GitLab Flow 但是，此文不会介绍，因为现在小编根本不懂，对此也很迷。 如想简单了解，请查看 Git 工作流程简介本文，主要讲下 长期分支、特性分支、远程分支 长期分支根据项目开发的不同阶段，同时有多个开发的分支，且是长期的，一般不会删除。再定期地把某些特性分支合并入其他分支。典型方式: 根据不同层次的稳定性，建立分支 master 分支:保留完全稳定的代码，已经发布 release 分支： 要发布的分支，发布且经过一段时间正式运行稳定后，合并入 master 分支 test 分支: 测试的分支，经过测试后，合并入 release 分支 develop 分支：开发分支,开发人员测试后，合并入 test 分支 这么做使分支具有不同级别的稳定性，当分支具有一定程度的稳定性后，再把它们合并入具有更改级别稳定性的分支中。 特性分支当工作被分散到不同的流水线中时，需要快速并且完整的在不同流水线中切换。而使用特性短期分支，针对不同流水线中的工作创建与之相关的分支，在不同分支间切换 来实现单一特性的工作。在特性分支修改完成后，再合并，而不用在乎它们建立的顺序或工作进度。 远程分支 分支(branch): z 指向某个提交对象的可变指针 跟踪分支(tracking brnch): 本地的分支，用户可写 远程跟踪分支(remote tracking branch): 远程分支状态的引用（指向远程分支的指针），用户只读，本地不能移动,在网络通信操作中，会自动移动。以 [remote]/[branch] 形式命名 git clone 过程 克隆前【远程仓库】的状态： 远程仓库master分支指向C2的 commit 将数据克隆到本地之后 首先 生成一个 origin/master 的指针指向最新的提交 C2.这个 origin/master 就是远程跟踪分支，用户只读 然后 生产一个和 orign 的 master 分支指向同一提交 C2 的本地 master 分支. git push 过程 克隆后，修改本地文件并提交。此时 本地 master 分支指向 C3 git push 对远程和本地都做成修改 修改远程的 master 分支 指向 至 C3 修改本地的 远程跟踪分支 orign/master 指向 C3 git fetch + git merge 过程git fetch从远端仓库抓取本地没有的数据，并更新本地数据库，移动 origin/master 指针指向新的、更新后的位置。但不会修改本地文件， 需要显式的合并 fetch 之前，远程 处于 C4, 本地处于 C3 fetch 之后，本地的 origin/master 分支指向了最新的 C4 通过 git merge origin/master 合并本地分支 ,merge 之后，本地 master 分支指向 C4. git pull 过程git pull = git fetch + git merge，本地仓库更新 origin/master 分支，将其指向 C4，再将其，合并入本地 master 分支,使得本地 master 分支也指向 C4 git pull 之前，远程在 C4， 本地在 C3 git pull 之后， 本地仓库更新了 origin/master，将其指向 C4;然后更新本地 master 分支，将其指向 C4","categories":[{"name":"技术总结","slug":"技术总结","permalink":"https://better-jiang.github.io/categories/%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%93/"}],"tags":[{"name":"git","slug":"git","permalink":"https://better-jiang.github.io/tags/git/"}]},{"title":"git基础(7)-分支(branch)","slug":"git基础-7-分支-branch","date":"2019-02-21T06:28:26.000Z","updated":"2023-02-03T12:14:22.413Z","comments":true,"path":"2019/02/21/git基础-7-分支-branch/","link":"","permalink":"https://better-jiang.github.io/2019/02/21/git%E5%9F%BA%E7%A1%80-7-%E5%88%86%E6%94%AF-branch/","excerpt":"","text":"Git 分支本质是指向提交对象(commit object)的可变指针,默认是指向最后那个提交对象，每次提交后，都会自动向前移动。HEAD是特殊指针，指向当前所在的本地分支（可理解为当前分支的别称）。 Git 是如何保存数据的？ Git 保存的不是文件的一系列或变更集或者差异，而是一系列不同时刻的文件快照。 每次提交时,Git 会保存一个提交对象。该对象包含： 一个指向暂存内容快照的指针（树对象） 作者姓名、邮箱、提交解决信息 指向它的父对象（上一次提交对象）的指针 首次提交产生的提交对象没有父对象 其他普通提交操作产生的提交对象有一个父对象 由多个分支合并产生的提交对象有多个父对象 例子 假设有一个工作目录，包含三个将要被暂存、提交的文件。 暂存操作： 为每一个文件计算校验和 把当前版本的文件快照保存到 Git 仓库中（使用 blob 对象来保存文件快照） 将校验和加入到暂存区域 等待提交 提交操作: Git 先计算每一个子目录的校验和 在 Git 仓库中把这些校验和保存为树对象 Git 创建一个提交对象 此时，Git 仓库： 3 个 blob 对象（保存文件快照） 1 个树对象（记录着目录结构和 blob 对象索引） 1 个提交对象 (包含 树对象的指针，和所有提交信息) 修改后再次提交，此次产生的提交对象会包含一个指向上次提交对象（父对象）的指针 Git 分支Git 分支，其本质仅仅时指向其中一个提交对象的可变指针。默认分支名字是 master。 A branch in Git is simply a lightweight movable pointer to one of these commits. 创建分支创建分支只是创建了一个可以移动的新的指针。名为HEAD的特殊指针，指向当前所在的本地分支 git branch &lt;branchname&gt;： 创建一个分支 git branch -b &lt;branchname&gt;： 创建分支，并切换，创建：git branch &lt;branchname&gt;, 切换：git checkout &lt;branchname&gt; 切换分支git checkout命令，切换分支，实际上是改变 HEAD 的指向,同时将工作目录恢复到该分支所指向的快照内容（最后一次提交时的样子）。git checkout testing，切换到 testing 分支，此时 HEAD 指向 testing 分支 在testing分支，修改再提交一次，testing分支向前移动,HEAD也随着提交自动向前移动，但master分支保持不动。 合并分支git merge命令，合并指定分支到当前分支。 Fast-forward, “快进模式”,由于当前分支所指向的提交是并入分支的直接上游,所有 Git 只是简单的将指针向前移动。 通俗来讲：当试图合并两个分支时，如果顺着一个分支走下去能够到达另一个分支，那么在合并时，只会简单的将指针向前推进。 &#39;recursive&#39; strategy,在合并时，需要递归的查找两个分支的分叉点。 Git 会使用两个分支的末端的快照（C4 、C5）和这两个分支的共同祖先(C2)，做一个简单的三方合并。再将结果做一个新的快照并自动创建一个新的提交（C6）指向它。 分支合并冲突如果在两个不同分支上，对同一个文件的同一个部分进行了不同的修改，分支合并时就会产生合并冲突。 此时，Git 做了合并，但没有自动创建一个新的合并提交。,需要解决冲突，在使用git add命令来将其标记为冲突已解决，然后git commit完成提交。具体步骤： git status 查看因 包含合并冲突 而处于未合并(unmerged)状态的文件 123456789$ git statusOn branch masterYou have unmerged paths.(fix conflicts and run &quot;git commit&quot;)Unmerged paths:(use &quot;git add &lt;file&gt;...&quot; to mark resolution)both modified: index.htmlno changes added to commit (use &quot;git add&quot; and/or &quot;git commit -a&quot;) 未合并状态的文件中都会加入标准的冲突解决标记，需要打开文件，手动修改文件，解决冲突。 1234567&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD:index.html&lt;div id=&quot;footer&quot;&gt;contact : email.support@github.com&lt;/div&gt;=======&lt;div id=&quot;footer&quot;&gt;please contact us at support@github.com&lt;/div&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; iss53:index.html 解决了所有文件冲突后， git add将每个文件标记为 冲突已解决。注意: 一旦暂存这些冲突文件，Git 就会将它们标记为冲突已解决。所以最后是修改一个文件，暂存一个文件，以免漏掉。 git commit，提交合并。 分支管理 查看分支 git branch 不加任何参数，列出所有分支，* 代表当前分支（当前 HEAD 指针所指向的分支） 1234$ git branch* develop master release git branch -v,每个分支的最后一次提交 1234$ git branch -v* develop b1e18237 【预警查询】 分页滑动，触发页面样式更新函数，屏幕自适应 master 3ea94fa9 Merge branch &#x27;release&#x27; into &#x27;master&#x27; release a98f6667 Merge branch &#x27;develop&#x27; into &#x27;release&#x27; git branch --merged/--no-merged,过滤分支列表中已经合并或尚未合并到当前分支的分支。 123$ git branch --merged * develop release 在列表中没有*号的分支，通常是已经将它们的分支合并到另一个分支，可已使用git branch -d 删除的。","categories":[{"name":"技术总结","slug":"技术总结","permalink":"https://better-jiang.github.io/categories/%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%93/"}],"tags":[{"name":"git","slug":"git","permalink":"https://better-jiang.github.io/tags/git/"}]},{"title":"git基础(6)-标签(tag)","slug":"git基础-6-标签-tag","date":"2019-02-21T01:37:46.000Z","updated":"2023-02-03T12:14:22.413Z","comments":true,"path":"2019/02/21/git基础-6-标签-tag/","link":"","permalink":"https://better-jiang.github.io/2019/02/21/git%E5%9F%BA%E7%A1%80-6-%E6%A0%87%E7%AD%BE-tag/","excerpt":"","text":"给历史上某一次提交打上标签，以示该次提交的重要性，方便日后的查看、回溯。比如使用此功能来标记发布节点（V1.0.0） tag 类型 轻量标签(lightweight): 其实是一个独立的分支，且不可改变,是一个特定提交的引用。 附注标签(annotated): 是存储在 Git 数据库中的一个完整对象。它有自身的校验和信息，包含标签名字、标签说明，标签本身也允许使用 GPG 来签署和验证。 创建 tag git tag -a v1.0 -m &quot;release 1.0&quot;, 创建一个附注标签，并且添加了附注信息”release 1.0” git tag -a v0.8 &lt;commitID&gt; : 给过去的提交大标签，在命令末尾指定提交的校验和（或部分校验和 、7 位） 查看 tag git tag : 列出所有的标签 git show &lt;tagname&gt; : 查看标签信息和对应的提交信息 删除 tag git tag -d &lt;tagname&gt; : 删除 本地仓库上的标签 共享/推送 tag默认情况，git push 不会推送 标签到远程仓库服务器上。需要显式地推送标签到共享服务器上。类似共享远程分支,执行 git push origin [tagname] 命令 123456789## 推送V1.1Tag 到 GitTest远程仓库上$ git push GitTest V1.1Enumerating objects: 1, done.Counting objects: 100% (1/1), done.Writing objects: 100% (1/1), 161 bytes | 53.00 KiB/s, done.Total 1 (delta 0), reused 0 (delta 0)To https://github.com/Better-Jiang/GitTest.git* [new tag] V1.1 -&gt; V1.1 使用带--tags 选项，可一次性推送全部标签。git push GitTest --tags","categories":[{"name":"技术总结","slug":"技术总结","permalink":"https://better-jiang.github.io/categories/%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%93/"}],"tags":[{"name":"git","slug":"git","permalink":"https://better-jiang.github.io/tags/git/"}]},{"title":"git基础(5)-远程仓库","slug":"git基础-5-远程仓库","date":"2019-02-20T08:57:40.000Z","updated":"2023-02-03T12:14:22.413Z","comments":true,"path":"2019/02/20/git基础-5-远程仓库/","link":"","permalink":"https://better-jiang.github.io/2019/02/20/git%E5%9F%BA%E7%A1%80-5-%E8%BF%9C%E7%A8%8B%E4%BB%93%E5%BA%93/","excerpt":"","text":"远程仓库是指托管在 Internet，或其他网络中的项目的版本库。一个人可以有多个远程仓库,可设置读 、写权限。在与他人协作涉及到管理远程 仓库、推送、拉取数据。 查看远程仓库 git remotegit remote 列出所指定的每一个远程服务器的名称。 git clone克隆的 仓库服务器 默认名称origin。选项-v 会 显示需要读写 远程仓库所使用的 Git 保存的简写名称和对应 URL。 1234$ git remote -vGitTest https://github.com/Better-Jiang/GitTest.git (fetch)GitTest https://github.com/Better-Jiang/GitTest.git (push) git remote show GitTest，查看某个远程 仓库的更多信息. 列出远程仓库 URL 与跟踪分支信息. 告诉正处于 master 分支 运行 git pull，抓取所有的 远程引用,然后将远程 master 分支合并到本地 master 分支 12345678910111213$ git remote show GitTest* remote GitTestFetch URL: https://github.com/Better-Jiang/GitTest.gitPush URL: https://github.com/Better-Jiang/GitTest.gitHEAD branch: masterRemote branches: branches tracked master trackedLocal branch configured for &#x27;git pull&#x27;: master merges with remote masterLocal ref configured for &#x27;git push&#x27;: master pushes to master (up to date) 添加远程仓库 git remote add &lt;shortaame&gt; &lt;url&gt;git remorte add &lt;shortname&gt; &lt;url&gt;,添加一个新的远程仓库，同时 指定一个可引用的简写.以后就可以在命令中使用该shortname 来代替整个 URL。例如 git fetch GitTest :拉取远程仓库 GitTest 的数据 git push GitTest master：将本地 master 分支推送到 GitTest 远程仓库 从远程仓库抓取与拉取 git fetch [remote-name]git fetch [remote-name],此命令访问远程服务器，拉取新 数据到 本地仓库，但不会自动合并或修改当前工作区，需要手动将其合入工作区.git clone会自动设置本地 master 分支跟踪 所克隆的远程仓库的 master 分支。git pull通常会从最初克隆的服务器上抓取数据并自动尝试合并到当前所在的分支。 执行git fetch命令后，此时比较本地仓库与远端仓库 更新本地的远端分支 git fetch &lt;shortname&gt; 12345678$ git fetchremote: Enumerating objects: 8, done.remote: Counting objects: 100% (8/8), done.remote: Compressing objects: 100% (4/4), done.remote: Total 6 (delta 2), reused 0 (delta 0), pack-reused 0Unpacking objects: 100% (6/6), done.From https://github.com/Better-Jiang/GitTest d4b6ca5..22ab9e0 master -&gt; GitTest/master 本地与远程的差集 (显示远程有，而本地没有的 commit 提交信息) git log master ..GitTest/master 123456789101112$ git log master ..GitTest/mastercommit 22ab9e044bc87a6e245bba775ae2dffd6616721a (GitTest/master)Author: 江 &lt;1433539514@qq.com&gt;Date: Wed Feb 20 19:13:18 2019 +0800 Update c.mdcommit 9451835f337bc5beb3106b7326c8b9522b4208c1Author: 江 &lt;1433539514@qq.com&gt;Date: Wed Feb 20 19:12:51 2019 +0800 Create d.md 统计文件改动 git diff &lt;local branch&gt; &lt;remote&gt;/&lt;remote branch&gt; 12345$ git diff --stat master GitTest/master c.md | 3 +-- d.md | 1 + 2 files changed, 2 insertions(+), 2 deletions(-) 推送到远程仓库 git push [remote-name] [branch-name]git push GitTest master，将本地的 master 分支推送到 GitTest 服务器上 远程仓库 移除 与 重命名 重命名: git remote rename &lt;old-remote-name&gt; &lt;new-remote-name&gt; 移除: git remote rm &lt;old-remote-name&gt;","categories":[{"name":"技术总结","slug":"技术总结","permalink":"https://better-jiang.github.io/categories/%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%93/"}],"tags":[{"name":"git","slug":"git","permalink":"https://better-jiang.github.io/tags/git/"}]},{"title":"git基础(4)-撤销与回滚","slug":"git基础-4-撤销与回滚","date":"2019-02-20T06:58:01.000Z","updated":"2023-02-03T12:14:22.413Z","comments":true,"path":"2019/02/20/git基础-4-撤销与回滚/","link":"","permalink":"https://better-jiang.github.io/2019/02/20/git%E5%9F%BA%E7%A1%80-4-%E6%92%A4%E9%94%80%E4%B8%8E%E5%9B%9E%E6%BB%9A/","excerpt":"","text":"在任何一个阶段，都可能想要撤销某些操作，来取消对某文件的修改。注意，有些操作是是不可逆的. 检查修改 git diff 检查工作区和暂存区之间的差异 git diff --cached 检查暂存区和本地仓库之间的差异 git diff master origin/develop 检查本地仓库与远程仓库 develop 分支之间的差异 重新提交 git commit --amend有时提交完了发现漏掉几个文件没添加、或者提交信息写错，需要重新提交. git commit --amend 会将暂存区的文件提交,并覆盖原来的提交信息 取消暂存的文件 git reset HEAD &lt;file&gt;...例如: 修改了两个文件并想将它们做为 2 次独立的修改提交,但却意外地输入 git add * 暂存了它们两个,如何取消暂存中的文件？ 正如 git status命令提示的 使用git reset HEAD &lt;file&gt; ... 来撤销暂存 1234567$ git status On branch master Changes to be committed: (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage) new file: a.md new file: b.md git reset HEAD a.md 1234567891011121314$ git reset HEAD a.md$ git statusOn branch masterChanges to be committed: (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage) new file: b.mdUntracked files: (use &quot;git add &lt;file&gt;...&quot; to include in what will be committed) a.md 撤销对文件的修改 git checkout -- &lt;file&gt;...撤销修改，将其还原成上次提交时的样子.但git checkout -- &lt;file&gt;是一个危险命令，它只是拷贝了一个文件来覆盖原文件，原文件所做的修改都会消失。 不同场景下的撤销（未 push 到远程仓库还原操作） 文件被修改，未执行git add 123git checkout &lt;fileName&gt;git checkout . 同时对多个文件执行git add ,但本次提交只想提交其中部分文件 12345$ git add *$ git status# 取消部分暂存文件$ git reset HEAD &lt;fileName&gt; 文件执行了 git add， 但想撤销对其中部分文件的修改 12345# 取消暂存$ git reset HEAD &lt;fileName&gt;# 取消修改$ git checkout &lt;fileName&gt; 已经 git commit， 想再次修改，但不想产生新的 commit 记录 123# 修改的最后一次暂存$ git add &lt;fileName&gt;$ git commit --amend -m &quot;comment&quot; 已经在本地多次提交记录git commit,但想撤销到其中某次 Commit 12git reset [--hard|soft|mixed|merge|keep] [commit|HEAD] 不同场景下的回滚（已 push 到远程仓库的还原操作）回滚有风险，需要提前做好备份，通知其他团队成员 撤销指定文件到指定版本 12345# 查看指定文件的历史版本$ git log &lt;fileName&gt;# 回滚到指定commitID$ git chekcout &lt;commitID&gt; &lt;fileName&gt;","categories":[{"name":"技术总结","slug":"技术总结","permalink":"https://better-jiang.github.io/categories/%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%93/"}],"tags":[{"name":"git","slug":"git","permalink":"https://better-jiang.github.io/tags/git/"}]},{"title":"git基础(3)-查看提交历史","slug":"git基础-3-查看提交历史","date":"2019-02-20T02:19:13.000Z","updated":"2023-02-03T12:14:22.413Z","comments":true,"path":"2019/02/20/git基础-3-查看提交历史/","link":"","permalink":"https://better-jiang.github.io/2019/02/20/git%E5%9F%BA%E7%A1%80-3-%E6%9F%A5%E7%9C%8B%E6%8F%90%E4%BA%A4%E5%8E%86%E5%8F%B2/","excerpt":"","text":"git log 命令查看提交历史，通过带不同参数来控制显示的内容和方式。 不用任何参数 git log 会按 提交时间（最晚在前）显示所有提交记录，包括 SHA-1 校验和、作者名字 、电子邮件地址、提交时间、提交说明。 12345678910111213$ git logcommit ca82a6dff817ec66f44342007202690a93763949Author: Scott Chacon &lt;schacon@gee-mail.com&gt;Date: Mon Mar 17 21:52:11 2008 -0700changed the version numbercommit 085bb3bcb608e1e8451d4b2432f8ecbe6306e7e7Author: Scott Chacon &lt;schacon@gee-mail.com&gt;Date: Sat Mar 15 16:40:33 2008 -0700removed unnecessary testcommit a11bef06a3f659402fe7563abf99ad00de2209e6Author: Scott Chacon &lt;schacon@gee-mail.com&gt;Date: Sat Mar 15 10:31:28 2008 -0700first commit -p ，显示 每次 提交内容差异 12345678910111213141516171819git log -pcommit ca82a6dff817ec66f44342007202690a93763949Author: Scott Chacon &lt;schacon@gee-mail.com&gt;Date: Mon Mar 17 21:52:11 2008 -0700 changed the version numberdiff --git a/Rakefile b/Rakefile // git格式的diff,进行比较的文件,a版本的Rakefile(变动前),b版本的Rekefile(变动后)index a874b73..8f94139 100644 // 两个版本的哈希(index区的a874b73对象，8f94139对象比较),最后6位数字是对象的模式（普通文件，644权限）--- a/Rakefile // 变动前文件+++ b/Rakefile // 变动后文件@@ -5,7 +5,7 @@ require &#x27;rake/gempackagetask&#x27; // 与 合并格式的 diff 相同(diff-u file1 file2) -5,7 表示 &quot;-&quot;:变动前文件,&quot;5&quot;:第6行，&quot;7&quot;:连续7行, &quot;+&quot;:变动后文件spec = Gem::Specification.new do |s|s.platform = Gem::Platform::RUBYs.name = &quot;simplegit&quot;- s.version = &quot;0.1.0&quot; // &quot;-&quot; 变动前文件，删除的行+ s.version = &quot;0.1.1&quot; // &quot;+&quot; 变动后文件，添加的行 s.author = &quot;Scott Chacon&quot; s.email = &quot;schacon@gee-mail.com&quot; s.summary = &quot;A simple gem for using Git in Ruby code.&quot; --stat, 简略的统计信息列出每次提交所修改过 的文件、多少文件被修改、被修改过的文件的哪些行被移除或添加了。最后给出总结。 12345678910111213$ git log --statcommit ca82a6dff817ec66f44342007202690a93763949Author: Scott Chacon &lt;schacon@gee-mail.com&gt;Date: Mon Mar 17 21:52:11 2008 -0700changed the version numberRakefile | 2 +-1 file changed, 1 insertion(+), 1 deletion(-)commit 085bb3bcb608e1e8451d4b2432f8ecbe6306e7e7Author: Scott Chacon &lt;schacon@gee-mail.com&gt;Date: Sat Mar 15 16:40:33 2008 -0700removed unnecessary testlib/simplegit.rb | 5 -----1 file changed, 5 deletions(-) --pretty ，使用指定的方式展示提交记录 oneline 将每个提交放在一行。 1234$ git log --pretty=onelineca82a6dff817ec66f44342007202690a93763949 changed the version number085bb3bcb608e1e8451d4b2432f8ecbe6306e7e7 removed unnecessary testa11bef06a3f659402fe7563abf99ad00de2209e6 first commit format，定制要显示的记录格式 12345$ git log --pretty=format:&quot;%h - %an, %ar : %s&quot; ca82a6d - Scott Chacon, 6 years ago : changed the version number 085bb3b - Scott Chacon, 6 years ago : removed unnecessary test a11bef0 - Scott Chacon, 6 years ago : first commit 选项 说明 %H commit 的完整哈希字串 %h 简短哈希字串 %an 作者（author）名字 %ae 作者电子邮件地址 %ad 作者修订日期，（可用–date=选项定制格式） %ar 作者修订日期，按多久以前的方式显示 %cn 提交者（committer）名字 %ce 提交者电子邮件地址 %cd 提交者修订日期，（可用–date=选项定制格式） %cr 提交者修订日期，按多久以前的方式显示 %s 提交说明 --graph ，图像化的展示分支、合并历史 123456789101112131415161718$ git log --graph * commit ca82a6dff817ec66f44342007202690a93763949 (HEAD -&gt; master, origin/master, origin/HEAD) | Author: Scott Chacon &lt;schacon@gmail.com&gt; | Date: Mon Mar 17 21:52:11 2008 -0700 | | changed the verison number | * commit 085bb3bcb608e1e8451d4b2432f8ecbe6306e7e7 | Author: Scott Chacon &lt;schacon@gmail.com&gt; | Date: Sat Mar 15 16:40:33 2008 -0700 | | removed unnecessary test code | * commit a11bef06a3f659402fe7563abf99ad00de2209e6 Author: Scott Chacon &lt;schacon@gmail.com&gt; Date: Sat Mar 15 10:31:28 2008 -0700 first commit --name-only, 仅显示已经修改的文件清单 1234567891011121314151617181920212223242526$ git log --name-only commit ca82a6dff817ec66f44342007202690a93763949 (HEAD -&gt; master, origin/master, origin/HEAD) Author: Scott Chacon &lt;schacon@gmail.com&gt; Date: Mon Mar 17 21:52:11 2008 -0700 changed the verison number Rakefile commit 085bb3bcb608e1e8451d4b2432f8ecbe6306e7e7 Author: Scott Chacon &lt;schacon@gmail.com&gt; Date: Sat Mar 15 16:40:33 2008 -0700 removed unnecessary test code lib/simplegit.rb commit a11bef06a3f659402fe7563abf99ad00de2209e6 Author: Scott Chacon &lt;schacon@gmail.com&gt; Date: Sat Mar 15 10:31:28 2008 -0700 first commit README Rakefile lib/simplegit.rb --name-status, 显示新增、修改、删除的文件清单 1234567891011121314151617181920212223242526$ git log --name-status commit ca82a6dff817ec66f44342007202690a93763949 (HEAD -&gt; master, origin/master, origin/HEAD) Author: Scott Chacon &lt;schacon@gmail.com&gt; Date: Mon Mar 17 21:52:11 2008 -0700 changed the verison number M Rakefile commit 085bb3bcb608e1e8451d4b2432f8ecbe6306e7e7 Author: Scott Chacon &lt;schacon@gmail.com&gt; Date: Sat Mar 15 16:40:33 2008 -0700 removed unnecessary test code M lib/simplegit.rb commit a11bef06a3f659402fe7563abf99ad00de2209e6 Author: Scott Chacon &lt;schacon@gmail.com&gt; Date: Sat Mar 15 10:31:28 2008 -0700 first commit A README A Rakefile A lib/simplegit.rb git log 常用选项（限制输出格式） 选项 说明 -p 显示每次提交之间的差异 –stat 提交文件修改统计信息 –shortstat 只显示–stat 中最后的行数、修改、添加、移除统计 –name-only 仅显示已修改 的文件清单 –abbrev-commit 仅显示 SHA-1 的前几个字符，而非所有 40 个字符 –graph 显示 ASCII 图形表示的 分支 合并历史 –pretty 使用其他格式 显示提交 历史信息。包括 oneline, short,full,fuller,format（后跟指定格式–pretty=format:’%h, %s’） 限制输出除定制输出格式外，git log 有许多 限定输出长度的选项，也就是只 输出部分提交历史信息。 选项 说明 -(n) 显示最近的 n 条提交 –since,–after 指定时间之后的提交(–since=”2019-02-01 21:00:00”) –until, –before 指定时间之前的提交 –autor 指定作者相关的提交 –committer 指定提交者相关的提交 –grep 含指定关键字的提交 (在提交说明中搜索关键字) -S 显示添加或移除某个关键字的提交 （-S 预警查询,找出添加或移除”预警查询”的提交记录） 路径 选项如果只关心某些文件或目录中的历史提交，可在git log选项的最后指定它们的路径。需要用两个短划线(–)隔开之前的选项和后面跟的路径名 1234$ git log --pretty=&quot;%h %s&quot; --author=&quot;liuzhenjiang&quot; --since=&quot;2019-02-14 21:00:00&quot; --before=&quot;2019-02-16&quot; -- ./src/views/early-warning/early-area-control/ 84854447 【预警消息】 案件/地域预警消息，状态更新","categories":[{"name":"技术总结","slug":"技术总结","permalink":"https://better-jiang.github.io/categories/%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%93/"}],"tags":[{"name":"git","slug":"git","permalink":"https://better-jiang.github.io/tags/git/"}]},{"title":"git基础(2)-创建仓库/更新记录","slug":"git基础-2-创建仓库-更新记录","date":"2019-02-19T01:21:34.000Z","updated":"2023-02-03T12:14:22.413Z","comments":true,"path":"2019/02/19/git基础-2-创建仓库-更新记录/","link":"","permalink":"https://better-jiang.github.io/2019/02/19/git%E5%9F%BA%E7%A1%80-2-%E5%88%9B%E5%BB%BA%E4%BB%93%E5%BA%93-%E6%9B%B4%E6%96%B0%E8%AE%B0%E5%BD%95/","excerpt":"","text":"创建仓库 在现有目录初始化仓库 1$ git init git init 命令将在此目录下创建一个名为.git的子目录，该目录包含 Git 仓库的必须文件。如果在一个非空文件夹中初始化 Git 仓库，需要通过 git add 命令实现对指定文件的跟踪，然后执行 git commit 提交 克隆现有仓库 1$ git clone https://github.com/Better-Jiang/Better-Jiang.github.io 执行 git clone [url] [rpName]命令，默认配置下，会拉取远程 Git 仓库中的每一个文件的每一个版本，克隆了该 Git 仓库服务器上的几乎所有数据。 更新记录到仓库文件状态工作目录下的文件只有 2 中状态：已跟踪、未跟踪（Untracked） 已跟踪： 指那些已经纳入了版本控制的文件,在上一次快照中有它的记录。其状态可能处于未修改（Unmodified），已修改（Modified），放入暂存区（Staged）。 未跟踪（Untracked）：指既不在上次快照的记录中，也没有放入暂存区的文件。一般是新加入的文件，还没执行git add命令.git 文件生命周期： 检查当前文件状态git status 命令，查看当前目录文件状处于什么态. 目录干净（working directory clean），所有已跟踪的文件在上次提交后都未被更改过。 12345$ git statusOn branch masterYour branch is up to date with &#x27;origin/master&#x27;.nothing to commit, working tree clean 未跟踪的文件（Untracked files），在之前的快照（提交）中没有该文件。 12345678$ echo &#x27;My Project&#x27; &gt; README $ git status On branch master Untracked files: (use &quot;git add &lt;file&gt;...&quot; to include in what will be committed) README nothing added to commit but untracked files present (use &quot;git add&quot; to track) 跟踪新文件，但未提交（Changes to be committed），处于暂存状态使用git add命令 开始跟踪一个文件，是已暂存状态 1234567$ git add README$ git status On branch master Changes to be committed: (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage) new file: README 暂存已修改文件修改一个已被跟踪的文件，然后运行git status命令 123456789101112$ git statusOn branch masterChanges to be committed:(use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage)new file: READMEChanges not staged for commit:(use &quot;git add &lt;file&gt;...&quot; to update what will be committed)(use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in workingdirectory)modified: CONTRIBUTING.md 文件CONTRIBUTING.md 在Changes not staged for commit这行下面，说明已跟踪的文件被修改了，但没有放入暂存区。要暂存此次更新，需要再次执行git add命令。 1234567$ git add CONTRIBUTING.md$ git statusOn branch masterChanges to be committed:(use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage)new file: READMEmodified: CONTRIBUTING.md git add 将CONTRIBUTING.md文件放到暂存区，此时两个文件都是已暂存，下次执行提交时就会一并记录到仓库。 git add / git commit 理解git add命令有多个功能 可以用它开始跟踪新文件并放入暂存区 把已跟踪的且被修改过的文件放入暂存区 合并时把有冲突的文件标记未已解决状态 git add 命令 可理解为 添加内容到下一次提交中， 而非 将一个文件添加到项目中git commit命令，将暂存区的所有文件（git add 命令后的那个版本）提交到版本库中的当前分支上。如果执行了git add 命令之后又做了修改文件，需要重新运行git add 把最新的版本暂存起来。","categories":[{"name":"技术总结","slug":"技术总结","permalink":"https://better-jiang.github.io/categories/%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%93/"}],"tags":[{"name":"git","slug":"git","permalink":"https://better-jiang.github.io/tags/git/"}]},{"title":"git基础(1)-git常规环境配置","slug":"git基础-1-git常规环境配置","date":"2019-02-18T12:10:01.000Z","updated":"2023-02-03T12:14:22.413Z","comments":true,"path":"2019/02/18/git基础-1-git常规环境配置/","link":"","permalink":"https://better-jiang.github.io/2019/02/18/git%E5%9F%BA%E7%A1%80-1-git%E5%B8%B8%E8%A7%84%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/","excerpt":"","text":"Git 配置每台计算机 Git 环境只需配置一次，Git 升级后会自动保留配置信息。 配置级别Git 环境配置分 3 个级别，系统级别（system）-&gt; 用户级别（global）-&gt; 当前仓库（local），底层配置会覆盖顶层配置。 Git config 命令 查看所有配置 git config --list 123456$ git config --system --list // 查看系统 配置信息$ git config --global --list // 查看当前用户 配置信息$ git config --local --list // 查看当前仓库 配置信息 查看指定配置信息 1234$ git config --get user.name // 查看用户名$ git config --get user.email // 查看邮箱 添加 1$ git config --global --add user.name &#x27;liuzhenjiang&#x27; // 添加用户名 修改 12$ git config --global user.name &#x27;liuzhenjiang&#x27; // 修改用户名 删除 12$ git config --global --unset name // 删除用户名","categories":[{"name":"技术总结","slug":"技术总结","permalink":"https://better-jiang.github.io/categories/%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%93/"}],"tags":[{"name":"git","slug":"git","permalink":"https://better-jiang.github.io/tags/git/"}]},{"title":"vscode插件推荐","slug":"vscode插件推荐","date":"2019-02-18T08:37:33.000Z","updated":"2023-02-03T12:14:22.413Z","comments":true,"path":"2019/02/18/vscode插件推荐/","link":"","permalink":"https://better-jiang.github.io/2019/02/18/vscode%E6%8F%92%E4%BB%B6%E6%8E%A8%E8%8D%90/","excerpt":"","text":"VSCode 插件Visual Studio Code ，微软出品，一款免费的、开源的、轻量级的编辑器，支持插件扩展。正因此，受到越来越多前端开发者的追捧。vSCode 插件丰富多样，安装/卸载方便，运用的好，能大大提高开发效率。在官方插件市场,不但可搜索特定插件，还有历史安装量排名，每周/月安装趋势，每日特色好玩插件推荐。 常用插件推荐 Syncing使用GitHub Gist，跨平台，跨设备同步 所有 VSCode 设置（包含安装的插件） Auto Import通过在整个项目及其依赖项中建议可用的变量，当您选择其中一个建议时，VS 代码会自动将它的导入添加到文件的顶部 Auto Close Tag自动添加 HTML/XML 关闭标签 AUtoRename Tag自动重命名成对的 HTML/XML 标签 Bracket Pair Colorizer用颜色来标识匹配的括号。多层括号，相同曾经括号颜色相同 indent-rainbow不同层次缩减使用不同颜色的空格点，使缩减更容易阅读 Path Autocomplete文件路径自动补全、提示 Prettier-Code Formater使用 prettier 格式化代码,部分规则可自行配置 -TODO Highlight高亮文件中的 TODO、FIXME 等注释标记 TODO TREE 在树视图中显示 TODO、FIXME 等注释标记 Debugger for Chrome在 chrome 调试 javaScript 代码 npm intellisense提示、并自动补全导入语句中的存在的 npm 模块 Code Time 编码时间统计 IntelliSense for Css Scss class namecss 中 class 命名 智能提示 HTML SnippetsHTML 代码片段 HTML CSS SupportCSS 提示 CSS Peek 在 html 中参看/跳转到 css 所定义的样式 Vue VSCode Snippets vue 代码片段 Vue 2 SnippetsVue 2 的代码片段 Vue Peek 查看/跳转到 组件 Veturvue 工具包，包括语法高亮、代码片段、错误检查、格式化等 Change-case变量名命名风格切换,选择多个变量，（快捷键 Alt + click） Iview Snippetsiview 代码片段 Less IntelliSenseless 智能提示，自动补全 Image preview显示图片预览","categories":[{"name":"技术总结","slug":"技术总结","permalink":"https://better-jiang.github.io/categories/%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%93/"}],"tags":[{"name":"vscode","slug":"vscode","permalink":"https://better-jiang.github.io/tags/vscode/"}]}],"categories":[{"name":"上班摸鱼写散文","slug":"上班摸鱼写散文","permalink":"https://better-jiang.github.io/categories/%E4%B8%8A%E7%8F%AD%E6%91%B8%E9%B1%BC%E5%86%99%E6%95%A3%E6%96%87/"},{"name":"技术总结","slug":"技术总结","permalink":"https://better-jiang.github.io/categories/%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%93/"},{"name":"烂笔头","slug":"烂笔头","permalink":"https://better-jiang.github.io/categories/%E7%83%82%E7%AC%94%E5%A4%B4/"},{"name":"英语拾遗","slug":"英语拾遗","permalink":"https://better-jiang.github.io/categories/%E8%8B%B1%E8%AF%AD%E6%8B%BE%E9%81%97/"},{"name":"随笔感悟","slug":"随笔感悟","permalink":"https://better-jiang.github.io/categories/%E9%9A%8F%E7%AC%94%E6%84%9F%E6%82%9F/"},{"name":"成长小记","slug":"成长小记","permalink":"https://better-jiang.github.io/categories/%E6%88%90%E9%95%BF%E5%B0%8F%E8%AE%B0/"},{"name":"就要表达","slug":"就要表达","permalink":"https://better-jiang.github.io/categories/%E5%B0%B1%E8%A6%81%E8%A1%A8%E8%BE%BE/"}],"tags":[{"name":"一碗鸡汤","slug":"一碗鸡汤","permalink":"https://better-jiang.github.io/tags/%E4%B8%80%E7%A2%97%E9%B8%A1%E6%B1%A4/"},{"name":"面试","slug":"面试","permalink":"https://better-jiang.github.io/tags/%E9%9D%A2%E8%AF%95/"},{"name":"grunt","slug":"grunt","permalink":"https://better-jiang.github.io/tags/grunt/"},{"name":"ESLint","slug":"ESLint","permalink":"https://better-jiang.github.io/tags/ESLint/"},{"name":"团队协作","slug":"团队协作","permalink":"https://better-jiang.github.io/tags/%E5%9B%A2%E9%98%9F%E5%8D%8F%E4%BD%9C/"},{"name":"语法","slug":"语法","permalink":"https://better-jiang.github.io/tags/%E8%AF%AD%E6%B3%95/"},{"name":"shell","slug":"shell","permalink":"https://better-jiang.github.io/tags/shell/"},{"name":"pnpm","slug":"pnpm","permalink":"https://better-jiang.github.io/tags/pnpm/"},{"name":"redis","slug":"redis","permalink":"https://better-jiang.github.io/tags/redis/"},{"name":"技术总结","slug":"技术总结","permalink":"https://better-jiang.github.io/tags/%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%93/"},{"name":"反思怪","slug":"反思怪","permalink":"https://better-jiang.github.io/tags/%E5%8F%8D%E6%80%9D%E6%80%AA/"},{"name":"烂笔头","slug":"烂笔头","permalink":"https://better-jiang.github.io/tags/%E7%83%82%E7%AC%94%E5%A4%B4/"},{"name":"vite","slug":"vite","permalink":"https://better-jiang.github.io/tags/vite/"},{"name":"eslint","slug":"eslint","permalink":"https://better-jiang.github.io/tags/eslint/"},{"name":"飞盘","slug":"飞盘","permalink":"https://better-jiang.github.io/tags/%E9%A3%9E%E7%9B%98/"},{"name":"网络","slug":"网络","permalink":"https://better-jiang.github.io/tags/%E7%BD%91%E7%BB%9C/"},{"name":"编程认知","slug":"编程认知","permalink":"https://better-jiang.github.io/tags/%E7%BC%96%E7%A8%8B%E8%AE%A4%E7%9F%A5/"},{"name":"linux","slug":"linux","permalink":"https://better-jiang.github.io/tags/linux/"},{"name":"成长小记","slug":"成长小记","permalink":"https://better-jiang.github.io/tags/%E6%88%90%E9%95%BF%E5%B0%8F%E8%AE%B0/"},{"name":"css","slug":"css","permalink":"https://better-jiang.github.io/tags/css/"},{"name":"http","slug":"http","permalink":"https://better-jiang.github.io/tags/http/"},{"name":"javascript","slug":"javascript","permalink":"https://better-jiang.github.io/tags/javascript/"},{"name":"vue","slug":"vue","permalink":"https://better-jiang.github.io/tags/vue/"},{"name":"前端性能","slug":"前端性能","permalink":"https://better-jiang.github.io/tags/%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD/"},{"name":"axios","slug":"axios","permalink":"https://better-jiang.github.io/tags/axios/"},{"name":"webpack","slug":"webpack","permalink":"https://better-jiang.github.io/tags/webpack/"},{"name":"翻译","slug":"翻译","permalink":"https://better-jiang.github.io/tags/%E7%BF%BB%E8%AF%91/"},{"name":"CSS权威指南-第四版","slug":"CSS权威指南-第四版","permalink":"https://better-jiang.github.io/tags/CSS%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97-%E7%AC%AC%E5%9B%9B%E7%89%88/"},{"name":"书籍读后感","slug":"书籍读后感","permalink":"https://better-jiang.github.io/tags/%E4%B9%A6%E7%B1%8D%E8%AF%BB%E5%90%8E%E6%84%9F/"},{"name":"npm","slug":"npm","permalink":"https://better-jiang.github.io/tags/npm/"},{"name":"git","slug":"git","permalink":"https://better-jiang.github.io/tags/git/"},{"name":"vscode","slug":"vscode","permalink":"https://better-jiang.github.io/tags/vscode/"}]}