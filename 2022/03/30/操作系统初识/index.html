<!DOCTYPE html>
<html lang=zh>
<head>
  <meta charset="utf-8">
  
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no, minimal-ui">
  <meta name="renderer" content="webkit">
  <meta http-equiv="Cache-Control" content="no-transform" />
  <meta http-equiv="Cache-Control" content="no-siteapp" />
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black">
  <meta name="format-detection" content="telephone=no,email=no,adress=no">
  <!-- google 广告 -->
  <script data-ad-client="ca-pub-7070857500305563" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <!-- Color theme for statusbar -->
  <meta name="theme-color" content="#000000" />
  <!-- 强制页面在当前窗口以独立页面显示,防止别人在框架里调用页面 -->
  <meta http-equiv="window-target" content="_top" />
  
  
  <title>操作系统初识 | better-jiang</title>
  <meta name="description" content="OS 基本概念操作系统是控制软件  管理应用程序 为应用程序提供服务 分配资源 CPU (CPU 调度、进程、线程) 内存 (物理内存、虚拟内存) 磁盘 (文件系统)   管理外设  并发、并行  并发(concurrent)，在一段时间内多个程序交替运行 并行(parallel), 在一个时间点上有多个程序同时运行  启动、中断、异常、系统调用启动BIOS： Basic Input Output">
<meta property="og:type" content="article">
<meta property="og:title" content="操作系统初识">
<meta property="og:url" content="https://better-jiang.github.io/2022/03/30/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%88%9D%E8%AF%86/index.html">
<meta property="og:site_name" content="爱学兮的小江">
<meta property="og:description" content="OS 基本概念操作系统是控制软件  管理应用程序 为应用程序提供服务 分配资源 CPU (CPU 调度、进程、线程) 内存 (物理内存、虚拟内存) 磁盘 (文件系统)   管理外设  并发、并行  并发(concurrent)，在一段时间内多个程序交替运行 并行(parallel), 在一个时间点上有多个程序同时运行  启动、中断、异常、系统调用启动BIOS： Basic Input Output">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://better-jiang.github.io/image/interrupt.png">
<meta property="og:image" content="https://better-jiang.github.io/image/memory-hierarchy.png">
<meta property="og:image" content="https://better-jiang.github.io/image/page_table.png">
<meta property="og:image" content="https://better-jiang.github.io/image/indrection_page.png">
<meta property="og:image" content="https://better-jiang.github.io/image/segment_page.png">
<meta property="og:image" content="https://better-jiang.github.io/image/virtual_memory.png">
<meta property="og:image" content="https://better-jiang.github.io/image/page_item.png">
<meta property="og:image" content="https://better-jiang.github.io/image/page_missing_execption.png">
<meta property="og:image" content="https://better-jiang.github.io/image/process_suspend.png">
<meta property="og:image" content="https://better-jiang.github.io/image/synchronized.png">
<meta property="og:image" content="https://better-jiang.github.io/image/moniter.png">
<meta property="og:image" content="https://better-jiang.github.io/image/UFS.png">
<meta property="og:image" content="https://better-jiang.github.io/image/IO_lifecycle.png">
<meta property="og:image" content="https://better-jiang.github.io/image/read-disk-by-direct-IO-address.png">
<meta property="article:published_time" content="2022-03-30T00:53:57.000Z">
<meta property="article:modified_time" content="2023-02-03T12:14:22.423Z">
<meta property="article:author" content="刘振江">
<meta property="article:tag" content="编程认知">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://better-jiang.github.io/image/interrupt.png">
  <!-- Canonical links -->
  <link rel="canonical" href="https://better-jiang.github.io/2022/03/30/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%88%9D%E8%AF%86/index.html">
  
    <link rel="alternate" href="/atom.xml" title="爱学兮的小江" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.ico" type="image/x-icon">
  
  
<link rel="stylesheet" href="/css/style.css">

  
  
  
    <link href="//cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.3.5/dist/jquery.fancybox.min.css" rel="stylesheet">
  
  
    <link rel="stylesheet" href="//cdn.jsdelivr.net/npm/gitalk@1.4.0/dist/gitalk.min.css">
  
<meta name="generator" content="Hexo 6.3.0"></head>


<body class="main-center theme-purple" itemscope itemtype="http://schema.org/WebPage">
  <header class="header" itemscope itemtype="http://schema.org/WPHeader">
  <div class="slimContent">
    <div class="navbar-header">
      
      
      <div class="profile-block text-center">
        <a id="avatar" href="https://github.com/Better-Jiang" target="_blank">
          <img class="img-circle img-rotate" src="/images/avatar.jpg" width="200" height="200">
        </a>
        <h2 id="name" class="hidden-xs hidden-sm">爱学兮的小江</h2>
        <h3 id="title" class="hidden-xs hidden-sm hidden-md">Web前端 &amp; Vue</h3>
        <small id="location" class="text-muted hidden-xs hidden-sm"><i class="icon icon-map-marker"></i> Shenzhen, China</small>
      </div>
      
      <div class="search" id="search-form-wrap">

    <form class="search-form sidebar-form">
        <div class="input-group">
            <input type="text" class="search-form-input form-control" placeholder="搜索" />
            <span class="input-group-btn">
                <button type="submit" class="search-form-submit btn btn-flat" onclick="return false;"><i class="icon icon-search"></i></button>
            </span>
        </div>
    </form>
    <div class="ins-search">
  <div class="ins-search-mask"></div>
  <div class="ins-search-container">
    <div class="ins-input-wrapper">
      <input type="text" class="ins-search-input" placeholder="想要查找什么..." x-webkit-speech />
      <button type="button" class="close ins-close ins-selectable" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">×</span></button>
    </div>
    <div class="ins-section-wrapper">
      <div class="ins-section-container"></div>
    </div>
  </div>
</div>


</div>
      <button class="navbar-toggle collapsed" type="button" data-toggle="collapse" data-target="#main-navbar" aria-controls="main-navbar" aria-expanded="false">
        <span class="sr-only">Toggle navigation</span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
    </div>
    <nav id="main-navbar" class="collapse navbar-collapse" itemscope itemtype="http://schema.org/SiteNavigationElement" role="navigation">
      <ul class="nav navbar-nav main-nav ">
        
        
        <li class="menu-item menu-item-home">
          <a href="/.">
            
            <i class="icon icon-home-fill"></i>
            
            <span class="menu-title">首页</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-archives">
          <a href="/archives">
            
            <i class="icon icon-archives-fill"></i>
            
            <span class="menu-title">归档</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-categories">
          <a href="/categories">
            
            <i class="icon icon-folder"></i>
            
            <span class="menu-title">分类</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-tags">
          <a href="/tags">
            
            <i class="icon icon-tags"></i>
            
            <span class="menu-title">标签</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-repository">
          <a href="/repository">
            
            <i class="icon icon-project"></i>
            
            <span class="menu-title">项目</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-about">
          <a href="/about">
            
            <i class="icon icon-cup-fill"></i>
            
            <span class="menu-title">关于</span>
          </a>
        </li>
        
      </ul>
      
	
    <ul class="social-links">
    	
        <li><a href="https://github.com/Better-Jiang" target="_blank" title="Github" data-toggle=tooltip data-placement=top><i class="icon icon-github"></i></a></li>
        
    </ul>

    </nav>
  </div>
</header>

  
    <aside class="sidebar" itemscope itemtype="http://schema.org/WPSideBar">
  <div class="slimContent">
    
      <div class="widget">
    <h3 class="widget-title">公告</h3>
    <div class="widget-body">
        <div id="board">
            <div class="content">
                <p>欢迎交流与分享经验!</p>
            </div>
        </div>
    </div>
</div>

    
      
  <div class="widget">
    <h3 class="widget-title">分类</h3>
    <div class="widget-body">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/%E4%B8%8A%E7%8F%AD%E6%91%B8%E9%B1%BC%E5%86%99%E6%95%A3%E6%96%87/">上班摸鱼写散文</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%B0%B1%E8%A6%81%E8%A1%A8%E8%BE%BE/">就要表达</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%88%90%E9%95%BF%E5%B0%8F%E8%AE%B0/">成长小记</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%93/">技术总结</a><span class="category-list-count">85</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%83%82%E7%AC%94%E5%A4%B4/">烂笔头</a><span class="category-list-count">9</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E8%8B%B1%E8%AF%AD%E6%8B%BE%E9%81%97/">英语拾遗</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E9%9A%8F%E7%AC%94%E6%84%9F%E6%82%9F/">随笔感悟</a><span class="category-list-count">11</span></li></ul>
    </div>
  </div>


    
      
  <div class="widget">
    <h3 class="widget-title">标签</h3>
    <div class="widget-body">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/CSS%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97-%E7%AC%AC%E5%9B%9B%E7%89%88/" rel="tag">CSS权威指南-第四版</a><span class="tag-list-count">9</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/ESLint/" rel="tag">ESLint</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/axios/" rel="tag">axios</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/css/" rel="tag">css</a><span class="tag-list-count">23</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/eslint/" rel="tag">eslint</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/git/" rel="tag">git</a><span class="tag-list-count">10</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/grunt/" rel="tag">grunt</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/http/" rel="tag">http</a><span class="tag-list-count">4</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/javascript/" rel="tag">javascript</a><span class="tag-list-count">13</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/linux/" rel="tag">linux</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/npm/" rel="tag">npm</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/pnpm/" rel="tag">pnpm</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/redis/" rel="tag">redis</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/shell/" rel="tag">shell</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/vite/" rel="tag">vite</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/vscode/" rel="tag">vscode</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/vue/" rel="tag">vue</a><span class="tag-list-count">10</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/webpack/" rel="tag">webpack</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E4%B8%80%E7%A2%97%E9%B8%A1%E6%B1%A4/" rel="tag">一碗鸡汤</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E4%B9%A6%E7%B1%8D%E8%AF%BB%E5%90%8E%E6%84%9F/" rel="tag">书籍读后感</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD/" rel="tag">前端性能</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%8F%8D%E6%80%9D%E6%80%AA/" rel="tag">反思怪</a><span class="tag-list-count">3</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%9B%A2%E9%98%9F%E5%8D%8F%E4%BD%9C/" rel="tag">团队协作</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%88%90%E9%95%BF%E5%B0%8F%E8%AE%B0/" rel="tag">成长小记</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%93/" rel="tag">技术总结</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%83%82%E7%AC%94%E5%A4%B4/" rel="tag">烂笔头</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%BC%96%E7%A8%8B%E8%AE%A4%E7%9F%A5/" rel="tag">编程认知</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%BD%91%E7%BB%9C/" rel="tag">网络</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%BF%BB%E8%AF%91/" rel="tag">翻译</a><span class="tag-list-count">10</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%AF%AD%E6%B3%95/" rel="tag">语法</a><span class="tag-list-count">3</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E9%9D%A2%E8%AF%95/" rel="tag">面试</a><span class="tag-list-count">9</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E9%A3%9E%E7%9B%98/" rel="tag">飞盘</a><span class="tag-list-count">3</span></li></ul>
    </div>
  </div>


    
      
  <div class="widget">
    <h3 class="widget-title">标签云</h3>
    <div class="widget-body tagcloud">
      <a href="/tags/CSS%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97-%E7%AC%AC%E5%9B%9B%E7%89%88/" style="font-size: 13.57px;">CSS权威指南-第四版</a> <a href="/tags/ESLint/" style="font-size: 13px;">ESLint</a> <a href="/tags/axios/" style="font-size: 13px;">axios</a> <a href="/tags/css/" style="font-size: 14px;">css</a> <a href="/tags/eslint/" style="font-size: 13px;">eslint</a> <a href="/tags/git/" style="font-size: 13.71px;">git</a> <a href="/tags/grunt/" style="font-size: 13px;">grunt</a> <a href="/tags/http/" style="font-size: 13.43px;">http</a> <a href="/tags/javascript/" style="font-size: 13.86px;">javascript</a> <a href="/tags/linux/" style="font-size: 13px;">linux</a> <a href="/tags/npm/" style="font-size: 13px;">npm</a> <a href="/tags/pnpm/" style="font-size: 13px;">pnpm</a> <a href="/tags/redis/" style="font-size: 13px;">redis</a> <a href="/tags/shell/" style="font-size: 13px;">shell</a> <a href="/tags/vite/" style="font-size: 13px;">vite</a> <a href="/tags/vscode/" style="font-size: 13px;">vscode</a> <a href="/tags/vue/" style="font-size: 13.71px;">vue</a> <a href="/tags/webpack/" style="font-size: 13px;">webpack</a> <a href="/tags/%E4%B8%80%E7%A2%97%E9%B8%A1%E6%B1%A4/" style="font-size: 13px;">一碗鸡汤</a> <a href="/tags/%E4%B9%A6%E7%B1%8D%E8%AF%BB%E5%90%8E%E6%84%9F/" style="font-size: 13.14px;">书籍读后感</a> <a href="/tags/%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD/" style="font-size: 13px;">前端性能</a> <a href="/tags/%E5%8F%8D%E6%80%9D%E6%80%AA/" style="font-size: 13.29px;">反思怪</a> <a href="/tags/%E5%9B%A2%E9%98%9F%E5%8D%8F%E4%BD%9C/" style="font-size: 13px;">团队协作</a> <a href="/tags/%E6%88%90%E9%95%BF%E5%B0%8F%E8%AE%B0/" style="font-size: 13px;">成长小记</a> <a href="/tags/%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%93/" style="font-size: 13px;">技术总结</a> <a href="/tags/%E7%83%82%E7%AC%94%E5%A4%B4/" style="font-size: 13px;">烂笔头</a> <a href="/tags/%E7%BC%96%E7%A8%8B%E8%AE%A4%E7%9F%A5/" style="font-size: 13.14px;">编程认知</a> <a href="/tags/%E7%BD%91%E7%BB%9C/" style="font-size: 13.14px;">网络</a> <a href="/tags/%E7%BF%BB%E8%AF%91/" style="font-size: 13.71px;">翻译</a> <a href="/tags/%E8%AF%AD%E6%B3%95/" style="font-size: 13.29px;">语法</a> <a href="/tags/%E9%9D%A2%E8%AF%95/" style="font-size: 13.57px;">面试</a> <a href="/tags/%E9%A3%9E%E7%9B%98/" style="font-size: 13.29px;">飞盘</a>
    </div>
  </div>

    
      
  <div class="widget">
    <h3 class="widget-title">归档</h3>
    <div class="widget-body">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/02/">二月 2023</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/08/">八月 2022</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/07/">七月 2022</a><span class="archive-list-count">5</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/06/">六月 2022</a><span class="archive-list-count">7</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/05/">五月 2022</a><span class="archive-list-count">4</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/04/">四月 2022</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/03/">三月 2022</a><span class="archive-list-count">6</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/06/">六月 2020</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/05/">五月 2020</a><span class="archive-list-count">10</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/04/">四月 2020</a><span class="archive-list-count">10</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/03/">三月 2020</a><span class="archive-list-count">5</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/01/">一月 2020</a><span class="archive-list-count">5</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/12/">十二月 2019</a><span class="archive-list-count">18</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/11/">十一月 2019</a><span class="archive-list-count">5</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/05/">五月 2019</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/04/">四月 2019</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/03/">三月 2019</a><span class="archive-list-count">9</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/02/">二月 2019</a><span class="archive-list-count">14</span></li></ul>
    </div>
  </div>


    
      
  <div class="widget">
    <h3 class="widget-title">最新文章</h3>
    <div class="widget-body">
      <ul class="recent-post-list list-unstyled no-thumbnail">
        
          <li>
            
            <div class="item-inner">
              <p class="item-category">
                <a class="category-link" href="/categories/%E4%B8%8A%E7%8F%AD%E6%91%B8%E9%B1%BC%E5%86%99%E6%95%A3%E6%96%87/">上班摸鱼写散文</a>
              </p>
              <p class="item-title">
                <a href="/2023/02/03/%E7%BB%A7%E7%BB%AD%E7%94%9F%E6%B4%BB/" class="title">继续生活</a>
              </p>
              <p class="item-date">
                <time datetime="2023-02-03T12:19:45.000Z" itemprop="datePublished">2023-02-03</time>
              </p>
            </div>
          </li>
          
          <li>
            
            <div class="item-inner">
              <p class="item-category">
                <a class="category-link" href="/categories/%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%93/">技术总结</a>
              </p>
              <p class="item-title">
                <a href="/2022/08/20/js%E7%96%91%E9%9A%BE%E6%B2%BB%E6%84%88/" class="title">js疑难治愈</a>
              </p>
              <p class="item-date">
                <time datetime="2022-08-20T00:50:12.000Z" itemprop="datePublished">2022-08-20</time>
              </p>
            </div>
          </li>
          
          <li>
            
            <div class="item-inner">
              <p class="item-category">
                <a class="category-link" href="/categories/%E7%83%82%E7%AC%94%E5%A4%B4/">烂笔头</a>
              </p>
              <p class="item-title">
                <a href="/2022/08/13/%E5%B0%8F%E7%99%BD%E7%AC%94%E8%AE%B0-grunt/" class="title">小白笔记-grunt</a>
              </p>
              <p class="item-date">
                <time datetime="2022-08-13T01:56:40.000Z" itemprop="datePublished">2022-08-13</time>
              </p>
            </div>
          </li>
          
          <li>
            
            <div class="item-inner">
              <p class="item-category">
                <a class="category-link" href="/categories/%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%93/">技术总结</a>
              </p>
              <p class="item-title">
                <a href="/2022/08/04/%E5%8E%BB%E4%BA%86%E8%A7%A3ESLint%E5%90%A7/" class="title">去了解ESLint吧</a>
              </p>
              <p class="item-date">
                <time datetime="2022-08-04T06:09:15.000Z" itemprop="datePublished">2022-08-04</time>
              </p>
            </div>
          </li>
          
          <li>
            
            <div class="item-inner">
              <p class="item-category">
                <a class="category-link" href="/categories/%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%93/">技术总结</a>
              </p>
              <p class="item-title">
                <a href="/2022/07/27/%E7%BC%BA%E9%99%B7%E6%8E%A7%E5%88%B6/" class="title">缺陷控制</a>
              </p>
              <p class="item-date">
                <time datetime="2022-07-27T07:06:01.000Z" itemprop="datePublished">2022-07-27</time>
              </p>
            </div>
          </li>
          
      </ul>
    </div>
  </div>
  

    
  </div>
</aside>

  
  
<main class="main" role="main">
  <div class="content">
  <article id="post-操作系统初识" class="article article-type-post" itemscope itemtype="http://schema.org/BlogPosting">
    
    <div class="article-header">
      
        
  
    <h1 class="article-title" itemprop="name">
      操作系统初识
    </h1>
  

      
      <div class="article-meta">
        <span class="article-date">
    <i class="icon icon-calendar-check"></i>
	<a href="/2022/03/30/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%88%9D%E8%AF%86/" class="article-date">
	  <time datetime="2022-03-30T00:53:57.000Z" itemprop="datePublished">2022-03-30</time>
	</a>
</span>
        
  <span class="article-category">
    <i class="icon icon-folder"></i>
    <a class="article-category-link" href="/categories/%E7%83%82%E7%AC%94%E5%A4%B4/">烂笔头</a>
  </span>

        
  <span class="article-tag">
    <i class="icon icon-tags"></i>
	<a class="article-tag-link-link" href="/tags/%E7%BC%96%E7%A8%8B%E8%AE%A4%E7%9F%A5/" rel="tag">编程认知</a>
  </span>


        
	<span class="article-read hidden-xs">
	    <i class="icon icon-eye-fill" aria-hidden="true"></i>
	    <span id="busuanzi_container_page_pv">
			<span id="busuanzi_value_page_pv">0</span>
		</span>
	</span>


        <span class="post-comment"><i class="icon icon-comment"></i> <a href="/2022/03/30/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%88%9D%E8%AF%86/#comments" class="article-comment-link">评论</a></span>
        
	
		<span class="post-wordcount hidden-xs" itemprop="wordCount">字数统计: 12.5k(字)</span>
	
	
		<span class="post-readcount hidden-xs" itemprop="timeRequired">阅读时长: 43(分)</span>
	

      </div>
    </div>
    <div class="article-entry marked-body" itemprop="articleBody">
      
        <h2 id="OS-基本概念"><a href="#OS-基本概念" class="headerlink" title="OS 基本概念"></a>OS 基本概念</h2><p>操作系统是<strong>控制软件</strong></p>
<ul>
<li>管理应用程序</li>
<li>为应用程序提供服务</li>
<li>分配资源<ul>
<li>CPU (CPU 调度、进程、线程)</li>
<li>内存 (物理内存、虚拟内存)</li>
<li>磁盘 (文件系统)</li>
</ul>
</li>
<li>管理外设</li>
</ul>
<p><strong>并发、并行</strong></p>
<ul>
<li>并发(concurrent)，在<strong>一段时间</strong>内多个程序<strong>交替运行</strong></li>
<li>并行(parallel), 在一个<strong>时间点</strong>上有多个程序<strong>同时运行</strong></li>
</ul>
<h2 id="启动、中断、异常、系统调用"><a href="#启动、中断、异常、系统调用" class="headerlink" title="启动、中断、异常、系统调用"></a>启动、中断、异常、系统调用</h2><h4 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h4><p>BIOS： Basic Input Output System， 一组固化到 ROM 上的程序，是计算机启动时加载的第一个程序</p>
<p><strong>BIOS 启动固件 作用</strong></p>
<ul>
<li><p>基本输入输出程序</p>
</li>
<li><p>系统设置信息</p>
</li>
<li><p>开机后自检程序</p>
</li>
<li><p>系统自动程序(BIOS)</p>
<p>将加载程序从磁盘的引导扇区(512 字节)加载到 0x7c000,之后跳转到 0x7c00</p>
</li>
</ul>
<p><strong>加载程序</strong>(bootloader)</p>
<p>将操作系统代码、数据从硬盘加载到内存，并跳转到操作系统起始地址</p>
<h4 id="中断、异常、系统调用"><a href="#中断、异常、系统调用" class="headerlink" title="中断、异常、系统调用"></a>中断、异常、系统调用</h4><ul>
<li>中断(hardware interrupt)， 来自<strong>硬件设备</strong>的处理请求； <strong>异步响应</strong></li>
<li>异常(exception)，非法指令或其他原因导致当前<strong>指令执行失败</strong>； <strong>同步响应</strong></li>
<li>系统调用(system call)， 应用程序<strong>主动</strong>向操作系统发出的服务请求； <strong>异步或同步</strong></li>
</ul>
<h4 id="中断（中断、异常、系统调用）处理机制"><a href="#中断（中断、异常、系统调用）处理机制" class="headerlink" title="中断（中断、异常、系统调用）处理机制"></a>中断（中断、异常、系统调用）处理机制</h4><ul>
<li>硬件处理，在 CPU 初始化时 设置 <strong>中断使能</strong>标志；<ul>
<li>依据内部或外部事件设置中断标志</li>
<li>依据 <strong>中断向量表</strong> 调用相应<strong>中断服务例程</strong></li>
</ul>
</li>
<li>软件<ul>
<li>现场保存 (编译器)</li>
<li>中断服务处理 (服务例程)</li>
<li>清除中断标记 (服务例程)</li>
<li>现场恢复 (编译器)</li>
</ul>
</li>
</ul>
<p><img src="/image/interrupt.png" alt="中断处理"></p>
<h4 id="中断嵌套"><a href="#中断嵌套" class="headerlink" title="中断嵌套"></a>中断嵌套</h4><ul>
<li><p>硬件中断服务可被<strong>打断</strong></p>
<ul>
<li>不同硬件的中断源可能在硬件中断处理时出现</li>
<li>硬件中断服务例程中 需要 <strong>临时禁止中断请求</strong></li>
<li>中断请求会<strong>保持到 CPU 做出响应</strong></li>
</ul>
</li>
<li><p>异常服务例程 可被 <strong>打断、嵌套</strong></p>
<ul>
<li>异常服务例程执行时 可能出现硬件中断</li>
<li>异常服务例程可能出现<strong>缺页</strong></li>
</ul>
</li>
</ul>
<h4 id="系统调用的实现"><a href="#系统调用的实现" class="headerlink" title="系统调用的实现"></a>系统调用的实现</h4><ul>
<li><p>每个系统调用对应一个<strong>系统调用号</strong>， 系统调用接口根据系统调用号来维护<strong>表的索引</strong></p>
</li>
<li><p>系统调用接口调用<strong>内核态</strong>中的系统调用功能实现，并返回系统调用的状态和结果</p>
</li>
<li><p>用户不需要知道系统调用的实现， 仅需设置<strong>调用参数</strong>和获取<strong>返回结果</strong></p>
</li>
</ul>
<h4 id="函数调用、系统调用-差异"><a href="#函数调用、系统调用-差异" class="headerlink" title="函数调用、系统调用 差异"></a>函数调用、系统调用 差异</h4><ul>
<li>系统调用<ul>
<li><strong>INT</strong>和 <strong>IRET</strong>指令</li>
<li>发生 <strong>堆栈切换</strong>、<strong>特权级 转换</strong></li>
</ul>
</li>
<li>函数调用</li>
<li><ul>
<li><strong>CALL</strong> 和 <strong>RET</strong> 指令</li>
<li>没有 堆栈切换</li>
</ul>
</li>
</ul>
<h4 id="中断、异常、系统调用的开销"><a href="#中断、异常、系统调用的开销" class="headerlink" title="中断、异常、系统调用的开销"></a>中断、异常、系统调用的开销</h4><ul>
<li>引导机制</li>
<li>建立内核堆栈</li>
<li>验证参数</li>
<li>内核态映射到用户态的地址</li>
<li>内核态独立地址空间</li>
</ul>
<h2 id="内存管理-物理内存-连续分配"><a href="#内存管理-物理内存-连续分配" class="headerlink" title="内存管理(物理内存) - 连续分配"></a>内存管理(物理内存) - 连续分配</h2><h4 id="内存的层次结构"><a href="#内存的层次结构" class="headerlink" title="内存的层次结构"></a>内存的层次结构</h4><ul>
<li><p>CPU 内部 包含 <strong>ALU</strong>(算术逻辑单元)、<strong>MMU</strong>(内存管理单元)、<strong>寄存器</strong>、<strong>cache</strong>,其容量小， 访问速度快。</p>
</li>
<li><p>主存(物理内存)，存放操作系统和各应用，通过 <strong>交换/分页</strong>和 磁盘交互，将永久保存的数据放到磁盘中(<strong>虚拟内存</strong>)</p>
<p><img src="/image/memory-hierarchy.png" alt="内存层次结构"></p>
</li>
</ul>
<h4 id="操作系统的内存管理"><a href="#操作系统的内存管理" class="headerlink" title="操作系统的内存管理"></a>操作系统的内存管理</h4><ul>
<li><p>抽象，逻辑地址空间</p>
</li>
<li><p>保护，独立地址空间</p>
</li>
<li><p>共享，访问相同内存</p>
</li>
<li><p>虚拟化，更大的地址空间</p>
</li>
</ul>
<h4 id="操作系统的内存管理方式"><a href="#操作系统的内存管理方式" class="headerlink" title="操作系统的内存管理方式"></a>操作系统的内存管理方式</h4><p>目前多数操作系统采用 <strong>按需页使虚拟</strong>存储</p>
<ul>
<li>重定位(relocation)</li>
<li>分段(segmentation)</li>
<li>分页(paging)</li>
<li>虚拟存储 (virtual memory)</li>
</ul>
<h4 id="地址空间"><a href="#地址空间" class="headerlink" title="地址空间"></a>地址空间</h4><ul>
<li>物理地址空间， 硬件支持的地址空间，起始地址 0， 到 MAX_sys</li>
<li>逻辑地址空间，在 CPU 运行的进程中看到的地址，起始地址 0， 到 MAX_prog ， 通过<strong>映射关系</strong>，落在物理空间上。</li>
<li>逻辑地址生成过程：<ul>
<li>C 程序通过编译、汇编、链接 link、载入（<strong>重定位</strong>）生产可执行文件，将逻辑地址映射到物理空间上。</li>
<li>C 程序中函数的位置(入口)，变量名就是逻辑地址，</li>
<li>编译后(.o 文件)起始地址为 0，把变量名和函数名转为相应的<strong>从 0 开始的连续逻辑地址</strong></li>
<li>link 把多个.o 文件和成一个，存放在硬盘中，通过 loader 应用程序把可执行文件载入内存中执行，这里有分配地址空间和映射(偏移)的过程</li>
</ul>
</li>
<li>物理地址生产过程：<ul>
<li>CPU 执行指令，ALU 需要逻辑地址的内存内容，<strong>发生请求、传递参数</strong>，参数就是逻辑地址</li>
<li>查表，根据 CPU 中 MMU，查表 将 逻辑地址 转换为 物理地址</li>
<li>找到后 CPU 给内存发请求，请求一个物理地址</li>
<li>内存会通过总线把内容传递给 CPU，CPU 执行指令</li>
</ul>
</li>
</ul>
<h4 id="地址生成时机和限制"><a href="#地址生成时机和限制" class="headerlink" title="地址生成时机和限制"></a>地址生成时机和限制</h4><ul>
<li><p>编译时</p>
<ul>
<li><strong>假设起始地址已知</strong>；</li>
<li>如果<strong>起始地址改变</strong>，必须<strong>重新编译</strong></li>
</ul>
</li>
<li><p>加载时</p>
<ul>
<li><p>如果编译时起始位置未知，编译器需生成<strong>可重定位的代码</strong>；</p>
</li>
<li><p>加载时，生成<strong>绝对地址</strong></p>
</li>
</ul>
</li>
<li><p>执行时</p>
<ul>
<li>执行时代码可移动</li>
<li>需要地址转换（映射）硬件支持</li>
</ul>
</li>
</ul>
<h4 id="连续内存分配"><a href="#连续内存分配" class="headerlink" title="连续内存分配"></a>连续内存分配</h4><p>给进程分配一块不小于指定大小的连续的物理内存区域</p>
<ul>
<li>内存碎片， 空闲内存<strong>不能被利用</strong><ul>
<li>外部碎片，分配单元<strong>之间</strong>的未被使用内存</li>
<li>内部碎片，分配单元<strong>之内</strong>的未被使用内存，取决于<strong>分配单元大小是否要取整</strong></li>
</ul>
</li>
</ul>
<h4 id="动态分区的分配策略"><a href="#动态分区的分配策略" class="headerlink" title="动态分区的分配策略"></a>动态分区的分配策略</h4><ul>
<li><p>最先匹配(First Fit Allocation)，分配 n 个字节，使用第一个可用的空间比 n 大的空闲块</p>
<p><strong>原理/实现</strong></p>
<ul>
<li>空闲分区列表按 地址顺序排序</li>
<li>分配过程时，搜索一个合适的分区</li>
<li>释放分区时，检查是否可与<strong>临近的空闲分区合并</strong></li>
</ul>
<p><strong>优、缺点</strong></p>
<ul>
<li>简单、在<strong>高地址</strong>空间有大块的空闲分区</li>
<li>外部碎片，分配大块时较慢</li>
</ul>
</li>
<li><p>最佳匹配(Best Fit Allocation), 分配 n 个字节，查找并使用不小于 n 的最小空闲分区</p>
<p><strong>原理/实现</strong></p>
<ul>
<li>空闲分区列表<strong>按大小排序</strong></li>
<li>分配时，查找合适分区</li>
<li>释放时，查找并合并临近的空闲分区</li>
</ul>
<p><strong>优缺点</strong></p>
<ul>
<li>大部分分配的<strong>尺寸较小</strong>时，效果很好； 可<strong>避免大的空闲分区被拆分</strong>；可减小外部碎片的大小</li>
<li>产生外部碎片，<strong>释放分区较慢</strong>，容易产生<strong>很多无用的小碎片</strong></li>
</ul>
</li>
<li><p>最差匹配(Worst Fit Allocation)， 分配 n 个字节，使用尺寸不小于 n 的<strong>最大空闲分区</strong></p>
<p><strong>原理/实现</strong></p>
<ul>
<li>空闲分区列表按<strong>由大到小排序</strong></li>
<li>分配时，选最大的分区</li>
<li>释放时，检查是否可与临近的空闲分区合并，并<strong>调整空闲分区列表顺序</strong></li>
</ul>
<p><strong>优缺点</strong></p>
<ul>
<li><strong>中等大小的分配较多</strong>时，效果最好， 避免出现太多的小碎片</li>
<li>释放分区慢，产生外部碎片，<strong>容易破坏大的空闲分区</strong>，导致后续难以分配大的分区</li>
</ul>
</li>
</ul>
<h4 id="碎片整理"><a href="#碎片整理" class="headerlink" title="碎片整理"></a>碎片整理</h4><p>通过调整进程占用的分区位置来减少/避免分区碎片</p>
<ul>
<li>碎片紧凑(compaction)<ul>
<li>通过移动分配给进程的内存分区，以合并外部碎片</li>
<li><strong>条件：</strong> 所有的应用程序可<strong>动态重定位</strong></li>
<li><strong>问题：</strong>， 何时移动？ 开销？</li>
</ul>
</li>
<li>分区对换(swapping in/out),<ul>
<li>通过<strong>抢占并回收</strong>处于<strong>等待状态</strong>进程的分区，以增大可用内存空间</li>
<li><strong>问题：</strong>换哪个程序？开销？</li>
</ul>
</li>
</ul>
<h2 id="内存管理-物理内存-非连续分配"><a href="#内存管理-物理内存-非连续分配" class="headerlink" title="内存管理(物理内存) - 非连续分配"></a>内存管理(物理内存) - 非连续分配</h2><h5 id="连续分配有缺点"><a href="#连续分配有缺点" class="headerlink" title="连续分配有缺点"></a>连续分配有缺点</h5><ul>
<li>分配给程序的物理内存必须连续</li>
<li>存在碎片(外部、内部)</li>
<li>内存分配的动态修改困难</li>
<li>内存利用率教低</li>
</ul>
<h4 id="非连续分配"><a href="#非连续分配" class="headerlink" title="非连续分配"></a><strong>非连续分配</strong></h4><p>分配给一个程序的物理空间是非连续，提高内存利用效率和管理灵活性</p>
<p><strong>优点</strong></p>
<ul>
<li>允许共享代码和数据</li>
<li>支持<strong>动态加载</strong>和<strong>动态链接</strong></li>
</ul>
<p><strong>缺点</strong></p>
<ul>
<li>有额外的管理开销， 要建立<strong>虚拟地址和物理地址之间的转换</strong></li>
</ul>
<h5 id="如何实现虚拟地址和物理地址的转换？"><a href="#如何实现虚拟地址和物理地址的转换？" class="headerlink" title="如何实现虚拟地址和物理地址的转换？"></a>如何实现虚拟地址和物理地址的转换？</h5><ul>
<li>软件实现(灵活、开销大)</li>
<li>硬件实现(够用，开销小)</li>
</ul>
<h4 id="段式存储管理"><a href="#段式存储管理" class="headerlink" title="段式存储管理"></a>段式存储管理</h4><p><strong>段的概念</strong></p>
<ul>
<li>表示访问方式和存储数据等<strong>属性相同</strong>的一段地址空间</li>
<li>其对应一个连续的内存块</li>
<li>若干个段组成进程逻辑地址空间</li>
</ul>
<p><strong>段访问</strong></p>
<ul>
<li><p><strong>段基址 + 段内偏移</strong></p>
</li>
<li><p>逻辑地址由二元组(s, addr)表示， s 段号， addr，段内偏移</p>
</li>
</ul>
<h4 id="页式存储管理"><a href="#页式存储管理" class="headerlink" title="页式存储管理"></a>页式存储管理</h4><p><strong>页帧（帧、物理页面 Frame）</strong></p>
<ul>
<li>将<strong>物理地址空间</strong>划分为大小相同的基本分配空间单位</li>
<li>2 的 n 次方，如 512，4096</li>
<li>内存物理地址的表示，二元组(f,o) = f * 2^S + o<ul>
<li>f, 帧号，F 位，共有 2^F 个 帧</li>
<li>o，帧内偏移，S 位， 每帧有 2^S 字节</li>
</ul>
</li>
</ul>
<p><strong>页面（页、逻辑页面 Page）</strong></p>
<ul>
<li><p>将<strong>逻辑地址空间</strong>也划分为相同大小的基本分配单位</p>
</li>
<li><p>帧、页 <strong>大小必须是相同</strong>的</p>
</li>
<li><p>进程中的逻辑地址的表示，二元组(p,o) = p*2^S + o</p>
<ul>
<li>p ,页号 (P 位， 2^P 个页)</li>
<li>o, 页内偏移(S 位， 每页有 2^S 字节)</li>
</ul>
</li>
</ul>
<p><strong>页到帧的转换 （地址映射）</strong></p>
<ul>
<li><p>逻辑地址到物理地址的转换</p>
</li>
<li><p><strong>页表</strong>， 保存了逻辑地址到物理地址之间的映射关系</p>
</li>
<li><p>MMU、TLB</p>
</li>
<li><p><strong>逻辑地址中的页号 是连续的，物理地址中的帧号是不连续的</strong></p>
</li>
<li><p>不是所有的页都有对应的帧，<strong>缺页</strong></p>
<p><strong>具体过程</strong>： 首先 CPU 得到逻辑地址，逻辑地址分块，一块表示页号，一块表示页内偏移。通过查找<strong>页表</strong>，页表的<strong>索引就是页号，内容是帧号</strong>。<strong>帧号+偏移</strong>，就是物理地址，找到对应的内存空间</p>
</li>
</ul>
<h5 id="页表"><a href="#页表" class="headerlink" title="页表"></a><strong>页表</strong></h5><p><img src="/image/page_table.png" alt="页表"></p>
<p><strong>每个进程都有一个页表</strong></p>
<ul>
<li><p>每个页表对应一个<strong>页表项</strong></p>
<ul>
<li>页表项标志<ul>
<li>存在位 (resident bit)</li>
<li>修改位 (dirty bit)</li>
<li>引用位 (clock/reference bit)</li>
</ul>
</li>
</ul>
</li>
<li><p>其随进程运行状态而<strong>动态变化</strong></p>
</li>
<li><p>页表基址寄存器(PTBR， Page Table Base Register)</p>
</li>
</ul>
<p><strong>页式存储管理机制的性能问题</strong></p>
<ul>
<li>内存访问性能， 访问一个内存单元需要 2 次内存访问<ul>
<li>第一次，获取页表项</li>
<li>第二次，访问数据</li>
</ul>
</li>
<li>页表 大 小 ，可能非常大</li>
<li>如何 处理？ <strong>缓存、间接访问</strong></li>
</ul>
<h5 id="快表-TLB，Translation-Look-aside-Buffer"><a href="#快表-TLB，Translation-Look-aside-Buffer" class="headerlink" title="快表(TLB，Translation Look-aside Buffer)"></a>快表(TLB，Translation Look-aside Buffer)</h5><p>快表是一种高速缓冲存储器，<strong>用缓冲近期访问的页表项</strong></p>
<p><strong>过程</strong></p>
<ul>
<li>根据逻辑地址推算出目标页表项的索引，查询快表<ul>
<li>若命中，则结合逻辑地址的低若干位推算出最终物理地址</li>
<li>若没有命中，则去查页表并更新对应的页表项到 TLB 中</li>
<li>当 TBL 被写满又有新的页表项要写进来，则按照策略擦除快表中的一个旧页表项</li>
</ul>
</li>
</ul>
<h5 id="间接访问，多级页表"><a href="#间接访问，多级页表" class="headerlink" title="间接访问，多级页表"></a>间接访问，多级页表</h5><p>通过间接引用将页号分成 k 级，使等将对一个大地址范围的寻址分为对几个小的页表的寻址</p>
<p><strong>优点：可离散存储</strong>，进程中未使用的页暂存时可以不用为其建立页表，只有在进程实际需要一个页表时才给该页表分配内存</p>
<p><img src="/image/indrection_page.png" alt="多级页表"></p>
<h5 id="大地址空间问题？"><a href="#大地址空间问题？" class="headerlink" title="大地址空间问题？"></a>大地址空间问题？</h5><p>逻辑地址空间增长速度快于物理地址空间</p>
<p><strong>思路</strong>， 不让页表与逻辑地址空间的大小相对应，让页表与物理地址空间的大小相对于</p>
<ul>
<li><p><strong>页寄存器(Page Registers)</strong></p>
<p>每个帧 与 一个 页寄存器 管理，寄存器内容包括:</p>
<ul>
<li>使用位， 此帧是否 被 进程占用</li>
<li>占用页号，对应的页号 p</li>
<li>保护位</li>
</ul>
<p><strong>示例</strong></p>
<p>物理内存大小： 4096 _ 4096 = 4K_ 4K = 16 MB</p>
<p>页面大小： 4096 bytes = 4KB</p>
<p>页帧数： 4096</p>
<p>页寄存器使用的空间(假设每个页寄存器占 8 字节)： 8 * 4096 = 32KB</p>
<p>则页寄存器带来的开销： 32K/16M = 0.2%</p>
<p>虚拟内存的大小： 任意</p>
<p><strong>优点</strong>， 本身物理存址小，节省空间，不再是每个进程都要页表，整个系统只用 一个</p>
<p><strong>缺点，</strong> 需求高，需要软硬件配合，有冲突</p>
</li>
<li><p><strong>反置页面</strong></p>
<p>基于 HASH 映射值查找对应页表项中的帧号</p>
</li>
</ul>
<h4 id="段页式存储管理"><a href="#段页式存储管理" class="headerlink" title="段页式存储管理"></a>段页式存储管理</h4><p>在端式存储的基础上，给每个段 加 一级页表</p>
<p><strong>逻辑地址：</strong> 段号 + 若各个页号 + 页内偏移</p>
<p><strong>物理地址</strong>：帧号 + 页内偏移</p>
<p><strong>内存共享</strong>，通过指向相同的页表基址，实现进程间的端共享</p>
<p><img src="/image/segment_page.png" alt="断页式存储管理"></p>
<h2 id="虚拟存储"><a href="#虚拟存储" class="headerlink" title="虚拟存储"></a>虚拟存储</h2><h4 id="覆盖技术"><a href="#覆盖技术" class="headerlink" title="覆盖技术"></a>覆盖技术</h4><p>在较小的可用内存中运行较大的程序</p>
<ul>
<li>依据程序逻辑结构，将程序划分为若干<strong>功能相对独立的模块</strong></li>
<li>将不会同时执行的模块<strong>共享同一块内存</strong>区域</li>
<li>必要、常用功能的代码和数据 常驻内存</li>
<li>可选，不常用功能，只在需要时装入 内存</li>
<li>不存在调用关系的模块 可相互 覆盖，共用同一块内存区域</li>
</ul>
<h4 id="交互技术"><a href="#交互技术" class="headerlink" title="交互技术"></a>交互技术</h4><p>增加正在运行或需要运行的程序的内存</p>
<ul>
<li><p>将暂时不用运行的程序放到外存</p>
</li>
<li><p>换入换成的基本单位，<strong>整个进程的地址空间</strong></p>
</li>
</ul>
<h4 id="局部性原理"><a href="#局部性原理" class="headerlink" title="局部性原理"></a>局部性原理</h4><p>程序在执行过程的一个较短时期，所执行的指令的地址，指令的操作数地址都局限于一定区域；</p>
<p>存在<strong>时间、空间、分支</strong>局限性；</p>
<p><strong>局部性原理的意义</strong>：该原理表明 理论上虚拟存储技术是可以实现的</p>
<h4 id="虚拟存储技术"><a href="#虚拟存储技术" class="headerlink" title="虚拟存储技术"></a>虚拟存储技术</h4><p><strong>物理内存+ 磁盘 = 虚拟存储</strong></p>
<ul>
<li>只把部分程序放到内存中，从而运行比物理内存大的程序，有操作系统自动完成</li>
<li>实现进程在内存和外外存直接的交换，从而获得更多的空闲内存空间</li>
</ul>
<p><strong>原理：</strong></p>
<ul>
<li>在装入程序时，只把当前指令执行需要的部分页、段装入内存</li>
<li>当执行到指令或数据不存在时(<strong>缺页、缺段异常</strong>)，处理器通知操作系统将<strong>相应的页、段调入内存</strong></li>
<li>操作系统将内存中暂时不用的页、端保存到<strong>外存</strong></li>
</ul>
<p><strong>实现方式：</strong></p>
<ul>
<li>虚拟页式存储</li>
<li>虚拟段式存储</li>
</ul>
<p><strong>基本特征：</strong></p>
<ul>
<li>不连续性<ul>
<li><strong>物理内存 分配 非连续</strong></li>
<li>虚拟地址空间 使用 非连续</li>
</ul>
</li>
<li>大用户空间， 提供给用户的虚拟内存 可 大于 时间的物理内存</li>
<li>部分交换，只对<strong>部分虚拟地址空间</strong>进行 调入 和 调出</li>
</ul>
<p><strong>技术支持：</strong></p>
<ul>
<li>硬件，页式或短时存储中 <strong>地址转换机制</strong></li>
<li>操作系统，管理内存和外存 间 页、端的换入、换出</li>
</ul>
<h5 id="虚拟页式存储管理"><a href="#虚拟页式存储管理" class="headerlink" title="虚拟页式存储管理"></a>虚拟页式存储管理</h5><p>在页式存储管理的基础上，增加 <strong>请求调页</strong> 、<strong>页面置换</strong></p>
<p><strong>思路</strong></p>
<ul>
<li>当用户程序要装载到内存运行时，<strong>只装入部分页面</strong>，就启动程序运行</li>
<li>进程在运行中发现有需要的代码或数据不在内存时，想系统发出<strong>缺页异常请求</strong></li>
<li>操作系统在处理缺页异常时，将外存中相应的页面调入内存，使得进程能继续运行</li>
</ul>
<p><img src="/image/virtual_memory.png" alt="虚拟页式存储管理"></p>
<h5 id="虚拟页式存储中-页表项-结构"><a href="#虚拟页式存储中-页表项-结构" class="headerlink" title="虚拟页式存储中 页表项 结构"></a>虚拟页式存储中 页表项 结构</h5><p><img src="/image/page_item.png" alt="虚拟页式存储中 页表项 结构"></p>
<p><strong>驻留位</strong>： 表示该页面是否在内存； 1 在 内存，0 在外存，访问时缺页异常</p>
<p><strong>修改位：</strong> 表示在内存中的该页是否被修改过； 回收物理页面时据此决定是否把内容写会外存</p>
<p><strong>访问位：</strong>表示该页面是否被访问过(读、写)，被访问过设置为 1</p>
<p><strong>保护位：</strong>表示该页面的允许访问方式，只读、可读写、可执行等</p>
<h5 id="缺页异常的处理流程"><a href="#缺页异常的处理流程" class="headerlink" title="缺页异常的处理流程"></a>缺页异常的处理流程</h5><p><img src="/image/page_missing_execption.png" alt="缺页异常处理流程"></p>
<p>1、如果在内存中有空闲的物理空间，则分配一个物理页帧 f，然后转至 5，否则 2</p>
<p>2、采用某种页面置换算法，选择一个被替换的物理页帧，其对应的逻辑页为 q，（<strong>如果没修改过可直接释放，如果修改位是 1，则要写会外存）</strong></p>
<p>3、如果 q 被修改过，则把它写回外存</p>
<p>4、把 q 对应页面驻留位设置为 0</p>
<p>5、把需要访问的页面 p 装入物理页面 f 中</p>
<p>6、修改 p 对应页表项，驻留位设置 1，物理页帧设置为 f</p>
<p>7、重新执行产生缺页的指令</p>
<h2 id="页面置换算法"><a href="#页面置换算法" class="headerlink" title="页面置换算法"></a>页面置换算法</h2><p>当出现<strong>缺页异常</strong>，需要调入新的页面而<strong>内存已满</strong>时，置换算法选择被置换的<strong>物理页面</strong></p>
<p><strong>目标：</strong></p>
<ul>
<li>尽可能减少页面的调入调出次数</li>
<li>把未来不再访问或短期内不访问的页面调出</li>
</ul>
<p><strong>页面锁定（frame locking）</strong></p>
<ul>
<li>描述 必须 常驻内存的逻辑页面</li>
<li>操作系统的关键部分</li>
<li>要求响应速度的代码和数据</li>
<li>页表中的锁定标志位</li>
</ul>
<h4 id="局部页面置换算法"><a href="#局部页面置换算法" class="headerlink" title="局部页面置换算法"></a>局部页面置换算法</h4><p>置换页面的选择范围 仅限于 <strong>当前进程占用的物理页面内</strong></p>
<ul>
<li>最优页面置换算法(OPT)<ul>
<li><strong>思路</strong>：未来最长时间不访问的页面 作为置换页面</li>
<li><strong>实现：</strong> 缺页时，计算内存中每个逻辑页面的下一次访问时间，选择未来最长时间不访问的页面</li>
<li><strong>特征：</strong> 理想情况，OS 无法实现</li>
</ul>
</li>
<li>先进先出算法(FIFO)<ul>
<li><strong>思路：</strong> 选择在内存驻留时间最长的页面进行置换</li>
<li><strong>实现：</strong> 维护一个记录所有位于内存中的逻辑页面，链表元素按<strong>驻留内存的时间排序</strong>，链首最长，链尾最短；出现缺页时，置换链首页面，新页面添加值链尾</li>
<li><strong>特征：</strong> 性能差，调出的页面可能是常用页面； <strong>出现 Belady 现象</strong></li>
</ul>
</li>
<li>最近最久未使用算法(LRU)<ul>
<li><strong>思路：</strong> 选择最长时间没被引用的页面进行置换；如果某些页面长时间未被访问，则它在将来还可能长时间不会访问</li>
<li><strong>实现：</strong><ul>
<li>维护一个按最近一次访问时间排序的链表，链首是最近刚刚访问的页面，链尾是最久为使用的页面</li>
<li>访问内存时，找到相应页面，并把它移到链首</li>
<li>缺页时，置换链表尾节点的页面</li>
</ul>
</li>
<li><strong>特征：</strong> 最优置换算法的一种 <strong>近似</strong>， 开销比较大</li>
</ul>
</li>
<li>时钟页面置换算法(Clock)<ul>
<li><strong>思路：</strong> 仅对页面的访问情况进行大致统计； 在页表项增加 <strong>访问位</strong>，描述页面在过去一段时间的内存访问情况</li>
<li><strong>实现：</strong><ul>
<li>各页面组成<strong>环形链表</strong>，指针指向<strong>最先调入的页面</strong></li>
<li>访问页面时，在页表项纪录页面访问情况， 访问位 1 (初始时 0)</li>
<li>缺页时，从指针处开始顺序查找 未被访问的页面进行置换<ul>
<li>从指针当前位置顺序检查环形链表</li>
<li>访问位 为 0 ， 则置换该页面</li>
<li>访问位 为 1，则 置为 0，指针移动到下一个页面，直到找到可置换的页面 ∫</li>
</ul>
</li>
</ul>
</li>
<li><strong>特征：</strong> 是 LRU 和 FIFO 的折中</li>
</ul>
</li>
<li>最不常用算法(LFU)<ul>
<li><strong>思路：</strong>选择页面访问次数最少的页面</li>
<li><strong>实现：</strong> 对每个页面设置访问计数器，当一个页面被访问+1,置换数值最小的页面</li>
<li><strong>特征：</strong> 开销，硬盘计数器开销，排序查找开销</li>
</ul>
</li>
</ul>
<h5 id="Belady-现象"><a href="#Belady-现象" class="headerlink" title="Belady 现象"></a>Belady 现象</h5><p>采用 FIFO 算法时，可能出现分配的物理页面增加，缺页次数反而升高的异常现象</p>
<h5 id="LRU、FIFO、CLock-算法比较"><a href="#LRU、FIFO、CLock-算法比较" class="headerlink" title="LRU、FIFO、CLock 算法比较"></a>LRU、FIFO、CLock 算法比较</h5><ul>
<li>LRU 和 FIFO 本质上都是<strong>先进先出的思路</strong><ul>
<li>LRU 依据 页面的 最近访问时间排序， <strong>需要动态的调整顺序</strong></li>
<li>FIFO 依据 页面 进入 内存的时间排序，<strong>是固定不变的</strong></li>
</ul>
</li>
<li><strong>LRU 可 退化 成 FIFO</strong>， 页面进入内存后没被访问，最近访问时间 与 进入内存的时间 相同</li>
<li>LRU 算法性能较好，但系统开销大</li>
<li>FIFO 系统开销较小，但会发生 <strong>Belady 现象</strong></li>
<li>Clock 是它们的折中<ul>
<li>页面访问时，不动态调整页面的在链表中的顺序，仅做标记</li>
<li>缺页时，再把它移动到链表末尾</li>
<li>对应 未被访问的页面，Clock 和 LRU 算法表现的一样好</li>
<li>对于被 访问过的页面，Clock 算法 不能记录 准确访问顺序，而 LRU 算法可以</li>
</ul>
</li>
</ul>
<h4 id="全局页面置换算法"><a href="#全局页面置换算法" class="headerlink" title="全局页面置换算法"></a>全局页面置换算法</h4><p>置换页面的选择范围 是 <strong>所有可换出的 物理页面</strong></p>
<p><strong>进程在不同阶段的内存需求是变化的，分配给进程的内存也需要在不同阶段有所变化</strong></p>
<ul>
<li><p>工作集算法</p>
<ul>
<li><strong>思路：</strong> 换出不在工作集中的页面</li>
<li><strong>实现：</strong><ul>
<li>访问链表，维护窗口内的访存页面链表</li>
<li>在防存时，换出不在工作集的页面，缺页时，换入页面，更新访存链表</li>
</ul>
</li>
</ul>
<h5 id="工作集"><a href="#工作集" class="headerlink" title="工作集"></a>工作集</h5><p>一个进程当前使用的逻辑页面集合，用二元函数 w(t,Δ)，t 是当前时刻，Δ 是工作集窗口，一个定长的页面访问的时间窗口。t+Δ 构成一个时间段，w(t,Δ)就是在当前时刻 t 之前的 Δ 时间内所有访问页面组成的集合，在随 t 不断更新。</p>
<p>在进程开始后，随着访问新页面逐步建立起<strong>较稳定的工作集</strong></p>
<h5 id="常驻集"><a href="#常驻集" class="headerlink" title="常驻集"></a>常驻集</h5><p>在当前时刻，进程实际驻留在内存当中的页面集合</p>
</li>
<li><p>缺页率算法</p>
<p><strong>缺页率：</strong> 缺页次数/内存访问次数= 1/缺页的平均时间间隔</p>
<ul>
<li><strong>思路：</strong> 动态调整常驻集的大小； 若缺页率高则增加工作集来分配更多的物理页面，过低则减少工作集来减少其物理页面。</li>
</ul>
</li>
</ul>
<h4 id="抖动和负载控制"><a href="#抖动和负载控制" class="headerlink" title="抖动和负载控制"></a>抖动和负载控制</h4><p><strong>抖动：</strong>如果分配给一个进程的物理页面太少，常驻集远小于工作集，则缺页率很大，频繁在内外存之间替换页面，使进程的运行慢，此状态为”抖动”</p>
<p><strong>产生抖动原因：</strong> 随着驻留内存的进程数目增加，分配给每个进程的物理页面数据不断减少，缺页率上升。因此 OS 要选择一个适当的进程数目和进程需要的帧数，在并发和缺页率之间达到平衡。</p>
<p><strong>负载控制：</strong> 通过调节并发进程数来进行系统负载控制。<strong>平均缺页间隔时间 = 缺页异常处理时间</strong></p>
<h2 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h2><h5 id="进程定义"><a href="#进程定义" class="headerlink" title="进程定义"></a>进程定义</h5><p>一个具有一定<strong>独立功能</strong>的程序在一个<strong>数据集合</strong>上的一次<strong>动态执行过程</strong></p>
<p>只有当一个程序被 OS 加载到内存中，cpu 对其执行时，这个过程是动态的，称为进程</p>
<h5 id="进程的组成"><a href="#进程的组成" class="headerlink" title="进程的组成"></a>进程的组成</h5><p>进程包含了正在运行的一个程序的<strong>所有状态信息</strong></p>
<ul>
<li>代码</li>
<li>数据</li>
<li>状态寄存器</li>
<li>通用寄存器</li>
<li>进程占用系统资源</li>
</ul>
<h5 id="进程特点"><a href="#进程特点" class="headerlink" title="进程特点"></a>进程特点</h5><ul>
<li>动态性，动态的创建、结束进程</li>
<li>并发性，可并独立调用并占用处理机运行</li>
<li>独立性，不同进程的工作相互独立</li>
<li>制约性，因访问共享数据、资源，或进程间同步 而产生制约</li>
</ul>
<h5 id="进程与程序的联系"><a href="#进程与程序的联系" class="headerlink" title="进程与程序的联系"></a>进程与程序的联系</h5><ul>
<li>进程是操作系统处于<strong>执行状态程序的抽象</strong></li>
<li><strong>进程 = 执行中的程序 = 程序(静态文件) + 执行状态</strong></li>
<li>同一个程序的多次执行过程对应不同进程</li>
<li>进程执行需要资源，内存（保存代码、数据），CPU(执行指令)</li>
</ul>
<h5 id="进程控制块-PCB，Process-Control-Block"><a href="#进程控制块-PCB，Process-Control-Block" class="headerlink" title="进程控制块 (PCB，Process Control Block)"></a>进程控制块 (PCB，Process Control Block)</h5><ul>
<li>操作系统管理控制进程运行所用的<strong>信息集合</strong><ul>
<li>操作系统用 PCB 来描述 进程的<strong>基本情况</strong> 以及 <strong>运行变化的过程</strong></li>
<li>PCB 是 <strong>进程存在的唯一标志</strong></li>
</ul>
</li>
</ul>
<p><strong>PCB 三大类信息</strong></p>
<ul>
<li><strong>进程标识</strong>，本进程标识、父进程标识、用户标识</li>
<li><strong>处理机状态保存</strong>，保存进程的<strong>现场信息</strong>，主要是寄存器</li>
<li><strong>进程控制信息</strong><ul>
<li>调度和状态信息，调度进程、处理机使用情况</li>
<li>进程间通信信息，通信相关的各种标识、信号</li>
<li>存储管理信息，指向本<strong>进程映像</strong>存储空间的数据结构，内存信息</li>
<li>进程所用资源， 打开使用的系统资源</li>
<li>有关数据结构连接信息，与<strong>PCB 相关的进程队列</strong></li>
</ul>
</li>
</ul>
<h5 id="PCB-组织方式"><a href="#PCB-组织方式" class="headerlink" title="PCB 组织方式"></a>PCB 组织方式</h5><ul>
<li>链表，同一状态的进程其 PCB 成一链表，多个状态对应多个不同的链表；如 就绪链表、阻塞链表</li>
<li>索引表，同一状态的进程归入一个索引表(由索引执行 PCB)，多个状态对应多个不同的索引表</li>
</ul>
<h5 id="进程生命周期"><a href="#进程生命周期" class="headerlink" title="进程生命周期"></a>进程生命周期</h5><ul>
<li><p>创建</p>
<p><strong>引起进程创建情况</strong></p>
<ul>
<li>系统初始化</li>
<li>用户请求创建一个新进程</li>
<li>正在运行的进程执行了<strong>创建进程的系统调用</strong></li>
</ul>
</li>
<li><p>执行</p>
<p>内核选择一个<strong>就绪的</strong>进程，让它<strong>占用处理机并执行</strong></p>
</li>
<li><p>等待</p>
<p><strong>进入等待的情况</strong></p>
<ul>
<li>请求并等待系统服务，无法马上完成</li>
<li>启动某种操作，无法马上完成</li>
<li>需要的数据没有到达</li>
</ul>
</li>
<li><p>抢占</p>
<p><strong>进程抢占的情况</strong></p>
<ul>
<li>高优先级进程就绪</li>
<li>进程执行当前时间用完</li>
</ul>
</li>
<li><p>唤醒</p>
<p><strong>唤醒进程情况</strong></p>
<ul>
<li>被阻塞进程需要的资源被满足</li>
<li>被阻塞进程等待的事件到达</li>
</ul>
<p><strong>进程只能被别的进程或操作系统唤醒</strong></p>
</li>
<li><p>结束</p>
<p><strong>进程结束情况</strong></p>
<ul>
<li>正常退出</li>
<li>错误退出</li>
<li>致命错误</li>
<li>被其他进程杀死</li>
</ul>
</li>
</ul>
<h5 id="进程挂起"><a href="#进程挂起" class="headerlink" title="进程挂起"></a>进程挂起</h5><p>处于挂起状态的进程<strong>映像在磁盘</strong>上，以减少进程占用的内存</p>
<p><img src="/image/process_suspend.png" alt="进程挂起"></p>
<p><strong>挂起状态</strong></p>
<ul>
<li>等待挂起状态(Blocked-suspend)，进程在外存 并<strong>等待某事件的出现</strong></li>
<li>就绪挂起状态(Ready-suspendReady-suspend)，进程在外存，但只要进入内存即可运行</li>
</ul>
<p><strong>挂起状态转换</strong></p>
<ul>
<li>从内存转到外存<ul>
<li>等待 -&gt; 等待挂起， 没有进程处于就绪状态，或就绪进程 要求更多内存资源</li>
<li>就绪 -&gt; 就绪挂起，当有高优先级等待进程（系统认为会很快就绪的）和低优先级就绪进程</li>
<li>运行 -&gt; 就绪挂起，对抢占式分时系统，当有高优先级等待挂起进程因事件出现而进入就绪挂起</li>
</ul>
</li>
<li>在外存时的状态转换<ul>
<li>等待挂起 -&gt; 就绪挂起， 有等待挂起进程 因相关事件出现</li>
<li>激活， 外存到内存，需要运行该进程时</li>
<li>就绪挂起 -&gt; 就绪，没有就绪进程，或 挂起就绪进程高于 就绪进程</li>
<li>等待挂起 -&gt; 等待， 当一个进程释放足够内存，并有高优先级等待挂起进程</li>
</ul>
</li>
</ul>
<h5 id="状态队列"><a href="#状态队列" class="headerlink" title="状态队列"></a>状态队列</h5><p>由操作系统维护一组队列，表示系统中所有进程的当前状态</p>
<p>不同队列表示不同状态</p>
<h2 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h2><h4 id="线程概念"><a href="#线程概念" class="headerlink" title="线程概念"></a>线程概念</h4><p>线程是进程的一部分，描述<strong>指令流 执行状态</strong>。它是进程中的<strong>指令执行流 的最小单元</strong>，是<strong>CPU 调度的基本单位</strong></p>
<p><strong>线程 = 进程 - 共享资源</strong></p>
<h4 id="线程优缺点"><a href="#线程优缺点" class="headerlink" title="线程优缺点"></a>线程优缺点</h4><ul>
<li>一个进程中可<strong>同时存在多个线程</strong></li>
<li>各个线程之间可以<strong>并发执行</strong></li>
<li>各个线程之间可共享<strong>地址空间和文件</strong>等资源</li>
<li><strong>一个线程崩溃，会导致其所属进程的所有线程崩溃</strong></li>
</ul>
<h4 id="线程、进程-比较"><a href="#线程、进程-比较" class="headerlink" title="线程、进程 比较"></a>线程、进程 比较</h4><ul>
<li>进程是资源分配单位，线程是 CPU 调度单位</li>
<li>进程拥有一个完整的资源平台，线程只独享指令流执行的必要资源，如寄存器、栈</li>
<li>线程能减少并发执行的时间（切换时间短，能直接通信）和空间开销(共享内存和文件资源)</li>
</ul>
<h2 id="进程控制"><a href="#进程控制" class="headerlink" title="进程控制"></a>进程控制</h2><h4 id="进程切换-上下文切换"><a href="#进程切换-上下文切换" class="headerlink" title="进程切换(上下文切换)"></a>进程切换(上下文切换)</h4><h5 id="切换时机"><a href="#切换时机" class="headerlink" title="切换时机"></a>切换时机</h5><ul>
<li>暂停当前运行状态，从<strong>运行</strong>状态变成其他状态</li>
<li>调度另一个进程，从<strong>就绪</strong>状态变成<strong>运行</strong>状态</li>
</ul>
<h5 id="进程切换要求"><a href="#进程切换要求" class="headerlink" title="进程切换要求"></a>进程切换要求</h5><ul>
<li>切换前，保存进程上下文</li>
<li>切换后，恢复进程上下文</li>
<li>要快速切换</li>
<li>保存进程生命周期信息(寄存器、CPU 状态、内存地址空间)</li>
</ul>
<h5 id="进程控制块-PCB"><a href="#进程控制块-PCB" class="headerlink" title="进程控制块 PCB"></a>进程控制块 PCB</h5><ul>
<li>内核为每个进程维护了对应的进程控制块(PCB)</li>
<li>相同状态的进程的 PCB 放置在同一队列</li>
</ul>
<h4 id="进程创建-fork-exec"><a href="#进程创建-fork-exec" class="headerlink" title="进程创建 (fork/exec)"></a>进程创建 (fork/exec)</h4><ul>
<li>fork() 复制一个进程，复制父进程信息，创建一个新的子进程。<ul>
<li>复制父进程所有变量和内存</li>
<li>复制父进程的所有 CPU 寄存器</li>
<li>子进程的 fork()返回 0</li>
<li>父进程的 fork()返回进程标识符</li>
<li>子进程使用 getpid()获取 PID</li>
</ul>
</li>
<li>exec() 加载 <strong>新程序</strong>取代当前运行进程</li>
</ul>
<h4 id="进程等待和退出"><a href="#进程等待和退出" class="headerlink" title="进程等待和退出"></a>进程等待和退出</h4><ul>
<li><p>wait() 用于 父进程等待子进程的结束</p>
<ul>
<li>子进程 结束 时通过 exit()向父进程返回一个值，父进程通过 wait()接受并处理这个值</li>
<li>有<strong>子进程存活</strong>时，父进程进入等待状态，等待子进程的返回结果；当子进程调用 exit()时，<strong>唤醒</strong>父进程，将 exit()返回值作为父进程中的 wait()调用的返回值()</li>
<li>有僵尸子进程等待时，wait()立即返回其中一个值</li>
<li>无子进程存活时，wait()立即返回</li>
</ul>
</li>
<li><p>exit(),进程的<strong>有序终止</strong></p>
<ul>
<li>将调用才是作为 进程的”结果”</li>
<li>关闭所有打开的文件等占用资源</li>
<li>释放内存</li>
<li>释放大部分 进程相关的内核数据结构</li>
<li>检查父进程是非存活<ul>
<li>存活，保留结果的值 直到 父进程需要它，进入僵尸（zombie）状态</li>
<li>没有，释放所有的数据结构，进程结束</li>
</ul>
</li>
<li>清理所有等待的僵尸进程</li>
</ul>
</li>
</ul>
<h2 id="处理机调度"><a href="#处理机调度" class="headerlink" title="处理机调度"></a>处理机调度</h2><ul>
<li><strong>进程切换</strong>，切换 CPU 的当前任务，从一个进程/线程到另一个，保存当前在 PCB/TCB 中的执行上下文，读取下一个的上下文</li>
<li><strong>CPU 调度</strong>，从就绪队列中挑选一个进程/线程作为 CPU 将要运行的下一个进程/线程</li>
</ul>
<h4 id="调度准则"><a href="#调度准则" class="headerlink" title="调度准则"></a>调度准则</h4><ul>
<li>CPU 使用率： CPU 处于忙状态的时间百分比</li>
<li>吞吐量：单位时间内完成的<strong>进程数量</strong></li>
<li>周转时间：进程从初始化到结束的总时间</li>
<li>等待时间：进程在<strong>就绪队列</strong>中的总时间</li>
<li>响应时间：从<strong>提交请求到产生响应</strong>所花费的总时间</li>
</ul>
<h4 id="调度算法"><a href="#调度算法" class="headerlink" title="调度算法"></a>调度算法</h4><ul>
<li><p>先来先服务（FCFS，First Come，First Served)，依据进程<strong>进入就绪状态的先后顺序</strong></p>
<ul>
<li>优点，简单</li>
<li>缺点<ul>
<li>平均等待时间波动大，<strong>短进程可能排在长进程后面</strong></li>
<li>I/O 资源和 CPU 资源利用率低，CPU 密集型进程导致 I/O 设备闲置，反之亦然</li>
</ul>
</li>
</ul>
</li>
<li><p>短进程优先，选择就绪队列中<strong>执行时间最短进程</strong> 占用 CPU 进入运行状态</p>
<ul>
<li>SPN，Shortest Process Next (短进程)，</li>
<li>SJF，Shortest Job First (短作业)</li>
<li>SRT，Shortest Remaining Time (短剩余时间)</li>
<li>优点： 具有<strong>最优平均周转时间</strong></li>
<li>缺点：<ul>
<li>可能导致饥饿，<strong>连续的短进程会使长进程无法获得 CPU 资源</strong></li>
<li><strong>需要预知未来</strong>，预估 CPU 使用的时间</li>
</ul>
</li>
</ul>
</li>
<li><p>最高响应比优先 (HRRN，Highest Response Ratio Next)</p>
<ul>
<li>R = (等待时间 + 执行时间) / 执行时间</li>
<li>在短进程优先算法的基础上改进，<strong>不可抢占</strong>，<strong>关注进程的等待时间</strong>，<strong>可防止长进程无限期推迟</strong></li>
</ul>
</li>
<li><p>时间片轮转 (RR， Round Robin)</p>
<ul>
<li><strong>时间片</strong>，分配处理机资源的基本时间单元</li>
<li><strong>开销</strong>，额外的上下文切换；<ul>
<li>时间片太长，等待时间过长，极限情况下，退化成 FCFS</li>
<li>时间片太小，反应迅速，但产生大量上下文切换，增加开销</li>
</ul>
</li>
</ul>
</li>
<li><p>多级队列(MQ，Multilevel Queues)</p>
<ul>
<li>就绪队列分为 <strong>多个相对独立的队列</strong>，调度在队列间进行，每个队列拥有自己的调度策略。如 前台交互，使用 RR，保证响应速率；后台/批处理，使用 FCFS</li>
<li><strong>队列间调度</strong><ul>
<li>固定优先级，先前台，再处理后台，可能导致饥饿</li>
<li>时间片轮转，每个队列都等到一个确定的，能够调度其进程的 CPU 总时间。如 80%CPU 时间用于前台，后台 20%</li>
</ul>
</li>
</ul>
</li>
<li><p>多级反馈队列 (MFQ， Multilevel Feedback Queues)</p>
<ul>
<li>优先级队列中的时间片轮转有<strong>动态调整</strong><ul>
<li>一个进程可以在不同队列中移动，N 级优先队列</li>
<li>每个队列内部 使用 RR 轮换</li>
<li>时间片大小随优先级增加而增加，若进程在当前时间片没有完成，则降到下一个优先级</li>
<li><strong>I/O 幂集型进程 停留 在 高优先级</strong></li>
</ul>
</li>
</ul>
</li>
<li><p>公平共享 (FSS，Fair Share Scheduling)</p>
</li>
</ul>
<h2 id="同步互斥"><a href="#同步互斥" class="headerlink" title="同步互斥"></a>同步互斥</h2><ul>
<li><p>原子操作(Atomic Operation)， 一次不存在任何中断或失败的操作，<strong>要么成功，要么操作没执行</strong></p>
</li>
<li><p>利用 2 个原子操作实现一个锁</p>
</li>
<li><p>Lock.Acquire</p>
<ul>
<li>在锁别释放前一直等到，然后获得锁</li>
<li>如果 2 给线程都在等待同一个锁，并且同时发现锁被释放了，那么只有一个能够获得锁</li>
</ul>
</li>
<li><p>Lock.release</p>
</li>
</ul>
<h4 id="进程间交互关系"><a href="#进程间交互关系" class="headerlink" title="进程间交互关系"></a>进程间交互关系</h4><ul>
<li><p>互斥(mutual exclusion)， 一个进程占用资源，其它进程不能使用</p>
</li>
<li><p>死锁 (deadlock)，多个进程各占用部分资源，形成<strong>循环等待</strong></p>
</li>
<li><p>饥饿 (starvation)， 一个进程<strong>一直得不到资源</strong>，而其它进程可能轮流占用资源</p>
</li>
</ul>
<h4 id="临界区-Critical-Section"><a href="#临界区-Critical-Section" class="headerlink" title="临界区 (Critical Section)"></a>临界区 (Critical Section)</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">entry section       // 进入区</span><br><span class="line">	cirtical section  // 临界区</span><br><span class="line">exit section        // 退出区</span><br><span class="line">	remainder section</span><br></pre></td></tr></table></figure>

<ul>
<li>临界区，进程中 访问临界资源的一段 <strong>需要 互斥执行</strong>的代码</li>
<li>进入区，<strong>检查可否进入临界区</strong>的一段代码，如果可，则<strong>设置”正在访问临界区”标志</strong></li>
<li>退出区，<strong>清除”正在访问临界区”标志</strong></li>
</ul>
<h5 id="临界区访问规则"><a href="#临界区访问规则" class="headerlink" title="临界区访问规则"></a>临界区访问规则</h5><ul>
<li>空闲则入，没有进程在临界区，任何进程可进入</li>
<li>忙则等待，有进程在临界区，其他进程不能进入</li>
<li>有限等待，等待进入临界区的进程 <strong>不能无限期等待</strong></li>
<li>让权等待，不能进入临界区的进程，应释放 CPU</li>
</ul>
<h5 id="锁-抽象的数据结构"><a href="#锁-抽象的数据结构" class="headerlink" title="锁 (抽象的数据结构)"></a>锁 (抽象的数据结构)</h5><ul>
<li>一个二进制变量</li>
<li>Lock::Acquire(), 锁被释放前一直等待，然后得到锁</li>
<li>Lock::Release()， 锁释放后，唤醒任何等待进程</li>
</ul>
<h2 id="信号量与管程"><a href="#信号量与管程" class="headerlink" title="信号量与管程"></a>信号量与管程</h2><p><img src="/image/synchronized.png" alt="基本同步方法"></p>
<h3 id="信号量-Semaphore"><a href="#信号量-Semaphore" class="headerlink" title="信号量(Semaphore)"></a>信号量(Semaphore)</h3><p>信号量，是操作系统提供的一种协调共享资源的方法</p>
<p>信号是一种<strong>抽象数据结构</strong>，由一个<strong>整形变量</strong>和两个<strong>原子操作</strong>组成</p>
<ul>
<li>P(), sem—, 如果 sem&lt;0,等待，类似 Lock::Acquire()</li>
<li>V(),sem++, 如果 sem&lt;=0,说明当前有等着的进程，唤醒在信号量上的进程，一个或多个</li>
</ul>
<h5 id="信号量分类"><a href="#信号量分类" class="headerlink" title="信号量分类"></a>信号量分类</h5><ul>
<li>二级制信号量，约等于锁，取值 0，1</li>
<li>资源信号量，资源数目为任何 非负值</li>
</ul>
<h5 id="用信号量解决生产-消费问题"><a href="#用信号量解决生产-消费问题" class="headerlink" title="用信号量解决生产-消费问题"></a>用信号量解决生产-消费问题</h5><p>生产者 —&gt; 缓冲区 —&gt; 消费者</p>
<ul>
<li>一个或多个生产者 在生产数据后 放在 一个缓存区 中</li>
<li><strong>单个消费者</strong>从缓冲区 取出数据</li>
<li>任何时刻<strong>只能有一个</strong>生产者 或消费者 可访问缓冲区 (<strong>互斥访问</strong>)</li>
<li>缓存区空时，消费者必须等待生产者 <strong>(条件同步)</strong></li>
<li>缓冲区满时，生产者必须等待消费者 <strong>(条件同步)</strong></li>
</ul>
<h3 id="管程"><a href="#管程" class="headerlink" title="管程"></a>管程</h3><p><img src="/image/moniter.png" alt="同步-管程"></p>
<p><strong>管程，是一种用于多线程互斥访问 共享资源的程序结构</strong>。其组成：</p>
<ul>
<li>一个锁，控制管程代码的互斥访问</li>
<li>0 或多个<strong>条件变量</strong>，管理共享数据的并发访问</li>
</ul>
<h5 id="条件变量"><a href="#条件变量" class="headerlink" title="条件变量"></a>条件变量</h5><ul>
<li>进入管程的线程因资源被占用而进入等待状态</li>
<li>每个条件变量表示一种等待原因，对应一个等待队列</li>
<li>Wait()<ul>
<li>将自己阻塞在等待队列</li>
<li>唤醒一个等待者或释放管程的互斥访问</li>
</ul>
</li>
<li>Signal()<ul>
<li>将等待队列中的一个线程唤醒</li>
<li>如果等等待队列为空，则等同于 <strong>空操作</strong></li>
</ul>
</li>
</ul>
<h2 id="死锁、进程通信"><a href="#死锁、进程通信" class="headerlink" title="死锁、进程通信"></a>死锁、进程通信</h2><p>死锁，一组阻塞的进程，持有一种资源，等待获取另一个进程所占用的资源，而导致谁都无法执行。</p>
<p><strong>死锁必要条件</strong></p>
<ul>
<li>互斥</li>
<li>持有并等待</li>
<li>无抢占，一个资源只能被进程自愿释放</li>
<li>循环等待，形成闭环</li>
</ul>
<p><strong>死锁处理方法</strong></p>
<ul>
<li>死锁预防(Deadlock Prevention)， 确保系统永远不会进入死锁状态<ul>
<li>限制申请方式，任何时刻都不满足<strong>死锁的必要条件</strong><ul>
<li>互斥 - 把互斥的共享资源 封装 成可同时访问</li>
<li>只有并等待， 进程请求资源时，要求它<strong>不持有任何其它资源</strong>；允许进程在开始执行时，<strong>一次请求所有需要的资源</strong></li>
<li>非抢占，进程请求不能立即分配的资源，则释放已占用资源；只在能够同时获得所有需要资源时，才执行分配操作</li>
<li>循环等待， 对资源排序，要求进程按顺序请求资源</li>
</ul>
</li>
</ul>
</li>
<li>死锁避免 (Deadlock Avoidance)，在使用前进行判断，只允许不会出现死锁的进程 请求资源<ul>
<li>利用额外的先验信息，在分配资源时判断是否会出现死锁，<strong>只在不会死锁时分配资源</strong><ul>
<li>要求进程声明<strong>需要资源的最大数目</strong></li>
<li>限定提供、分配的资源数量，确保满足进程的最大需求</li>
<li><strong>动态检查</strong> 资源分配状态，确保不会出现环形等待</li>
</ul>
</li>
</ul>
</li>
<li>死锁检测和恢复(Deadlock Detection &amp; Recovery)，在检查到死锁后，进行恢复<ul>
<li>允许系统进入死锁</li>
<li>维护系统的资源分配图</li>
<li>定期调用死锁检测算法 搜索 图中是否存在死锁</li>
<li>出现死锁时，用死锁恢复机制 进行恢复</li>
</ul>
</li>
</ul>
<h4 id="安全状态"><a href="#安全状态" class="headerlink" title="安全状态"></a>安全状态</h4><ul>
<li><p>系统处于安全状态，一定没有死锁</p>
</li>
<li><p>系统处于不安全状态，可能出现死锁</p>
</li>
</ul>
<h4 id="银行家算法"><a href="#银行家算法" class="headerlink" title="银行家算法"></a>银行家算法</h4><p>银行家算法是一个<strong>避免死锁产生</strong>的算法，它以银行借贷分配策略为基础，判断并保证<strong>系统处于安全状态</strong></p>
<ul>
<li><p>客户在第一次申请贷款时，声明所需最大资源量，在满足所有贷款要求并完成项目时，及时归还</p>
</li>
<li><p>客户贷款数量不超过银行拥有的最大值时，银行家尽量满足客户需要</p>
</li>
<li><p>类比</p>
<ul>
<li>银行家 - 操作系统</li>
<li>资金 - 资源</li>
<li>客户 - 申请资源的线程</li>
</ul>
</li>
</ul>
<h4 id="进程通信-IPC，-Inter-Process-Communication"><a href="#进程通信-IPC，-Inter-Process-Communication" class="headerlink" title="进程通信(IPC， Inter-Process Communication)"></a>进程通信(IPC， Inter-Process Communication)</h4><ul>
<li>直接通信，一条链路对应一对通信进程，没对进程间只能有一个链路存在</li>
<li><strong>间接通信</strong><ul>
<li>通过操作系统维护的<strong>消息队列</strong>实现进程间的消息<ul>
<li>每个消息队列都有一个<strong>唯一的标识</strong></li>
<li>只有<strong>共享了相同消息队列的进程</strong>，才能够通信</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="共享内存"><a href="#共享内存" class="headerlink" title="共享内存"></a>共享内存</h4><ul>
<li>共享内存是把同一个物理内存区域同时映射到<strong>多个进程的内存地址空间</strong>的通信机制</li>
<li>进程，每个进程都</li>
</ul>
<h2 id="文件系统"><a href="#文件系统" class="headerlink" title="文件系统"></a>文件系统</h2><p>文件系统是操作系统中管理持久性数据的子系统，提供<strong>数据存储和访问功能</strong></p>
<p>文件是具有<strong>符号名</strong>，由<strong>字节序列</strong>构成的<strong>数据项集合</strong>。 它是文件系统的<strong>基本数据单元</strong>。<strong>文件名是文件的标识符号</strong></p>
<h4 id="文件系统的功能"><a href="#文件系统的功能" class="headerlink" title="文件系统的功能"></a>文件系统的功能</h4><ul>
<li>分配文件磁盘空间，管理文件块(位置或顺序)，管理空闲空间，分配算法</li>
<li>管理文件集合，<strong>定位</strong>(文件及其内容)，命名，文件系统结构</li>
<li>数据可靠和安全， 安全(<strong>多层次保护数据</strong>)，可靠</li>
</ul>
<p><strong>文件头：</strong> <strong>文件系统元数据</strong>中的文件信息(文件属性、文件存储位置、顺序)</p>
<h4 id="文件描述符"><a href="#文件描述符" class="headerlink" title="文件描述符"></a>文件描述符</h4><ul>
<li><strong>内核跟踪进程 打开的所有文件</strong>，操作系统为每个进程维护一个打开文件表；文件描述符就是<strong>打开文件的标识</strong></li>
<li><strong>文件描述符： 操作系统在打开文件表中维护的打开文件状态和信息</strong><ul>
<li><strong>文件指针：</strong> <strong>最近一次读写位置</strong>； <strong>每个进程分别维护自己的打开文件指针</strong></li>
<li><strong>文件打开计数：</strong> <strong>当前打开文件的次数</strong>， 当最后一个进程关闭文件时，将其从打开文件表中移除</li>
<li><strong>文件的磁盘位置：</strong>缓存数据访问信息</li>
<li><strong>访问权限：</strong> 每个程序访问模式信息</li>
</ul>
</li>
</ul>
<h4 id="文件的-用户视图-和-系统视图"><a href="#文件的-用户视图-和-系统视图" class="headerlink" title="文件的 用户视图 和 系统视图"></a>文件的 用户视图 和 系统视图</h4><p><strong>用户视图</strong>， 持久的数据结构</p>
<p><strong>系统视图</strong>， <strong>数据块的集合</strong>(块时逻辑存储单元，扇区是物理存储单元)</p>
<h4 id="用户视图-到-系统视图"><a href="#用户视图-到-系统视图" class="headerlink" title="用户视图 到 系统视图"></a>用户视图 到 系统视图</h4><p><strong>数据块 是 文件系统中基本操作单位</strong>，即使每次只访问 1 字节的数据，也需要缓存目标数据的一个数据块(4096 字节 4KB)</p>
<ul>
<li>进程度文件<ul>
<li>获取字节 所在的<strong>数据块</strong></li>
<li>返回数据块内对应部分</li>
</ul>
</li>
<li>进程写文件<ul>
<li>获取数据块</li>
<li>修改数据块中对应部分</li>
<li>写回数据块</li>
</ul>
</li>
</ul>
<h4 id="访问模式"><a href="#访问模式" class="headerlink" title="访问模式"></a>访问模式</h4><ul>
<li>顺序访问， 按字节一次读取</li>
<li>随机访问，随机读取</li>
<li>索引访问，依据数据特征索引</li>
</ul>
<h3 id="分层文件系统"><a href="#分层文件系统" class="headerlink" title="分层文件系统"></a>分层文件系统</h3><p>文件是以<strong>目录</strong>的方式组织起来</p>
<p><strong>目录：</strong> 是一类特殊的文件， 其内容是<strong>文件索引表&lt;文件名，指向文件的指针&gt;</strong></p>
<p><strong>文件别名</strong>， 2 个多多个文件名 关联 同给一个文件</p>
<ul>
<li>硬链接， 多个文件项 指向 一个文件，删除时，可能有个<strong>隐形计数器</strong>，删除一次减一，直到为 0 时才真正删除</li>
<li>软链接，以快捷方式指向其他文件 (通过存储 真实文件 的<strong>逻辑名称</strong> 来实现)。 删除时，这个别名成为一个<strong>空指针</strong></li>
</ul>
<h4 id="名字解析-路径遍历"><a href="#名字解析-路径遍历" class="headerlink" title="名字解析(路径遍历)"></a>名字解析(路径遍历)</h4><p>把<strong>逻辑名字</strong>转换成<strong>物理资源</strong>，递归<code>先读文件头，在读数据块，搜索子项</code></p>
<ul>
<li>依次遍历路径名，在文件系统中找到实际文件位置</li>
<li>遍历文件目录 直到 直到目标文件</li>
</ul>
<p>例如： 解析 <code>/bin/ls</code></p>
<ul>
<li>读取根目录的<strong>文件头</strong>(在磁盘固定位置)</li>
<li>读取根目录的数据块 ，搜索 “bin” 项</li>
<li>读取 bin 的文件头</li>
<li>读取 bin 的数据块 ，搜索 “ls” 项</li>
<li>读取 ls 的文件头</li>
</ul>
<h4 id="文件系统挂载"><a href="#文件系统挂载" class="headerlink" title="文件系统挂载"></a>文件系统挂载</h4><p>一个文件系统需要先<strong>挂载</strong>才能被访问，挂载点 在用户 看来 相当于 <strong>目录</strong>。</p>
<p>将额外的文件系统 与 根文件系统的某个 <strong>现存的目录建立关联关系</strong>，进而使得该目录作为其他文件<strong>访问入口</strong></p>
<h3 id="虚拟文件系统-VFS，Virtual-File-System"><a href="#虚拟文件系统-VFS，Virtual-File-System" class="headerlink" title="虚拟文件系统(VFS，Virtual File System)"></a>虚拟文件系统(VFS，Virtual File System)</h3><p>对不同文件系统的<strong>抽象</strong>，提供相同的文件和文件系统<strong>接口</strong>，管理所有文件和文件系统关联的<strong>数据结构</strong></p>
<h5 id="文件系统的基本数据结构"><a href="#文件系统的基本数据结构" class="headerlink" title="文件系统的基本数据结构"></a><strong>文件系统的基本数据结构</strong></h5><ul>
<li><strong>文件卷控制块</strong><ul>
<li>每个文件系统一个</li>
<li>文件系统详细信息</li>
<li>块、块大小、空余块、计数/指针等</li>
</ul>
</li>
<li><strong>文件控制块</strong><ul>
<li>每个文件一个</li>
<li>文件详细信息</li>
<li>访问权限、拥有者、大小、数据块位置等</li>
</ul>
</li>
<li><strong>目录项</strong><ul>
<li>每个目录项一个</li>
<li>将目录项 数据结构及树型布局 编码成 树型数据结构</li>
<li>指向文件控制块、父目录、子目录等</li>
</ul>
</li>
</ul>
<h5 id="文件系统的存储结构"><a href="#文件系统的存储结构" class="headerlink" title="文件系统的存储结构"></a>文件系统的存储结构</h5><ul>
<li>持久存储在外存</li>
<li>当需要时加载进内存<ul>
<li>卷 控制块，当文件系统挂载时进入内存</li>
<li>文件 控制块，当文件被访问是进入内存</li>
<li>目录节点，在遍历一个文件路径时进入 内存</li>
</ul>
</li>
</ul>
<h5 id="文件系统打开文件的数据结构"><a href="#文件系统打开文件的数据结构" class="headerlink" title="文件系统打开文件的数据结构"></a>文件系统打开文件的数据结构</h5><ul>
<li>文件描述符<ul>
<li>每个被打开的文件都有一个文件描述符</li>
<li>文件状态信息 (目录项、当前文件指针、文件操作设置…)</li>
</ul>
</li>
<li>打开文件表<ul>
<li>每个进程一个进程打开文件表</li>
<li>有<strong>一个系统级</strong>的打开文件表</li>
<li>有文件被打开时，文件卷就不能被卸载</li>
</ul>
</li>
</ul>
<h4 id="文件分配"><a href="#文件分配" class="headerlink" title="文件分配"></a>文件分配</h4><p>如何表示分配给一个文件数据块的位置和顺序</p>
<p><strong>分配方式</strong></p>
<ul>
<li>连续分配<ul>
<li>文件头指定起始块和长度</li>
<li>最先匹配，最佳匹配</li>
<li>优点，文件读取表现好，高效的顺序和随机访问</li>
<li>缺点，碎片，文件增长问题(预分配、按需分配)</li>
</ul>
</li>
<li>链式分配<ul>
<li>文件以<strong>数据块链表</strong>方式存储，文件头 包含 了 第一块 和 最后一块 的指针</li>
<li>优点，创建、增大、缩小容易；没有碎片</li>
<li>缺点，无法实现随机访问；可靠性差(破坏一个链，后面的数据块就丢了)</li>
</ul>
</li>
<li>索引分配<ul>
<li>为每个文件创建一个索引数据块，指向文件数据块的指针列表；文件头 包含了索引数据块 指针</li>
<li>优点，创建、增大、缩小容易；没有碎片，支持直接访问</li>
<li>缺点，文件很小时，存储索引开销大；大文件索引难处理</li>
</ul>
</li>
</ul>
<h5 id="UFS-多级索引分配"><a href="#UFS-多级索引分配" class="headerlink" title="UFS 多级索引分配"></a>UFS 多级索引分配</h5><p><img src="/image/UFS.png" alt="UFS多级索引分配"></p>
<ul>
<li>文件头包含 13 个指针<ul>
<li>前 10 个指针指向数据块</li>
<li>第 11 个指针 指向 索引块</li>
<li>第 12 给指针指向二级索引块</li>
<li>第 13 个指针指向三级索引块</li>
</ul>
</li>
</ul>
<h3 id="空闲空间管理"><a href="#空闲空间管理" class="headerlink" title="空闲空间管理"></a>空闲空间管理</h3><p>用<strong>位图</strong>代表空闲数据块列表</p>
<p>使用简单但是可能会是一个很大的<strong>向量表</strong>， 160G 磁盘 -&gt; 40M 数据块 -&gt; 5MB 位图</p>
<p>假设空闲空间在磁盘中均匀分布，则找到 “0”之前要扫描 n(数据块总数)/r(空闲块总数)</p>
<h4 id="磁盘分区、文件卷"><a href="#磁盘分区、文件卷" class="headerlink" title="磁盘分区、文件卷"></a>磁盘分区、文件卷</h4><p>通常磁盘通过<strong>分区</strong>来最大限制 减少寻道时间</p>
<ul>
<li>分区 是 一组柱面的集合</li>
<li>每个分区 都可视为 逻辑上独立的磁盘</li>
</ul>
<p><strong>文件卷</strong>： 已个拥有完整文件系统实例的外存空间，通常常驻在磁盘的单个分区上</p>
<h4 id="多磁盘管理"><a href="#多磁盘管理" class="headerlink" title="多磁盘管理"></a>多磁盘管理</h4><p>使用多磁盘可改善 <strong>吞吐量（通过并行）</strong>，<strong>可靠性和可用性 （通过冗余）</strong></p>
<h5 id="RAID-冗余磁盘队列（RedundantArray-of-Inexpensive-Disks）"><a href="#RAID-冗余磁盘队列（RedundantArray-of-Inexpensive-Disks）" class="headerlink" title="RAID 冗余磁盘队列（RedundantArray of Inexpensive Disks）"></a><strong>RAID 冗余磁盘队列（RedundantArray of Inexpensive Disks）</strong></h5><ul>
<li><p>RAID-0，磁盘条带化</p>
<p>把数据块分成多<strong>个子块</strong>，存储在<strong>独立的磁盘</strong>中；通过独立磁盘上<strong>并行数据块访问</strong> 提供更大的磁盘带宽</p>
</li>
<li><p>RAID-1，磁盘镜像</p>
<p>向 2 个磁盘写入，从任何一个读取；可靠性成倍增长，读取性线性增加</p>
</li>
<li><p>RAID-4，带校验的磁盘条带化</p>
<p>数据块级 的磁盘条带化 + 专用奇偶校验磁盘； <strong>能从任意一个故障磁盘中恢复</strong></p>
</li>
<li><p>RAID-5，带分布式校验的磁盘条带化</p>
</li>
</ul>
<h2 id="I-O-子系统"><a href="#I-O-子系统" class="headerlink" title="I/O 子系统"></a>I/O 子系统</h2><h5 id="常见设备接口类型"><a href="#常见设备接口类型" class="headerlink" title="常见设备接口类型"></a>常见设备接口类型</h5><ul>
<li>字符设备，键盘、鼠标、串口等，以<strong>字节</strong>单位<strong>顺序</strong>访问，get(),put()</li>
<li>块设备，磁盘驱动器、光驱等，<strong>均匀的数据块</strong>访问，原始 IO 或文件系统接口，内存映射文件系统接口</li>
<li>网络设备，以太网、无线、蓝牙等，<strong>格式化报文交换</strong>，send/receive 网络报文，网络接口</li>
</ul>
<h5 id="同步、异步-I-O"><a href="#同步、异步-I-O" class="headerlink" title="同步、异步 I/O"></a>同步、异步 I/O</h5><ul>
<li>阻塞 I/O，”wait”<ul>
<li>读数据时，进程 将进入 <strong>等待状态</strong>，直到完成数据读取</li>
<li>写数据时，进程 将进入 <strong>等待状态</strong>，直到设备完成数据写入处理</li>
</ul>
</li>
<li>非阻塞 I/O， “Don’t Wait”<ul>
<li>立即从 read/write 系统调用返回，返回值 为成功传输字节数，可能为 0</li>
</ul>
</li>
<li>异步 I/O， “Tell Me Later”<ul>
<li>读数据时，使用指针标记好用户缓冲区，立即返回；稍后<strong>内核将填充缓冲区并通知用户</strong></li>
<li>写数据时，使用指针标记好用户缓冲区，立即返回；稍后内核 将 处理数据并通知用户</li>
</ul>
</li>
</ul>
<h3 id="I-O-结构"><a href="#I-O-结构" class="headerlink" title="I/O 结构"></a>I/O 结构</h3><p>CPU 北桥连 高速设备， 南桥 连 IO 设备</p>
<h5 id="CPU-与设备的连接"><a href="#CPU-与设备的连接" class="headerlink" title="CPU 与设备的连接"></a>CPU 与设备的连接</h5><ul>
<li>设备控制器： CPU 与 IO 间的<strong>接口</strong>，向 CPU 提供特殊指令和寄存器</li>
<li>IO 地址： CPU 用来控制 IO 硬件，内存地址或端口号</li>
<li>CPU 与设备的通信方式： <strong>轮询 、设备中断、DMA（直接内存访问）</strong></li>
</ul>
<h5 id="IO-指令、内存映射-IO"><a href="#IO-指令、内存映射-IO" class="headerlink" title="IO 指令、内存映射 IO"></a>IO 指令、内存映射 IO</h5><ul>
<li>IO 指令，通过 IO 端口号访问 设备寄存器，特殊 CPU 指令</li>
<li>内存映射 IO，设备寄存器/存储 被映射到 内存物理地址空间中<ul>
<li>通过 内存 load/store 指令 完成 IO 操作</li>
<li>MMU 设置映射，硬件跳线或程序启动是设置地址</li>
</ul>
</li>
</ul>
<h5 id="I-O-请求声明周期"><a href="#I-O-请求声明周期" class="headerlink" title="I/O 请求声明周期"></a>I/O 请求声明周期</h5><p><img src="/image/IO_lifecycle.png" alt="I/O请求声明周期"></p>
<h5 id="CPU-与-设备控制器-的数据传输"><a href="#CPU-与-设备控制器-的数据传输" class="headerlink" title="CPU 与 设备控制器 的数据传输"></a>CPU 与 设备控制器 的数据传输</h5><ul>
<li><p>**程序控制 IO(PIO)**， 通过 CPU 的 load/store 传输所有数据</p>
<ul>
<li>硬件简单、编程容易，消耗的 CPU 时间和数据量成正比</li>
<li>适用于简单的、小型的设备 I/O</li>
</ul>
</li>
<li><p><strong>直接内存访问（DMA）</strong>， 设备控制器可 <strong>直接 访问 系统总线</strong>，控制器直接与内存互相传输数据</p>
<ul>
<li>设备传输数据不影响 CPU，需要 CPU 参与设置</li>
<li>适用高吞吐量 I/O</li>
</ul>
</li>
</ul>
<h5 id="通过直接-I-O-寻址-读取-磁盘数据"><a href="#通过直接-I-O-寻址-读取-磁盘数据" class="headerlink" title="通过直接 I/O 寻址 读取 磁盘数据"></a>通过直接 I/O 寻址 读取 磁盘数据</h5><p><img src="/image/read-disk-by-direct-IO-address.png" alt="通过直接I/O寻址 读取 磁盘数据 "></p>
<h5 id="I-O-设备通知操作系统的机制"><a href="#I-O-设备通知操作系统的机制" class="headerlink" title="I/O 设备通知操作系统的机制"></a>I/O 设备通知操作系统的机制</h5><ul>
<li>操作系统需要了解设备状态<ul>
<li>I/O 操作完成时间</li>
<li>I/O 操作遇到的错误</li>
</ul>
</li>
<li>通知方式<ul>
<li><strong>CPU 主动轮询</strong> ：IO 设置在<strong>特定的状态寄存器</strong>中放置<strong>状态和错误信息</strong>，操作系统<strong>定期检测寄存器</strong></li>
<li>设备中断</li>
</ul>
</li>
</ul>

      
    </div>
    <div class="article-footer">
      <blockquote class="mt-2x">
  <ul class="post-copyright list-unstyled">
    
    <li class="post-copyright-link hidden-xs">
      <strong>本文链接：</strong>
      <a href="https://better-jiang.github.io/2022/03/30/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%88%9D%E8%AF%86/" title="操作系统初识" target="_blank" rel="external">https://better-jiang.github.io/2022/03/30/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%88%9D%E8%AF%86/</a>
    </li>
    
    <li class="post-copyright-license">
      <strong>版权声明： </strong> 本博客所有文章除特别声明外，均采用 <a href="http://creativecommons.org/licenses/by/4.0/deed.zh" target="_blank" rel="external">CC BY 4.0 CN协议</a> 许可协议。转载请注明出处！
    </li>
  </ul>
</blockquote>


<div class="panel panel-default panel-badger">
  <div class="panel-body">
    <figure class="media">
      <div class="media-left">
        <a href="https://github.com/Better-Jiang" target="_blank" class="img-burn thumb-sm visible-lg">
          <img src="/images/avatar.jpg" class="img-rounded w-full" alt="">
        </a>
      </div>
      <div class="media-body">
        <h3 class="media-heading"><a href="https://github.com/Better-Jiang" target="_blank"><span class="text-dark">爱学兮的小江</span><small class="ml-1x">Web前端 &amp; Vue</small></a></h3>
        <div>前端菜狗，偶尔思考，间歇式码字</div>
      </div>
    </figure>
  </div>
</div>


    </div>
  </article>
  
    
  <section id="comments">
  	
           
    
  </section>


  
</div>

  <nav class="bar bar-footer clearfix" data-stick-bottom>
  <div class="bar-inner">
  
  <ul class="pager pull-left">
    
    <li class="prev">
      <a href="/2022/04/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%88%9D%E8%AF%86/" title="计算机网络初识"><i class="icon icon-angle-left" aria-hidden="true"></i><span>&nbsp;&nbsp;上一篇</span></a>
    </li>
    
    
    <li class="next">
      <a href="/2022/03/27/linux-%E5%85%A5%E9%97%A8/" title="linux 入门"><span>下一篇&nbsp;&nbsp;</span><i class="icon icon-angle-right" aria-hidden="true"></i></a>
    </li>
    
    
  </ul>
  
  
  <!-- Button trigger modal -->
  <button type="button" class="btn btn-fancy btn-donate pop-onhover bg-gradient-warning" data-toggle="modal" data-target="#donateModal"><span>赏</span></button>
  <!-- <div class="wave-icon wave-icon-danger btn-donate" data-toggle="modal" data-target="#donateModal">
    <div class="wave-circle"><span class="icon"><i class="icon icon-bill"></i></span></div>
  </div> -->
  
  
  <div class="bar-right">
    
    <div class="share-component" data-sites="wechat" data-mobile-sites=""></div>
    
  </div>
  </div>
</nav>
  
<!-- Modal -->
<div class="modal modal-center modal-small modal-xs-full fade" id="donateModal" tabindex="-1" role="dialog">
  <div class="modal-dialog" role="document">
    <div class="modal-content donate">
      <button type="button" class="close" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">&times;</span></button>
      <div class="modal-body">
        <div class="donate-box">
          <div class="donate-head">
            <p>感谢您的支持，我会继续努力的!</p>
          </div>
          <div class="tab-content">
            <div role="tabpanel" class="tab-pane fade active in" id="alipay">
              <div class="donate-payimg">
                <img src="/images/donate/alipayimg.png" alt="扫码支持" title="扫一扫" />
              </div>
              <p class="text-muted mv">扫码打赏，你说多少就多少</p>
              <p class="text-grey">打开支付宝扫一扫，即可进行扫码打赏哦</p>
            </div>
            <div role="tabpanel" class="tab-pane fade" id="wechatpay">
              <div class="donate-payimg">
                <img src="/images/donate/wechatpayimg.png" alt="扫码支持" title="扫一扫" />
              </div>
              <p class="text-muted mv">扫码打赏，你说多少就多少</p>
              <p class="text-grey">打开微信扫一扫，即可进行扫码打赏哦</p>
            </div>
          </div>
          <div class="donate-footer">
            <ul class="nav nav-tabs nav-justified" role="tablist">
              <li role="presentation" class="active">
                <a href="#alipay" id="alipay-tab" role="tab" data-toggle="tab" aria-controls="alipay" aria-expanded="true"><i class="icon icon-alipay"></i> 支付宝</a>
              </li>
              <li role="presentation" class="">
                <a href="#wechatpay" role="tab" id="wechatpay-tab" data-toggle="tab" aria-controls="wechatpay" aria-expanded="false"><i class="icon icon-wepay"></i> 微信支付</a>
              </li>
            </ul>
          </div>
        </div>
      </div>
    </div>
  </div>
</div>



</main>

  <footer class="footer" itemscope itemtype="http://schema.org/WPFooter">
	
	
    <ul class="social-links">
    	
        <li><a href="https://github.com/Better-Jiang" target="_blank" title="Github" data-toggle=tooltip data-placement=top><i class="icon icon-github"></i></a></li>
        
    </ul>

    <div class="copyright">
    	
        <div class="publishby">
        	Theme by <a href="https://github.com/cofess" target="_blank"> cofess </a>base on <a href="https://github.com/cofess/hexo-theme-pure" target="_blank">pure</a>.
        </div>
    </div>
</footer>
  <script src="//cdn.jsdelivr.net/npm/jquery@1.12.4/dist/jquery.min.js"></script>
<script>
window.jQuery || document.write('<script src="js/jquery.min.js"><\/script>')
</script>

<script src="/js/plugin.min.js"></script>


<script src="/js/application.js"></script>


    <script>
(function (window) {
    var INSIGHT_CONFIG = {
        TRANSLATION: {
            POSTS: '文章',
            PAGES: '页面',
            CATEGORIES: '分类',
            TAGS: '标签',
            UNTITLED: '(未命名)',
        },
        ROOT_URL: '/',
        CONTENT_URL: '/content.json',
    };
    window.INSIGHT_CONFIG = INSIGHT_CONFIG;
})(window);
</script>

<script src="/js/insight.js"></script>






   
<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>





   
    
  <!-- <link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"> -->
  <script src="//cdn.jsdelivr.net/npm/gitalk@1.4.0/dist/gitalk.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/blueimp-md5@2.10.0/js/md5.min.js"></script>
  <script type="text/javascript">
  var gitalk = new Gitalk({
    clientID: '3c9348a5e84eb5050ec8',
    clientSecret: 'b92d8dd66f66bbe04d870af0e612ff74a00546da',
    repo: 'Better-Jiang.github.io',
    owner: 'Better-Jiang',
    admin: ['Better-Jiang'],
    id: md5(location.pathname),
    distractionFreeMode: true
  })
  gitalk.render('comments')
  </script>

      



  <script src="//cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.3.5/dist/jquery.fancybox.min.js"></script>
  <script>
  //利用 FancyBox 实现点击图片放大
  $(document).ready(function() {
    $('article img').not('[hidden]').not('.panel-body img').each(function() {
      var $image = $(this);
      var imageCaption = $image.attr('alt');
      var $imageWrapLink = $image.parent('a');
      if ($imageWrapLink.length < 1) {
        var src = this.getAttribute('src');
        var idx = src.lastIndexOf('?');
        if (idx != -1) {
          src = src.substring(0, idx);
        }
        $imageWrapLink = $image.wrap('<a href="' + src + '"></a>').parent('a');
      }
      $imageWrapLink.attr('data-fancybox', 'images');
      if (imageCaption) {
        $imageWrapLink.attr('data-caption', imageCaption);
      }
    });
    $().fancybox({
      selector: '[data-fancybox="images"]',
      hash: false,
      loop: false,
    });
  });
  </script>





</body>
</html>